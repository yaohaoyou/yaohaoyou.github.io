{"posts":[{"title":"讲题-XDFZ","content":"◊\\Large\\color{red}\\Diamond◊是关键转化。FakePlasticTrees2首先有个比较简单的dp，令fu,i,jf_{u,i,j}fu,i,j​表示uuu子树内删了iii条边，目前uuu连通块的大小为jjj是否可行。转移就类似树上背包合并，考虑如何优化jjj这一维。显然jjj的最大值是Tu−iLT_u-iLTu​−iL，最小值是Tu−iRT_u-iRTu​−iR，其中TuT_uTu​表示uuu子树内的AAA和，所以jjj的极差≤i(R−L)\\lei(R-L)≤i(R−L)。接着证明对于j=x,y,z(x&lt;y&lt;z,z−x&lt;R−L)j=x,y,z(x&lt;y&lt;z,z-x&lt;R-L)j=x,y,z(x&lt;y&lt;z,z−x&lt;R−L)时，状态yyy可以省略掉◊\\Large\\color{red}\\Diamond◊，设选择了yyy后最后形成的连通块大小为sz∈[l,r]sz\\in[l,r]sz∈[l,r]，则新增了sz−ysz-ysz−y，分讨后可以证明sz−y+xsz-y+xsz−y+x和sz−y+zsz-y+zsz−y+z至少一个会∈[l,r]\\in[l,r]∈[l,r]，所以yyy状态可以不计。此时所有记录的递增状态j1,j2…jsj_1,j_2\\dotsj_sj1​,j2​…js​都满足ji+2−ji≥R−Lj_{i+2}-j_i\\geR-Lji+2​−ji​≥R−L，而又O(k)\\mathcalO(k)O(k)个。所以状态只有O(nk2)\\mathcalO(nk^2)O(nk2)了，总复杂度为O(nk3)\\mathcalO(nk^3)O(nk3)。具体为什么不是O(nk4)\\mathcalO(nk^4)O(nk4)，是因为fu,if_{u,i}fu,i​和fv,jf_{v,j}fv,j​卷的时候由于树上背包的证明是O(nk)\\mathcalO(nk)O(nk)的，剩余两个卷积是O(k2)\\mathcalO(k^2)O(k2)的。P9266[PA2022]Nawiasowepodziały令w(l,r)w(l,r)w(l,r)表示区间[l,r][l,r][l,r]中所有子串中合法括号序列数量，可以证明www满足四边形不等式。令fi,jf_{i,j}fi,j​表示前iii个字符分成了jjj段的方案数，则fi,j=min⁡k&lt;ifk−1,j−1+w(k,i)f_{i,j}=\\min_{k&lt;i}f_{k-1,j-1}+w(k,i)fi,j​=mink&lt;i​fk−1,j−1​+w(k,i)，所以F(x)=fn,xF(x)=f_{n,x}F(x)=fn,x​为下凸函数。套路地，显示使用wqs二分，然后需要求gi=min⁡j&lt;igj−1+w(j,i)−midg_i=\\min_{j&lt;i}g_{j-1}+w(j,i)-midgi​=minj&lt;i​gj−1​+w(j,i)−mid。因为www满足四边形不等式，所以ggg满足决策单调性，但www不好直接求，并且ggg求解过程需要在线。发现w(l,r)w(l,r)w(l,r)在做l→l±1l\\tol\\pm1l→l±1或r→r±1r\\tor\\pm1r→r±1时可以直接O(1)\\mathcalO(1)O(1)求解，所以可以用cdq分治套决策单调性分治解决，复杂度为O(nlog⁡3n)\\mathcalO(n\\log^3n)O(nlog3n)。但是可以使用LARSCH/简化LARSCH（感觉像科技）算法优化至dp部分只要O(n)/O(nlog⁡n)\\mathcalO(n)/\\mathcalO(n\\logn)O(n)/O(nlogn)，总复杂度为O(nlog⁡n/nlog⁡2n)\\mathcalO(n\\logn/n\\log^2n)O(nlogn/nlog2n)。◊\\Large\\color{red}\\Diamond◊简化LARSCH算法其实类似于cdq分治套决策单调性分治，令optt(x)opt_t(x)optt​(x)表示只考虑从[1,t][1,t][1,t]的转移到xxx的最优决策，opt(x)=optx−1(x)opt(x)=opt_{x-1}(x)opt(x)=optx−1​(x)。具体过程是定义solve(l,r)solve(l,r)solve(l,r)表示已知[1,l)[1,l)[1,l)的g,optg,optg,opt和optl−1(r)opt_{l-1}(r)optl−1​(r)，求解[1,r][1,r][1,r]的g,optg,optg,opt。用i∈[optl−1,optl−1,r]i\\in[opt_{l-1},opt_{l-1,r}]i∈[optl−1​,optl−1,r​]求出optl−1(mid)opt_{l-1}(mid)optl−1​(mid)，因为optt(x)≤optt(y)≤optt(z),x&lt;y&lt;zopt_{t}(x)\\leopt_{t}(y)\\leopt_{t}(z),x&lt;y&lt;zoptt​(x)≤optt​(y)≤optt​(z),x&lt;y&lt;z。调用solve(l,mid)solve(l,mid)solve(l,mid)。用opt(i),i∈[l,mid]opt(i),i\\in[l,mid]opt(i),i∈[l,mid]和optl−1(r)opt_{l-1}(r)optl−1​(r)求出optmid(r)opt_{mid}(r)optmid​(r)。调用solve(mid+1,r)solve(mid+1,r)solve(mid+1,r)。注意1操作中要移动w1w1w1的指针，3操作中要移动w2w2w2的指针，可以证明整个过程中w1w1w1和w2w2w2的指针一共只会移动O(nlog⁡n)\\mathcalO(n\\logn)O(nlogn)次，若两种操作移动同一对指针会退化到O(n2)\\mathcalO(n^2)O(n2)次。P6782[Ynoi2008]rplexq考虑对于每个点的度数和儿子子树大小根号分治，对于度数≤B\\leB≤B的点的询问考虑暴力枚举每个儿子，&gt;B&gt;B&gt;B的点只有O(n)\\mathcalO(\\sqrtn)O(n​)个再考虑优化。◊\\Large\\color{red}\\Diamond◊记f(u,l,r)f(u,l,r)f(u,l,r)表示uuu子树中编号在[l,r][l,r][l,r]的点的数量，则对于询问(l,r,x)(l,r,x)(l,r,x)答案就是(f(x,l,r)2)−∑vissonofx(f(v,l,r)2)\\binom{f(x,l,r)}2-\\sum_\\text{vissonofx}\\binom{f(v,l,r)}{2}(2f(x,l,r)​)−∑vissonofx​(2f(v,l,r)​)。对于degx≤ndeg_x\\le\\sqrtndegx​≤n​，直接枚举vvv后就会形成O(nn)\\mathcalO(n\\sqrtn)O(nn​)个求子树内编号在[l,r][l,r][l,r]的数量的询问，把子树用dfs序拍掉就是O(n)\\mathcalO(n)O(n)个点O(nn)\\mathcalO(n\\sqrtn)O(nn​)次询问二维数点，离线后就是O(n)\\mathcalO(n)O(n)次单点加，O(nn)\\mathcalO(n\\sqrtn)O(nn​)次区间求和，可以使用分块内记录块内和块间前缀和做到O(n)−O(1)\\mathcalO(\\sqrtn)-\\mathcalO(1)O(n​)−O(1)修改/查询，复杂度为O(nn)\\mathcalO(n\\sqrtn)O(nn​)。但是空间还是O(nn)\\mathcalO(n\\sqrtn)O(nn​)，因为要存下O(nn)\\mathcalO(n\\sqrtn)O(nn​)个询问，可以发现xxx的儿子的询问区间互不相交，所以可以扫描求完最小的区间后再把下一个加入，空间就是O(n)\\mathcalO(n)O(n)的了。剩下考虑degx&gt;ndeg_x&gt;\\sqrtndegx​&gt;n​的怎么做。再次考虑分成两种情况，对于xxx的儿子vvv的子树大小&gt;n&gt;\\sqrtn&gt;n​的，xxx只会有n\\sqrtnn​个这种儿子，可以理解为度数只有n\\sqrtnn​，所以直接套用上面的做法即可。◊\\Large\\color{red}\\Diamond◊对于vvv子树大小≤n\\le\\sqrtn≤n​，直接暴力O(sizv2)\\mathcalO(siz_v^2)O(sizv2​)枚举出所有二元组(x,y),x&lt;y(x,y),x&lt;y(x,y),x&lt;y，若满足l≤x&lt;y≤rl\\lex&lt;y\\lerl≤x&lt;y≤r就会贡献答案，这也是一个二维偏序（数点），但是现在有O(nn)\\mathcalO(n\\sqrtn)O(nn​)对修改，O(m)\\mathcalO(m)O(m)个询问，使用O(1)−O(n)\\mathcalO(1)-\\mathcalO(\\sqrtn)O(1)−O(n​)的分块处理即可。这部分的复杂度还是O(nn)\\mathcalO(n\\sqrtn)O(nn​)的，修改简单处理就可以做到线性空间。总结一下就是直接对于每个点的儿子子树中前n\\sqrtnn​大的做O(n)−O(1)\\mathcalO(\\sqrtn)-O(1)O(n​)−O(1)的二维数点，对剩余的做O(1)−O(n)\\mathcalO(1)-\\mathcalO(\\sqrtn)O(1)−O(n​)的二维数点。OmniscientArtist首先将二维数点离线扫描线改成对aaa做区间±1\\pm1±1，由于ai≤na_i\\lenai​≤n，所以mmm的倍数只会有O(nm)\\mathcalO(\\fracnm)O(mn​)种。考虑以BBB为块长做序列分块，区间加是好做的，由于初始时aaa的差分数组都是ci=0c_i=0ci​=0，每次区间加会让cl←cl±1,cr+1←cr+1∓1c_l\\getsc_{l}\\pm1,c_{r+1}\\getsc_{r+1}\\mp1cl​←cl​±1,cr+1​←cr+1​∓1，只会有O(n)\\mathcalO(n)O(n)次区间加，所以∑∣ci∣≤2n\\sum|c_i|\\le2n∑∣ci​∣≤2n，所以每个块内的max⁡−min⁡\\max-\\minmax−min的和是O(n)\\mathcalO(n)O(n)级别的。询问时对每个块内枚举mmm的倍数并查询出现次数即可，mmm的倍数一共只会有O(max⁡−min⁡m)\\mathcalO(\\frac{\\max-\\min}m)O(mmax−min​)个，所以查询复杂度为O(nm)\\mathcalO(\\fracnm)O(mn​)，区间加复杂度为O(nB+B)\\mathcalO(\\fracnB+B)O(Bn​+B)，平衡后整体复杂度为O(nn)\\mathcalO(n\\sqrtn)O(nn​)。注意重构的时候应该对每个块内的数删除而不是O(max⁡−min⁡)\\mathcalO(\\max-\\min)O(max−min)的清空，否则复杂度会退化到O(n2)\\mathcalO(n^2)O(n2)。P14836[THUPC2026初赛]能量分配这也太困难了。p←317p\\gets317p←317，固定ccc数组后，分配宝石的方案数就是(nc1,c2,…cm)\\binom{n}{c_1,c_2,\\dotsc_m}(c1​,c2​,…cm​n​)，由Lucas定理的过程可以得到(nc1,c2…cn)≡0(modp)\\binom{n}{c_1,c_2\\dotsc_n}\\not\\equiv0(\\bmodp)(c1​,c2​…cn​n​)​≡0(modp)的必要条件是∀k,∑bitk(ci)=bitk(n)\\forallk,\\sumbit_k(c_i)=bit_k(n)∀k,∑bitk​(ci​)=bitk​(n)，其中bitk(x)bit_k(x)bitk​(x)表示xxx在ppp进制下的第kkk位，即需要满足∑ci\\sumc_i∑ci​求和过程中不能在ppp进制下进位。◊\\Large\\color{red}\\Diamond◊先考虑n&lt;pn&lt;pn&lt;p，此时就只有一层。考虑直接枚举排序后cic_ici​之间的偏序关系，即相邻的两个位置之间的关系是&lt;还是=，一共只有O(2m−1)\\mathcalO(2^{m-1})O(2m−1)种。然后在确定相对偏序关系后，(nc1,c2…cm)\\binomn{c_1,c_2\\dotsc_m}(c1​,c2​…cm​n​)的贡献和A,BA,BA,B造成的贡献就独立了，分别考虑。◊\\Large\\color{red}\\Diamond◊先考虑求出A,BA,BA,B的贡献。令dpS1,S2dp_{S1,S2}dpS1,S2​表示已经填入了集合S1S1S1的选手，前面的偏序关系是S2S2S2的贡献和，转移考虑枚举一个新的极长的相等段，选手编号集合为S3S3S3，然后可以提前预处理出wS1,S3w_{S1,S3}wS1,S3​造成的贡献进行转移。复杂度为O(∑i=1m(mi)×2i−1×2m−i)=O(4m)\\mathcalO(\\sum_{i=1}^m\\binom{m}{i}\\times2^{i-1}\\times2^{m-i})=\\mathcalO(4^m)O(∑i=1m​(im​)×2i−1×2m−i)=O(4m)。然后考虑求(nc1,c2…cm)\\binom{n}{c_1,c_2\\dotsc_m}(c1​,c2​…cm​n​)的贡献。由于cic_ici​的顺序不影响，所以这里只计算ccc有序时的贡献和。令fi,j,Sf_{i,j,S}fi,j,S​表示前iii个数和为jjj，相对偏序关系为SSS的总贡献，转移时讨论ci+1c_{i+1}ci+1​与cic_ici​的偏序关系。复杂度为O(∑i=1m2i−1p2)=O(2mp2)\\mathcalO(\\sum_{i=1}^m2^{i-1}p^2)=\\mathcalO(2^mp^2)O(∑i=1m​2i−1p2)=O(2mp2)。拓展到n≥pn\\gepn≥p，现在一共有log⁡pn\\log_pnlogp​n层。类似上面的做法，将两种贡献分开计算，A,BA,BA,B造成的贡献直接O(4m)\\mathcalO(4^m)O(4m)预处理即可。考虑如何适应层数对偏序关系的影响。从高位到低位，原本相等的一段区间可能会分裂成几个有序的区间，考虑用dp记录这个过程。令fi,Sf_{i,S}fi,S​表示到达iii层时的偏序关系为SSS的方案数（bit2(S)=[ci≠ci+1]bit_2(S)=[c_i\\nec_{i+1}]bit2​(S)=[ci​​=ci+1​]），考虑从fi,Sf_{i,S}fi,S​转移到fi−1,S′f_{i-1,S&#x27;}fi−1,S′​（S⊆S′S\\subeS&#x27;S⊆S′）的转移系数gS,S′,biti−1(n)g_{S,S&#x27;,bit_{i-1}(n)}gS,S′,biti−1​(n)​，实际上gS,S′,ig_{S,S&#x27;,i}gS,S′,i​可以将这个过程分成SSS的每个0区间（等价类）变成S′S&#x27;S′对应区间后对∑bitk(c)\\sumbit_k(c)∑bitk​(c)维做卷积得来的。具体的，令hS,ih_{S,i}hS,i​表示相对偏序关系为SSS，∑c=i\\sumc=i∑c=i的方案数，则(S,S′)(S,S&#x27;)(S,S′)的转移可以通过hS,ih_{S,i}hS,i​的第二维iii的和卷积得来。hhh的转移和上一段落中的类似，ggg的状态中有许多可以通过记忆化解决◊\\Large\\color{red}\\Diamond◊，比如下图中三个绿色段的相对顺序不会影响ggg的值，所以可以将其排序后存入map进行记忆化。令map的大小为F(m)F(m)F(m)，则预处理ggg的复杂度为O(F(m)p2)\\mathcalO(F(m)p^2)O(F(m)p2)。若没有记忆化，F(m)=3mF(m)=3^mF(m)=3m（即枚举S⊆S′S\\subeS&#x27;S⊆S′），但是显然记忆化后会大幅减少状态数，实际上F(12)=17547\\color{red}F(12)=17547F(12)=17547。对于每次询问跑fff转移后记得最后与前面算的A,BA,BA,B造成的贡献dpdpdp拼起来。总复杂度为O(4m+F(m)p2+q3mlog⁡pn)\\mathcalO(4^m+F(m)p^2+q3^m\\log_pn)O(4m+F(m)p2+q3mlogp​n)。倒闭了，写不了一点，还要卡常，下播了。upd.改完了。最小乘积由于A,BA,BA,B很小，所以考虑直接枚举其中一个。令fu,if_{u,i}fu,i​表示到uuu时经过的∑a=i\\suma=i∑a=i的最小的∑b\\sumb∑b，转移不难发现由于ai&gt;0a_i&gt;0ai​&gt;0，所以这个转移是分层图，可以从小到大枚举iii后枚举每条边转移，复杂度为O((n+m)mV)\\mathcalO((n+m)mV)O((n+m)mV)，若没有发现分层图直接跑dijkstra会多一只log无法通过。CF280Dk-MaximumSubsequenceSum由于kkk和∑k\\sumk∑k很小，可以考虑模拟费用流。首先有个显然的费用流模型，对每个iii连边(S,i,1,0),(i,i+1,1,ai),(i,T,1,0)(S,i,1,0),(i,i+1,1,a_i),(i,T,1,0)(S,i,1,0),(i,i+1,1,ai​),(i,T,1,0)，还有kkk的限制所以答案就是在这个图中增广kkk次的最大花费。每次增广就是找到当前的最大区间和，然后将经过的链上的边反向并将费用变成相反数◊\\Large\\color{red}\\Diamond◊。这个过程可以使用线段树模拟，就是做最大子段和还有区间取相反数，复杂度为O(qlog⁡n+∑knlog⁡n)\\mathcalO(q\\logn+\\sumkn\\logn)O(qlogn+∑knlogn)。其实也可以从反悔贪心的方面思考刚刚的过程，就是先取当前和最大的区间[l,r][l,r][l,r]，然后反悔再选取[l′,r′]⊆[l,r][l&#x27;,r&#x27;]\\sube[l,r][l′,r′]⊆[l,r]并减去sum[l′,r′]sum[l&#x27;,r&#x27;]sum[l′,r′]，这样区间就断成了[l,l′)[l,l&#x27;)[l,l′)和(r′,r](r&#x27;,r](r′,r]，完成了反悔操作，也就对应模拟费用流的反向弧的操作。PoorStudents依旧是模拟费用流。首先这显然是一个带权二分图匹配问题，考虑建立费用流后如何优化。如果手玩这个退流和走反向弧的过程不难发现每次实际上就是在右边选出一个序列p1,p2,…pmp_1,p_2,\\dotsp_mp1​,p2​,…pm​满足p[1,m)p[1,m)p[1,m)都曾经被流满了（匹配完cpic_{p_i}cpi​​个左部点了），然后不断进行退流操作（即走反向弧）直到最后走到了一个没有流满的点pmp_mpm​后走到TTT，下图红色的边就体现了退流的过程。由于m≤k≤10m\\lek\\le10m≤k≤10，所以考虑对右部点做一些本质的操作。◊\\Large\\color{red}\\Diamond◊实际上每次寻找最短路时可以看作从pip_ipi​走到pi+1p_{i+1}pi+1​，距离就是pi→x→pi+1p_i\\tox\\top_{i+1}pi​→x→pi+1​两条边的距离之和，这个可以提前预处理出任意两个右部点的xxx的集合处理，所以就是已知任意两个右部点之间的距离求一条最短路rs⇝rtrs\\rightsquigarrowrtrs⇝rt且保证rtrtrt没有流满。直接O(k3)\\mathcalO(k^3)O(k3)跑floyd即可，由于要模拟退流，所以要记录转移点来复原路径。复杂度为O(nk3+nk2log⁡n)\\mathcalO(nk^3+nk^2\\logn)O(nk3+nk2logn)。","link":"https://yaohaoyou.github.io/post/teaching-xdfz/"},{"title":"比赛-XDFZ","content":"◊\\Large\\color{red}\\Diamond◊是关键转化。pingpong赛时。多次询问是假的，直接离线排序。首先∑freq≤106\\sumfreq\\le10^6∑freq≤106是好做的，只要花费O(log⁡n)\\mathcalO(\\logn)O(logn)的时间消掉一个网即可。正解考虑优化这个过程，首先会处理左右端点有多个相同位置的网的情况，直接可以O(1)\\mathcalO(1)O(1)消掉一个位置所有的网，然后每次就可以花费O(log⁡n)\\mathcalO(\\logn)O(logn)让T←T−dis,dis←dis+1T\\getsT-dis,dis\\getsdis+1T←T−dis,dis←dis+1，所以只会有O(T)\\mathcalO(\\sqrtT)O(T​)种坐标，将所有完全相同的网合并后，每种网只会出现O(Tleni)\\mathcalO(\\frac{\\sqrt{T}}{len_i})O(leni​T​​)次，所以总和为O(Tln⁡T)\\mathcalO(\\sqrtT\\ln\\sqrtT)O(T​lnT​)，复杂度是O((N+T)(log⁡N+ln⁡T)+Qlog⁡Q)\\mathcalO((N+\\sqrtT)(\\logN+\\ln\\sqrtT)+Q\\logQ)O((N+T​)(logN+lnT​)+QlogQ)。select赛后。感觉O(n2)\\mathcalO(n^2)O(n2)和正解没有任何关系啊，不会分治还是太菜了。首先是即使没有观察到性质也应该想到O(nlog⁡2n)\\mathcalO(n\\log^2n)O(nlog2n)的分治做法。分治后钦定第一个区间一定要过midmidmid，离线掉一维后就只要做对于bbb数组的每种选择[l2,r2][l_2,r_2][l2​,r2​]找到包含midmidmid的极长合法段◊\\Large\\color{red}\\Diamond◊。首先bl2−1b_{l_2-1}bl2​−1​和br2+1b_{r_2+1}br2​+1​显然只会是与当前分治区间a[l,r]a[l,r]a[l,r]颜色相同的点或l2=1/r2=ml_2=1/r_2=ml2​=1/r2​=m，否则扩展后一定更优，于是也可以将bbb数组删到只剩r−l+1r-l+1r−l+1个。[l2,r2][l_2,r_2][l2​,r2​]是二维状态，考虑对r2r_2r2​扫描线，同时数据结构在l2l_2l2​维护[l2,r2][l_2,r_2][l2​,r2​]的状态。对于bbb选择[l2,r2][l_2,r_2][l2​,r2​]，维护[L,R](L≤mid≤R)[L,R](L\\lemid\\leR)[L,R](L≤mid≤R)表示a[L,R]a[L,R]a[L,R]是与b[l2,r2]b[l_2,r_2]b[l2​,r2​]不重的极大区间，显然对于同一个r2r_2r2​，随着l2l_2l2​增大对应的LLL单调不增，RRR单调不减，所以可以使用类似单调栈的思路解决。当r2←r2+1r_2\\getsr_2+1r2​←r2​+1，令br2=axb_{r_2}=a_xbr2​​=ax​，若x≤midx\\lemidx≤mid，所有的LLL和xxx取max⁡\\maxmax。若x≥midx\\gemidx≥mid，所有的RRR和xxx取min⁡\\minmin，刚好对应一段后缀，单调栈维护即可，过程中需要做区间加求区间最值，总复杂度O(nlog⁡2n)\\mathcalO(n\\log^2n)O(nlog2n)。考虑用性质优化，首先显然答案至少为max⁡(∑x,∑y)\\max(\\sumx,\\sumy)max(∑x,∑y)，而最后的答案为x[l1,r1]+y[l2,r2]x[l_1,r_1]+y[l_2,r_2]x[l1​,r1​]+y[l2​,r2​]，所以一定有x[l1,r1]&gt;∑x2x[l_1,r_1]&gt;\\frac{\\sumx}2x[l1​,r1​]&gt;2∑x​或y[l2,r2]&gt;∑x2y[l_2,r_2]&gt;\\frac{\\sum_x}2y[l2​,r2​]&gt;2∑x​​，否则还不如全选一个区间，所以找到最小的∑i=1pxi≥∑x2\\sum_{i=1}^px_i\\ge\\frac{\\sumx}2∑i=1p​xi​≥2∑x​，∑i=1qyq≥∑y2\\sum_{i=1}^qy_q\\ge\\frac{\\sumy}2∑i=1q​yq​≥2∑y​，则一定有[l1,r1][l_1,r_1][l1​,r1​]跨过ppp或[l2,r2][l_2,r_2][l2​,r2​]跨过qqq，然后就不用分治和去重了，把p,qp,qp,q当作上面的midmidmid做即可，复杂度为O(nlog⁡n)\\mathcalO(n\\logn)O(nlogn)。区间赛后。这个也太抽象了，第一步都想不到。首先有个显然的性质，一次取肯定会取完一个LDS，所以可以考虑直接将LDS缩起来。（这个是赛时想到的）然后就是将这个思路继续拓展。实际上，由于一个LDS内的选取顺序一定是连续的，所以影响他们什么时候取的就只有平均数（总和）了◊\\Large\\color{red}\\Diamond◊，所以对于相邻同侧的两个块(s1,len1)(s_1,len_1)(s1​,len1​)，(s2,len2)(s2,len_2)(s2,len2​)只要满足s1len1≥s2len2\\frac{s_1}{len_1}\\ge\\frac{s_2}{len_2}len1​s1​​≥len2​s2​​就一定会取完第一个块后立刻取第二个块（因为平均值拼上会更大），所以直接将两个块合并。此刻，kkk左右两侧的块就会分别单调了，即平均值形成\\k/的样子，对于先选左边和先选右边做差后能证明先选平均值更小的一定更优，所以直接将左右的块组成的序列归并就能得到操作顺序了。现在需要一个数据结构，支持增删区间，维护排序后的带系数的全局贡献和，直接使用平衡树维护，插入删除对其他贡献系数的影响求区间和即可。也可以提前将所有的单调栈的块信息预处理后按平均值离散化后在线段树上做单点修区间求和，复杂度O(nlog⁡n)\\mathcalO(n\\logn)O(nlogn)。序列赛后。其中O(nnα(n))\\mathcalO(n\\sqrtn\\alpha(n))O(nn​α(n))和O(nlog⁡n)\\mathcalO(n\\logn)O(nlogn)的做法都在代码源的题解中亦有记载，不改题导致的。首先O(nnlog⁡n)\\mathcalO(n\\sqrtn\\logn)O(nn​logn)的做法很显然，如果使用莫队尝试根号平衡。这个应该是比较套路的做法了，使用回滚莫队后，如果右端点只有向右移动，则每次就类似于初始时bi=−ib_i=-ibi​=−i，给后缀加一，求最后一个≥0\\ge0≥0的位置。考虑使用单调栈维护后缀最大值，每次增加[x,n][x,n][x,n]就找到xxx在单调栈中的前驱后继（包括xxx），然后将前驱删除，这个过程不难用链表+并查集维护。然后考虑左端点也可能会乱动，如果暴力撤销单调栈和链表会影响复杂度均摊，所以考虑和询问平衡复杂度。考虑对值域分块，维护每个块内的后缀最大值（单调栈），后缀加[x,n][x,n][x,n]的时候会将xxx所在块分裂，只要使用上面的链表+并查集维护单调栈即可，然后剩余的块直接在idx+1id_x+1idx​+1打上差分标记即可，询问时再做前缀和。比较妙的是可以提前将ala_lal​的n\\sqrtnn​种取值也作为分块的端点，这样所有的后缀加/减都只要打差分标记了，不会因为维护单调栈而影响均摊。查询的时候先找到答案在那个块后在块中跑单调栈即可，总复杂度为O(nnα(n))\\mathcalO(n\\sqrtn\\alpha(n))O(nn​α(n))。另一种做法就是让xxx从nnn到111，由于对于[l1,r1]⊆[l2,r2],ans[l1,r1]≤ans[l2,r2][l_1,r_1]\\sube[l_2,r_2],ans[l_1,r_1]\\leans[l_2,r_2][l1​,r1​]⊆[l2​,r2​],ans[l1​,r1​]≤ans[l2​,r2​]，所以可以在求出ans[l2,r2]ans[l_2,r_2]ans[l2​,r2​]前忽略[l1,r1][l_1,r_1][l1​,r1​]，这样当前的询问区间就是互不相交的，所以左右端点分别递增，可以使用线段树维护后缀加，当确定一个ans[l,r]=xans[l,r]=xans[l,r]=x时，将[l,r][l,r][l,r]删除，然后在线段树上二分来加入新的极长询问区间。复杂度O(nlog⁡n)\\mathcalO(n\\logn)O(nlogn)。","link":"https://yaohaoyou.github.io/post/contest-xdfz/"},{"title":"AT_arc213_c Double X 题解","content":"题目传送器更爽的阅读体验搬运官方题解做法。显然x1,x2,x3,x4x_1,x_2,x_3,x_4x1​,x2​,x3​,x4​满足在以kkk为根的TTT和UUU中两两之间的LCA都是kkk，这其实是一个类似于二分图匹配的问题。具体的，可以将这个问题转化成对于kkk在TTT上的儿子a1,a2,…,adegTka_1,a_2,\\dots,a_{degT_k}a1​,a2​,…,adegTk​​，和在UUU上的儿子b1,b2,…,bdegUkb_1,b_2,\\dots,b_{degU_{k}}b1​,b2​,…,bdegUk​​之间，若一个点xxx在aia_iai​和bjb_jbj​的子树中，则连接一条(i,j,Ax)(i,j,A_x)(i,j,Ax​)的边，代表一对匹配。这一步转化后，现在只需要求这个二分图中找到大小为4的最小匹配。由于二分图两边点数的总和只有degTk+degUkdegT_k+degU_kdegTk​+degUk​，所以可以对每个kkk考虑O~(degTk+degUk)\\tilde{\\mathcalO}(degT_k+degU_k)O~(degTk​+degUk​)解决这个问题，总复杂度就只有O~(∑n)\\tilde{\\mathcalO}(\\sumn)O~(∑n)。首先显然重边只用保留边权最小的一条。其次事实上，只要对每个左部点保留边权前4小的边也不会影响答案。证明考虑若选择了第5小的边，则剩余的3组匹配一定无法完全包含前4小的边的右端点，所以可以将第5小的边调整到没选的前4小的边一定不劣。所以每个左部点直接保留前4小的边即可，总边数就缩到O(degTk+degUk)\\mathcalO(degT_k+degU_k)O(degTk​+degUk​)级别了。由于流量flow=4flow=4flow=4很小，直接用费用流跑匹配，使用Primal-Dual能做到O(nlog⁡n)\\mathcalO(n\\logn)O(nlogn)，实测直接SSP也能过。现在思考如何建出这个图，即考虑如何快速求出以kkk为根时，在axa_xax​子树中前4小的不相同的边。考虑在UUU中将bib_ibi​的子树内的点vvv在TTT中染色成iii，则需要在TTT中找axa_xax​的子树中4种颜色的点的最小值。注意到我们实际上不可能每次吧kkk提出来做根跑dfs，但是可以将kkk的邻域分为kkk的父亲和kkk的儿子，kkk的父亲对应的子树直接全部染色成0，每次换根时就只会修改一个位置了，剩下的儿子子树的染色过程可以在UUU上用dsuontree在O(nlog⁡n)\\mathcalO(n\\logn)O(nlogn)做完。再开一棵线段树维护当前节点对应的TTT上欧拉序区间的最小的4种颜色和权值，在TTT上做线段树区间查即可，总复杂度为O(nlog⁡2n+Flow(n))\\mathcalO(n\\log^2n+Flow(n))O(nlog2n+Flow(n))，Flow(n)Flow(n)Flow(n)为边数为nnn的费用流的复杂度。注意最短路要开longlong，虽然最后的增广最短路只会有2×1092\\times10^92×109，但过程中可能需要经过的最短路会&lt;−2×109&lt;-2\\times10^9&lt;−2×109。code","link":"https://yaohaoyou.github.io/post/AT_arc213_c-solution/"},{"title":"wqs 二分学习笔记","content":"目前好像只会一些恰好选kkk段的题目。wqs二分适用于解决对于一个上凸/下凸的函数ggg在O(Dlog⁡V)\\mathcalO(D\\logV)O(DlogV)的复杂度内求出一个单点值g(x)g(x)g(x)，其中DDD为求出min⁡/max⁡(g(x)−kx)\\min/\\max(g(x)-kx)min/max(g(x)−kx)的复杂度，VVV为相邻ggg上相邻两点斜率的范围。具体的，我们需要使用一条直线l:y=kx+bl:y=kx+bl:y=kx+b来切点(x,g(x))(x,g(x))(x,g(x))，使得lll同时是凸包g(x)g(x)g(x)的切线，求kkk的最值，这是网络上常见的理解，我更愿意理解为找gk′(x)=g(x)−kx+bg&#x27;_k(x)=g(x)-kx+bgk′​(x)=g(x)−kx+b的最值。观察图像可知，当g(x)g(x)g(x)为下凸包，kkk要求最大时，gk′(x)g&#x27;_k(x)gk′​(x)会在[x,x+1][x,x+1][x,x+1]时取到最小值，若二分kkk时argmin⁡(gk′(x))≤x\\operatorname{argmin}(g&#x27;_k(x))\\lexargmin(gk′​(x))≤x，则说明斜率过小（或刚好），将l=mid+1l=mid+1l=mid+1，否则将r=mid−1r=mid-1r=mid−1。argmin⁡(f(x))\\operatorname{argmin}(f(x))argmin(f(x))表示使函数f(x)f(x)f(x)取到最小值的xxx。（实际上应该求kkk的最小值也是一样可以的。）上凸包的情况类似，下面给几道题目。P4983忘情首先要求的那个式子其实就是(∑xi+1)2(\\sumx_i+1)^2(∑xi​+1)2。令fi,jf_{i,j}fi,j​表示前iii个数分成jjj段的答案，则有转移式fi,j=min⁡k=0j−1(fk,j−1+(si−sk+1)2)f_{i,j}=\\min_{k=0}^{j-1}(f_{k,j-1}+(s_i-s_{k}+1)^2)fi,j​=mink=0j−1​(fk,j−1​+(si​−sk​+1)2)，由于xi&gt;0x_i&gt;0xi​&gt;0，可以证明fnf_nfn​是下凸的，要求fn,mf_{n,m}fn,m​。这和上面的类似了，考虑对函数g(x)=fn,xg(x)=f_{n,x}g(x)=fn,x​做wqs二分。先二分一个斜率kkk，然后需要判断g′(x)=g(x)−kxg&#x27;(x)=g(x)-kxg′(x)=g(x)−kx在何处取到最小值。只需要将−kx-kx−kx拆到每次新开一组的时候−k-k−k即可。转移可以斜率优化。总复杂度为O(nlog⁡2nV)\\mathcalO(n\\log_2nV)O(nlog2​nV)。P6246[IOI2000]邮局加强版加强版令w(l,r)w(l,r)w(l,r)表示区间[l,r][l,r][l,r]放一个邮局的距离和，fi,jf_{i,j}fi,j​表示前iii个村庄分jjj段。可以发现www满足四边形不等式，所以g(x)=fn,xg(x)=f_{n,x}g(x)=fn,x​为下凸函数。依旧套用wqs二分处理，check时需要用决策单调性，可以使用二分队列。CF2183HMinimiseCost先贪心。子序列实际上可以转成从小到大排序后的子区间，负数尽量全部放一组，非正数首先选出部分组成k−1k-1k−1组，剩余的和负数放一组。依旧是一个类似的转移式，令fi,jf_{i,j}fi,j​表示前iii个数分为jjj组，w(l,r)=(r−l+1)(sr−sl−1)w(l,r)=(r-l+1)(s_r-s_{l-1})w(l,r)=(r−l+1)(sr​−sl−1​)，fi,j=min⁡k=0i−1fk,j−1+w(k+1,i)f_{i,j}=\\min_{k=0}^{i-1}f_{k,j-1}+w(k+1,i)fi,j​=mink=0i−1​fk,j−1​+w(k+1,i)。根据上面的贪心，只有在i=1∨ai≥0i=1\\veea_i\\ge0i=1∨ai​≥0的时候需要转移枚举断电，对于w(l,r)(l=1∨al≥0,ar≥0)w(l,r)(l=1\\veea_l\\ge0,a_r\\ge0)w(l,r)(l=1∨al​≥0,ar​≥0)可以证明其满足四边形不等式，所以这个fff满足决策单调性，fnf_nfn​是下凸的。然后就和上面的p6246一样了。P9266[PA2022]Nawiasowepodziały令w(l,r)w(l,r)w(l,r)表示区间[l,r][l,r][l,r]中所有子串中合法括号序列数量，可以证明www满足四边形不等式。令fi,jf_{i,j}fi,j​表示前iii个字符分成了jjj段的方案数，则fi,j=min⁡k&lt;ifk−1,j−1+w(k,i)f_{i,j}=\\min_{k&lt;i}f_{k-1,j-1}+w(k,i)fi,j​=mink&lt;i​fk−1,j−1​+w(k,i)，所以F(x)=fn,xF(x)=f_{n,x}F(x)=fn,x​为下凸函数。套路地，显示使用wqs二分，然后需要求gi=min⁡j&lt;igj−1+w(j,i)−midg_i=\\min_{j&lt;i}g_{j-1}+w(j,i)-midgi​=minj&lt;i​gj−1​+w(j,i)−mid。因为www满足四边形不等式，所以ggg满足决策单调性，但www不好直接求，并且ggg求解过程需要在线。发现w(l,r)w(l,r)w(l,r)在做l→l±1l\\tol\\pm1l→l±1或r→r±1r\\tor\\pm1r→r±1时可以直接O(1)\\mathcalO(1)O(1)求解，所以可以用cdq分治套决策单调性分治解决，复杂度为O(nlog⁡3n)\\mathcalO(n\\log^3n)O(nlog3n)。但是可以使用LARSCH/简化LARSCH（感觉像科技）算法优化至dp部分只要O(n)/O(nlog⁡n)\\mathcalO(n)/\\mathcalO(n\\logn)O(n)/O(nlogn)，总复杂度为O(nlog⁡n/nlog⁡2n)\\mathcalO(n\\logn/n\\log^2n)O(nlogn/nlog2n)。简化LARSCH简化LARSCH算法其实类似于cdq分治套决策单调性分治，令optt(x)opt_t(x)optt​(x)表示只考虑从[1,t][1,t][1,t]的转移到xxx的最优决策，opt(x)=optx−1(x)opt(x)=opt_{x-1}(x)opt(x)=optx−1​(x)。具体过程是定义solve(l,r)solve(l,r)solve(l,r)表示已知[1,l)[1,l)[1,l)的g,optg,optg,opt和optl−1(r)opt_{l-1}(r)optl−1​(r)，求解[1,r][1,r][1,r]的g,optg,optg,opt。用i∈[optl−1,optl−1,r]i\\in[opt_{l-1},opt_{l-1,r}]i∈[optl−1​,optl−1,r​]求出optl−1(mid)opt_{l-1}(mid)optl−1​(mid)，因为optt(x)≤optt(y)≤optt(z),x&lt;y&lt;zopt_{t}(x)\\leopt_{t}(y)\\leopt_{t}(z),x&lt;y&lt;zoptt​(x)≤optt​(y)≤optt​(z),x&lt;y&lt;z。调用solve(l,mid)solve(l,mid)solve(l,mid)。用opt(i),i∈[l,mid]opt(i),i\\in[l,mid]opt(i),i∈[l,mid]和optl−1(r)opt_{l-1}(r)optl−1​(r)求出optmid(r)opt_{mid}(r)optmid​(r)。调用solve(mid+1,r)solve(mid+1,r)solve(mid+1,r)。注意1操作中要移动w1w1w1的指针，3操作中要移动w2w2w2的指针，可以证明整个过程中w1w1w1和w2w2w2的指针一共只会移动O(nlog⁡n)\\mathcalO(n\\logn)O(nlogn)次，若两种操作移动同一对指针会退化到O(n2)\\mathcalO(n^2)O(n2)次。","link":"https://yaohaoyou.github.io/post/wqs-binary-search/"},{"title":"GDKOI2025复活赛","content":"我说GDKOI复活不是我复活。Day1日常赛前没睡好。为什么是中大大学城校区，我要住酒店！8:10进考场，这电脑是开网的？开T1，不知道过了多久才拼了72pts，感觉不质因数分解MMM个数还是不太会做，但是拼分IOI好评，中途比赛时间还加了不少。跳了。T2写完暴力后想了特殊性质的O(n53)\\mathcalO(n^\\frac53)O(n35​)，写了下尽然不卡常直接过了，拿了50pts。到目前为止还认为这场是NOIP2025+，然后就是继续跳题。最后就是尝试把希望寄托在T4的乱搞上。写了SA又卡了inf时间，最后卡到了49pts。当时还以为自己赢完了，结果。。。T3最后30pts只写了15pts。然后就是T1,T2被切穿了，难道T2的性质做法比正解还困难？饭不太好吃，差评。回学校也不知道在干嘛，下播了。Day2OI生涯第一场ACM正式赛，多半也是最后一场了。只能说没忘本，看无敌坦克手的最后一舞吧。以上是赛前的话。我是罪人，后面忘了。这下这下了。对不住IsaacX和mskqwq了，又被卡题葬送比赛了。/ll","link":"https://yaohaoyou.github.io/post/gdkoi2025/"},{"title":"NOIP2025","content":"省流：自己看完。好像几个you'ji都用完了，所以直接叫NOIP2025了。考号竟然是按照csp-s高中排名排的，所以是考号最前的一次（只因为是高一了），侥幸拿下s同分mskqwq，拿下精品豹子号。Day0下午还能有体锻？人最多的一次，甚至凑齐了5v5，还有sana返场。最后被sana绝杀了，不爽。Day1晚上没睡好，但是早上感觉还可以，早餐依旧汉堡+菊花茶，但是机房为什么没网？在“学长”电脑上看了写文章，看到了范德蒙德卷积（伏笔）。总结了前几场失败可能包括了过T1T2就上厕所，导致不太能充分思考T3/T4的多方面做法。所以这次想过了T1T2后想完T3一会再上厕所（伏笔）。进考场了，10min过T1。这个T2看上去就很不善，至少比去年要难不少吧，一眼看不出啥，推了一下好像会了，写着写着发现是O(n3)\\mathcalO(n^3)O(n3)，而且没过大样例，调调调，过不了一点。十分红温，然后写了份暴力。调调调调调调调调调调调调调调调调调调调调调调调调调调调调调调调到了2h，实在忍不住了，想去上厕所，结果被说要排队，然后继续调，等了30min才排到队？上完厕所回来不久就挑出来了，应该能拿[72,92][72,92][72,92]。我本应该在这里说我看出来了这就是我赛前看到的范德蒙德卷积，但没有人会反转组合数，我也不是没有人，然后就寄了。还剩1.5h，那咋办。开T3，一看就不可做。T4，2022T4比赛？有点意思，看了一会儿写了暴力（我赛时还以为能过2,3）和AB性质。然后想了想，去写T3暴力，写完就差不多结束了。估分：100+[72,92]+8+40=[210,240]100+[72,92]+8+40=[210,240]100+[72,92]+8+40=[210,240]。好像很多人都不太会T2？T4还挺多人会O(nqlog⁡n)\\mathcalO(nq\\logn)O(nqlogn)？T3的poly(n)poly(n)poly(n)好像也该想到。感觉最菜的不是因为T2不会做，而是T2做了这么久。sanawhk一年280+？这下这下了。Day?出分日瓜飞了，不太想说了。90+84+8+35=21790+84+8+35=21790+84+8+35=217。这下要退役了。T2这要预处理组合数就有929292了，这也太笨了。dieselhuang都坠了，祝好。","link":"https://yaohaoyou.github.io/post/noip2025/"},{"title":"P4299 首都 题解","content":"题目传送器更爽的阅读体验前言怎么清一色LCT做法，还有一个看上去很麻烦的树剖+线段树合并，下面给一种好写好想的树上倍增双log⁡\\loglog做法。题意动态加边维护树的重心。做法根据经典结论，合并两棵树后新的重心会在原本两棵树的重心的路径上，所以可以考虑使用倍增或二分求出新的重心。具体地，将询问离线下来把树建出来，每次连接一条新边(u,v)∣depu≤depv(u,v)\\middep_u\\ledep_v(u,v)∣depu​≤depv​时就是将vvv的树以vvv为根并到uuu上，这里令当前uuu所在的树的根为rtrtrt，首先动态维护sizsizsiz，直接做是链加单点查，但是经典方法是将其差分后改为用树状数组维护单点加子树查。接下来令uuu所在树原本的重心为wcuwc_uwcu​，vvv的为wcvwc_vwcv​，lca←LCA⁡(wcu,wcv)lca\\gets\\operatorname{LCA}(wc_u,wc_v)lca←LCA(wcu​,wcv​)，首先特判掉wcu=lca∨wcv=lcawc_u=lca\\veewc_v=lcawcu​=lca∨wcv​=lca的情况，然后令tututu为lcalcalca在wcuwc_uwcu​方向上的儿子，tvtvtv同理，易得siztu+siztv+1=sizrtsiz_{tu}+siz_{tv}+1=siz_{rt}siztu​+siztv​+1=sizrt​，所以min⁡(siztu,siztv)&lt;sizu2\\min(siz_{tu},siz_{tv})&lt;\\frac{siz_u}{2}min(siztu​,siztv​)&lt;2sizu​​，而又有重心的判定sizwc≥sizu2siz_{wc}\\ge\\frac{siz_u}2sizwc​≥2sizu​​，所以可以直接判断出新的重心在tututu的子树内还是tvtvtv的子树内，并可以判断出在哪一条链上，若wcu=lca∨wcv=lcawc_u=lca\\veewc_v=lcawcu​=lca∨wcv​=lca就肯定在wcu⇝wctwc_u\\leadstowc_twcu​⇝wct​的路径上。知道了新的重心在哪一条路径上就可以直接倍增了，找到深度最大的满足2sizu≥sizrt2siz_u\\gesiz_{rt}2sizu​≥sizrt​的uuu即为重心，注意特判两个重心的情况，即若2sizu=sizrt2siz_u=siz_{rt}2sizu​=sizrt​则uuu的父亲也是重心。两种询问使用并查集在修改时维护即可。时间复杂度为O(nlog⁡n+mlog⁡2n)\\mathcalO(n\\logn+m\\log^2n)O(nlogn+mlog2n)，瓶颈在倍增时的树状数组查询，空间树上倍增数组需要O(nlog⁡n)\\mathcalO(n\\logn)O(nlogn)。Code","link":"https://yaohaoyou.github.io/post/p4299-solution/"},{"title":"CSP2025 油机","content":"省流：自己看完。Day0甚至要到了体锻，但是不出所料，上高一后就很少人踢球了，爽但不太爽。听到学弟问要不要背快读模板，感觉根本背不下来，而且大概也没用吧（伏笔Day1终于不用早起了，但是还是睡到8:00就不想睡了。早上在复习板子，被教练看见了，于是就有了：伏笔）中午看了J的题目，为什么我不参加就这么简单，学长AK后玩Ukraine方块被抓包了？中午直接睡到14:10才起来（为什么我的闹钟没响？）。问监考能不能带水杯进去，他说：《喝一口就行》，所以是怕我带炸药进考场？？？密码输的最快的一次，开T1，然后回了，但怎么有点像反悔贪心？写写写，本地跑1s+？为什么5×1055\\times10^55×105个整数不给快读？把堆改成排序就更快了，现在是真怕T1/T2被卡常。开T2，直接保留最小生成树做就行了，先写了O(n2klog⁡nα(n))\\mathcalO(n2^k\\logn\\alpha(n))O(n2klognα(n))，要跑1.6s。为什么3×106,1s3\\times10^6,1s3×106,1s都不下发快读？？？CCF不会默认大家都会fread吧。再看一下归并可以少一只log，写写写，为什么少一只log还要跑1s？丢了。开T3，感觉不太会做，推了一下性质发现只要会快速做两个有多少个xi∈A,yi∈Bx_i\\inA,y_i\\inBxi​∈A,yi​∈B即可，但这很明显不能快速做吧。然后就开始乱想了，中途甚至会根号分治做O(Ln)\\mathcalO(L\\sqrtn)O(Ln​)，但是为什么这和O(Ln)\\mathcalO(Ln)O(Ln)一个分？？？计算后发现O(nL)\\mathcalO(n\\sqrtL)O(nL​)可以过，然后就磕了一场的根号，然后就寄了。AB性质一共打了7kb+，考场直接被调红温了。T4提前看了，排列计数一看就不会做，最后15min极限拿下24pts。虚拟机过编后都来不及测大样例就结束了。（为什么14:30发的密码监考员说14：27就开始了，一定要18:27结束，CCF是差3min赶晚高峰吗？？？）赛后遇见yhm问zlt2h有没有AK，直接自闭了。mlk觉得自己好帅，然后就AK了。估分：100+100+70+24=294100+100+70+24=294100+100+70+24=294。Day5T3没判∣t1∣≠∣t2∣|t_1|\\ne|t_2|∣t1​∣​=∣t2​∣，自闭了。申诉查分？？？100+100+50+24=274100+100+50+24=274100+100+50+24=274。Day6T3∣t1∣≠∣t2∣|t_1|\\ne|t_2|∣t1​∣​=∣t2​∣没被卡，但是maxl⁡\\operatorname{maxl}maxl开成maxn⁡\\operatorname{maxn}maxn了，坠。原来T3放到两棵Trie上就从xi∈A,yi∈Bx_i\\inA,y_i\\inBxi​∈A,yi​∈B变成xi∈[l1,r1],yi∈[l2,r2]x_i\\in[l_1,r_1],y_i\\in[l_2,r_2]xi​∈[l1​,r1​],yi​∈[l2​,r2​]，就可以二维数点了，这么笨可以滚了。无敌坦克手贝塔获得成就：max⁡(CSP-S2025)−min⁡(CSP-S2025)=3\\max(\\text{CSP-S2025})-\\min(\\text{CSP-S2025})=3max(CSP-S2025)−min(CSP-S2025)=3。replace题解：手玩一下可以证明，将(si,1,si,2)(s_{i,1},s_{i,2})(si,1​,si,2​)定义成(ai,bi,bi′,ci)(a_i,b_i,b&#x27;_i,c_i)(ai​,bi​,bi′​,ci​)，其中aia_iai​为LCP(si,1,si,2)LCP(s_{i,1},s_{i,2})LCP(si,1​,si,2​)，cic_ici​为LCS(si,1,si,2)LCS(s_{i,1},s_{i,2})LCS(si,1​,si,2​)，ai+bi+ci=si,1,ai+bi′+ci=si,2a_i+b_i+c_i=s_{i,1},a_i+b&#x27;_i+c_i=s_{i,2}ai​+bi​+ci​=si,1​,ai​+bi′​+ci​=si,2​，同理将(ti,1,ti,2)(t_{i,1},t_{i,2})(ti,1​,ti,2​)定义成(Ai,Bi,Bi′,Ci)(A_i,B_i,B&#x27;_i,C_i)(Ai​,Bi​,Bi′​,Ci​)，则能将tj,1t_{j,1}tj,1​通过(si,1,si,2)(s_{i,1},s_{i,2})(si,1​,si,2​)替换成tj,2t_{j,2}tj,2​当且仅当aia_iai​为AjA_jAj​的后缀，bi=Bj,bi′=Bj′b_i=B_j,b&#x27;_i=B&#x27;_jbi​=Bj​,bi′​=Bj′​，cic_ici​为CjC_jCj​的前缀。bi=Bj,bi′=Bj′b_i=B_j,b&#x27;_i=B&#x27;_jbi​=Bj​,bi′​=Bj′​的限制好做，直接将所有(bi,bi′)(b_i,b&#x27;_i)(bi​,bi′​)哈希后存在一起，查询时找到对应的集合即可。剩下两个限制不能直接做，前缀后缀可以考虑建出两棵Trie树，限制就变为了求有多少个位置在第一棵Trie上一个子树内，在第二棵Trie上为当前点的祖先，然后使用dfs序即可转成二维数点，在第二棵Trie上dfs，用树状数组记录第一棵的区间点数。时间复杂度为O(L1+L2+(n+q)log⁡n)\\mathcalO(L1+L2+(n+q)\\logn)O(L1+L2+(n+q)logn)，空间O((L1+L2)∣∑∣)\\mathcalO((L1+L2)|\\sum|)O((L1+L2)∣∑∣).employ题解：对排列计数肯定不能直接做，先记录fi,jf_{i,j}fi,j​表示面试了iii个人有jjj个人没有录用的方案数，则目前的人可以分成ci≤jc_i\\lejci​≤j和ci&gt;jc_i&gt;jci​&gt;j的人，尝试直接记录在状态内。重设状态fi,j,kf_{i,j,k}fi,j,k​表示面试了iii个人有jjj个没有录用，cp&gt;jc_p&gt;jcp​&gt;j的共有kkk个人的方案数（cp&gt;jc_p&gt;jcp​&gt;j的无需记录位置和具体取的值，即延后钦定，这里后面会解释）。若si+1=0s_{i+1}=0si+1​=0，此时的j←j+1j\\getsj+1j←j+1，kkk会减去前面选中的c=j+1c=j+1c=j+1的个数，这里考虑直接枚举lll表示前面的人中有lll个cp=j+1c_p=j+1cp​=j+1。这里就解释了为什么要延后钦定，因为如果直接在加入时就选择他的位置和值，现在就会算重和算错。这里需要给lll个人钦定位置和值，所以乘上(cntj+1l)(kl)l!\\binom{cnt_{j+1}}{l}\\binom{k}{l}l!(lcntj+1​​)(lk​)l!的系数，转移如下：{fi+1,j+1,k−l+1←fi,j,k(cntj+1l)(kl)l!当前i+1选择c&gt;j+1fi+1,j+1,k−l←fi,j,k(cntj+1l)(kl)l!(prej+1−i+k−l)当前i+1选择c≤j+1\\begin{cases}f_{i+1,j+1,k-l+1}\\getsf_{i,j,k}\\binom{cnt_{j+1}}{l}\\binom{k}{l}l!&amp;\\text{当前}i+1\\text{选择}c&gt;j+1\\\\f_{i+1,j+1,k-l}\\getsf_{i,j,k}\\binom{cnt_{j+1}}{l}\\binom{k}{l}l!(pre_{j+1}-i+k-l)&amp;\\text{当前}i+1\\text{选择}c\\lej+1\\end{cases}{fi+1,j+1,k−l+1​←fi,j,k​(lcntj+1​​)(lk​)l!fi+1,j+1,k−l​←fi,j,k​(lcntj+1​​)(lk​)l!(prej+1​−i+k−l)​当前i+1选择c&gt;j+1当前i+1选择c≤j+1​然后si+1=1s_{i+1}=1si+1​=1的就类似了，注意若选择的c&gt;j′c&gt;j&#x27;c&gt;j′时不用记录当前选数的方案数。{fi+1,j,k+1←fi,j,k当前i+1选择c&gt;jfi+1,j,k+1←fi,j,k(cntj+1l)(kl)l!(prej−i+k)当前i+1选择c≤j\\begin{cases}f_{i+1,j,k+1}\\getsf_{i,j,k}&amp;\\text{当前}i+1\\text{选择}c&gt;j\\\\f_{i+1,j,k+1}\\getsf_{i,j,k}\\binom{cnt_{j+1}}{l}\\binom{k}{l}l!(pre_j-i+k)&amp;\\text{当前}i+1\\text{选择}c\\lej\\end{cases}{fi+1,j,k+1​←fi,j,k​fi+1,j,k+1​←fi,j,k​(lcntj+1​​)(lk​)l!(prej​−i+k)​当前i+1选择c&gt;j当前i+1选择c≤j​最后记得求答案时需要给剩余的选定位置和值：ans=∑i=0n−mfn,i,n−prei(n−prei)!ans=\\sum_{i=0}^{n-m}f_{n,i,n-pre_i}(n-pre_i)!ans=i=0∑n−m​fn,i,n−prei​​(n−prei​)!","link":"https://yaohaoyou.github.io/post/CSP2025/"},{"title":"P3688 [ZJOI2017] 树状数组 题解","content":"题目传送器更爽的阅读体验做法不一样的cdq分治做法。记sum[l,r]=(∑i=lrai)mod2sum[l,r]=(\\sum_{i=l}^ra_i)\\bmod2sum[l,r]=(∑i=lr​ai​)mod2对树状数组熟悉的应该可以看出错误代码求解的是{sum[l−1,r−1]l=1sum[r,n]l=1\\begin{cases}sum[l-1,r-1]&amp;l\\not=1\\\\sum[r,n]&amp;l=1\\end{cases}{sum[l−1,r−1]sum[r,n]​l​=1l=1​。若询问的l=1l\\not=1l​=1，则答案为al−1=ara_{l-1}=a_ral−1​=ar​的概率，若l=1l=1l=1，则答案为ar⊕sum[1,n]=0a_r\\oplussum[1,n]=0ar​⊕sum[1,n]=0的概率。其中sum[1,n]sum[1,n]sum[1,n]就是在这次询问之前的操作的次数，直接记录即可。处理l=1l=1l=1时开一个a0=0a_0=0a0​=0，由于a0a_0a0​永远不变，所以ar=[ar=a0]a_r=[a_r=a_0]ar​=[ar​=a0​]，思考如何维护ax=aya_x=a_yax​=ay​的概率，令px,yp_{x,y}px,y​为ax=aya_x=a_yax​=ay​的概率。对于一次修改[l,r][l,r][l,r]，分讨对ppp的影响，令P=1r−l+1P=\\frac1{r-l+1}P=r−l+11​。不难得出对于x∈[0,l),y∈[l,r]x\\in[0,l),y\\in[l,r]x∈[0,l),y∈[l,r]，px,y=px,y(1−P)+(1−px,y)Pp_{x,y}=p_{x,y}(1-P)+(1-p_{x,y})Ppx,y​=px,y​(1−P)+(1−px,y​)P。对于x∈[l,r],y∈[l,r]x\\in[l,r],y\\in[l,r]x∈[l,r],y∈[l,r]，px,y=px,y(1−2P)+(1−px,y)2Pp_{x,y}=p_{x,y}(1-2P)+(1-p_{x,y})2Ppx,y​=px,y​(1−2P)+(1−px,y​)2P。对于x∈[l,r],y∈(r,n]x\\in[l,r],y\\in(r,n]x∈[l,r],y∈(r,n]，px,y=px,y(1−P)+(1−px,y)Pp_{x,y}=p_{x,y}(1-P)+(1-p_{x,y})Ppx,y​=px,y​(1−P)+(1−px,y​)P。显然是对矩阵进行操作，先定义运算a⊙b=ab+(1−a)(1−b)a\\odotb=ab+(1-a)(1-b)a⊙b=ab+(1−a)(1−b)，思考⊙\\odot⊙运算的性质。手玩一下可以发现⊙\\odot⊙满足交换律和结合律，所一可以使用线段树维护。下面的维护方式就五花八门了，这里给出一种和其他题解不同的cdq分治做法。由于原题是矩阵操作，若想改成三维偏序就需要进行差分。解一下方程发现⊙\\odot⊙存在类似逆元，所以可以进行差分。具体的，b⊙b2b−1=1b\\odot\\fracb{2b-1}=1b⊙2b−1b​=1（这里可能存在b=12b=\\frac12b=21​的情况，但后面再解决），所以对于不在所需矩阵内的可以通过多⊙b2b−1\\odot\\frac{b}{2b-1}⊙2b−1b​来取消贡献。然后就将类似[l,r][L,R][l,r][L,R][l,r][L,R]的操作差分成了四个[0,x][0,y][0,x][0,y][0,x][0,y]形式的操作了，对于第iii个询问(a,b)(a,b)(a,b)，会影响其答案的就是第jjj次操作[0,x][0,y][0,x][0,y][0,x][0,y]满足j&lt;i∧a≤x∧b≤yj&lt;i\\wedgea\\lex\\wedgeb\\leyj&lt;i∧a≤x∧b≤y，于是转化成了三维偏序问题，由于⊙\\odot⊙满足结合律和交换律，所以cdq内使用线段树维护即可。现在处理b=12b=\\frac12b=21​的情况，此时不存在逆元，即无法差分。但带回原式子发现只有满足r=l+1r=l+1r=l+1或r=l+3r=l+3r=l+3时会出现这种情况。对于r=l+1r=l+1r=l+1，可以暴力O(r−l+1)O(r-l+1)O(r−l+1)将操作记录，离线后再扫一遍解决。对于r=l+3r=l+3r=l+3，只要O((r−l+1)2)O((r-l+1)^2)O((r−l+1)2)暴力操作会影响的px,yp_{x,y}px,y​。总复杂度为O(nlog⁡n+qlog⁡n2)\\mathcalO(n\\logn+q\\logn^2)O(nlogn+qlogn2)，无需卡常和卡空间，个人认为还是比较自然和好写的。ACCode","link":"https://yaohaoyou.github.io/post/p3688-solution/"},{"title":"暑假讲题","content":"◊\\Large{\\color{red}\\Diamond}◊为重点转换步骤。AT_arc201_b[ARC201B]BinaryKnapsack因为WWW很大，所以不能是01背包的思路，应该想贪心。思考偏序关系，由于不同重量只有log⁡2W\\log_2Wlog2​W种，并且两个2x−12^{x-1}2x−1可以直接合并成2x2^x2x，所以每次贪心取当前重量价值最大的一定更优。对WWW进行二进制拆位，从小到大，若当前第iii位为111，则选一个重量为2i2^i2i的一定不劣。◊\\Large{\\color{red}\\Diamond}◊剩下的排序后两两合并成重量为2i+12^{i+1}2i+1的物品，继续递归子问题。AT_arc200_epopcount&lt;=2将得到的AAA序列全部异或xxx后依旧满足情况，所以不妨将AAA异或A1A_1A1​后使A1=0A_1=0A1​=0。直接钦定A1=0A_1=0A1​=0，最后将答案×2m\\times2^m×2m即可。◊\\Large{\\color{red}\\Diamond}◊由于A1=0A_1=0A1​=0，popcount(A1⊕Ai)≤2popcount(A_1\\oplusA_i)\\le2popcount(A1​⊕Ai​)≤2，所以popcount(Ai)≤2popcount(A_i)\\le2popcount(Ai​)≤2。接下来分情况讨论。popcount(Ai)≤1popcount(A_i)\\le1popcount(Ai​)≤1，没有其他限制了，方案数为(m+1)n−1(m+1)^{n-1}(m+1)n−1。有且仅有一种popcount(Ax)=2popcount(A_x)=2popcount(Ax​)=2，方案数为(m2)(4n−1−3n−1)\\binomm2(4^{n-1}-3^{n-1})(2m​)(4n−1−3n−1)。有多种popcount(Aa1,Aa2,..Aak)=2popcount(A_{a_1},A_{a_2},..A_{a_k})=2popcount(Aa1​​,Aa2​​,..Aak​​)=2，且popcount(Aa1&amp;Aa2&amp;..&amp;Aak)=1,k≥2popcount(A_{a_1}\\AndA_{a_2}\\And..\\AndA_{a_k})=1,k\\ge2popcount(Aa1​​&amp;Aa2​​&amp;..&amp;Aak​​)=1,k≥2，方案数为m((m+1)n−1−2n−1−(m−1)(3n−1−2n−1))m((m+1)^{n-1}-2^{n-1}-(m-1)(3^{n-1}-2^{n-1}))m((m+1)n−1−2n−1−(m−1)(3n−1−2n−1))。有且仅有三种popcount(Ax,Ay,Az)=2popcount(A_x,A_y,A_z)=2popcount(Ax​,Ay​,Az​)=2，此时只能有这三种数和000出现，并且两两交的popcount都为111，如{Ax,Ay,Az}={3,5,6}\\{A_x,A_y,A_z\\}=\\{3,5,6\\}{Ax​,Ay​,Az​}={3,5,6}。方案数为(m3)(4n−1−3×3n−1+3×2n−1−1)\\binomm3(4^{n-1}-3\\times3^{n-1}+3\\times2^{n-1}-1)(3m​)(4n−1−3×3n−1+3×2n−1−1)。P9140THUPC2023初赛背包类似于P2371墨墨的等式的思路，先取civi\\frac{c_i}{v_i}vi​ci​​最大的物品作为基准并设m=vi,k=cim=v_i,k=c_im=vi​,k=ci​，由于若V′V&#x27;V′可以被凑出，则V′≡V(modm)V&#x27;\\equivV(\\bmodm)V′≡V(modm)的VVV可以通过加入多个mmm凑出，所以将物品的总大小在modm\\bmodmmodm的剩余系上处理。◊\\Large{\\color{red}\\Diamond}◊对于(V′,C′),V≡V′(modm)(V&#x27;,C&#x27;),V\\equivV&#x27;(\\bmodm)(V′,C′),V≡V′(modm)的情况，此时的总贡献为C′+V−V′mkC&#x27;+\\frac{V-V&#x27;}mkC′+mV−V′​k，由于Vm\\fracVmmV​固定，所以需要使C′−⌊V′m⌋kC&#x27;-\\lfloor\\frac{V&#x27;}m\\rfloorkC′−⌊mV′​⌋k最大，将这个值设为同余最长路上的距离。转移时从ppp加上物品xxx后转移至q=(p+vx)modmq=(p+v_x)\\bmodmq=(p+vx​)modm，fq=fp+cx−⌊p+vxm⌋kf_q=f_p+c_x-\\lfloor\\frac{p+v_x}m\\rfloorkfq​=fp​+cx​−⌊mp+vx​​⌋k。转移过程中需要保证没有正环和V′&gt;VV&#x27;&gt;VV′&gt;V。若有正权环u1→u2→...→usiz→u1u_1\\tou_2\\to...\\tou_{siz}\\tou_1u1​→u2​→...→usiz​→u1​，由于转一圈后物品总体积一定为mmm的倍数，而由于选择的基准为ciwi\\frac{c_i}{w_i}wi​ci​​最大，所以一定不如全部选择物品iii，矛盾，所以不存在正权环。设∀i∈[1,n],vi≤limv=105\\foralli\\in[1,n],v_i\\lelim_v=10^5∀i∈[1,n],vi​≤limv​=105。图上共有mmm个点，因为没有正权环，所以每个点最多走过111次，走过的边数最多也只有m−1m-1m−1条，每条边增加的体积≤limv\\lelim_v≤limv​，所以V′≤(limv)2=1010&lt;1011V&#x27;\\le(lim_v)^2=10^{10}&lt;10^{11}V′≤(limv​)2=1010&lt;1011，所以V′&lt;VV&#x27;&lt;VV′&lt;V。◊\\Large{\\color{red}\\Diamond}◊由于有负边权，所以不能用dijkstra。这个题数据水，最短路直接用SPFA就过了，正解应该使用转两圈的做法将复杂度做到O(nm)O(nm)O(nm)。建边的过程实际是枚举i∈[1,n],u∈[0,m)i\\in[1,n],u\\in[0,m)i∈[1,n],u∈[0,m)并连边(u,(u+vi)modm,w)(u,(u+v_i)\\bmodm,w)(u,(u+vi​)modm,w)，手玩一下（其实比较显然）可以发现对于iii会产生gcd⁡(vi,m)\\gcd(v_i,m)gcd(vi​,m)个环。由于本质上是在模意义下做完全背包，所以转移顺序并不影响。并且由于每个点只会在最短路上走一次，所以最短路只要在已知的gcd⁡(vi,m)\\gcd(v_i,m)gcd(vi​,m)个环上找到最小的disdisdis值，并用其转一圈更新这圈的其他点即可，也就是x∈[0,vi):x→(x+vi)mod→(x+2vi)modm→...→xx\\in[0,v_i):x\\to(x+v_i)\\bmod\\to(x+2v_i)\\bmodm\\to...\\toxx∈[0,vi​):x→(x+vi​)mod→(x+2vi​)modm→...→x。写代码时为了方便，可以不用找到disdisdis最小值，直接在环上转两圈更新即可，复杂度为O(nm)O(nm)O(nm)。P7320「PMOI-4」可怜的团主首先由一个结论是一棵树至少由⌈leaf2⌉\\lceil\\frac{leaf}2\\rceil⌈2leaf​⌉条路径覆盖，构造是将叶子按dfs序排序后，路径为(lf1,lf⌈leaf2⌉),(lf2,lf⌈leaf2⌉+1)…(lf_1,lf_{\\lceil\\frac{leaf}2\\rceil}),(lf_2,lf_{\\lceil\\frac{leaf}2\\rceil+1})\\dots(lf1​,lf⌈2leaf​⌉​),(lf2​,lf⌈2leaf​⌉+1​)…，若leafleafleaf是奇数则最后连一条(1,lfleaf)(1,lf_{leaf})(1,lfleaf​)。◊\\Large{\\color{red}\\Diamond}◊必要性显然，应为一条路径最多覆盖两个叶子。充分性是这样的路径可以使相邻两条路径都有交集。若有一个点uuu没有被覆盖。若uuu有至少两个在uuu儿子dfs序排列中相邻的v,wv,wv,w，则必有一条经过vvv子树的路径与一条经过www子树的路径相交，所以uuu一定被覆盖。若uuu只有一个儿子，若有不在uuu子树内的叶子则有一条从uuu子树内到外的路径，否则从1→u1\\tou1→u的路径上degf=1deg_f=1degf​=1，则存在从uuu子树内到111的路径。综上，至少用⌈leaf2⌉\\lceil\\frac{leaf}2\\rceil⌈2leaf​⌉条路径一定能覆盖所有节点。由于⌈n6⌉\\lceil\\fracn6\\rceil⌈6n​⌉和⌊n3⌋\\lfloor\\fracn3\\rfloor⌊3n​⌋的关系与⌈x2⌉\\lceil\\fracx2\\rceil⌈2x​⌉相似，所以考虑提出dfs树并看叶子考虑。◊\\Large{\\color{red}\\Diamond}◊显然，若leaf≥⌊n3⌋leaf\\ge\\lfloor\\fracn3\\rfloorleaf≥⌊3n​⌋，则选择第二种并将叶子节点输出即可。反之leaf&lt;⌊n3⌋leaf&lt;\\lfloor\\fracn3\\rfloorleaf&lt;⌊3n​⌋，则覆盖所有点的路径数⌈leaf2⌉&lt;⌈⌊n3⌋2⌉&lt;⌈n6⌉\\lceil\\frac{leaf}2\\rceil&lt;\\lceil\\frac{\\lfloor\\fracn3\\rfloor}2\\rceil&lt;\\lceil\\fracn6\\rceil⌈2leaf​⌉&lt;⌈2⌊3n​⌋​⌉&lt;⌈6n​⌉，使用上述的叶子节点相互匹配的做法后，剩下的路径用(x,x)(x,x)(x,x)浪费掉即可。AT_agc037_dSortingaGrid从无序的状态转移到有序的状态可以倒着思考，从有序的状态思考能到达的状态的共同点。由有序的状态进行每行重排后每行的值域集合不会变，设行重排后的矩阵为：AAAAABBBBBCCCCCDDDDDEEEEE\\begin{matrix}A&amp;A&amp;A&amp;A&amp;A\\\\B&amp;B&amp;B&amp;B&amp;B\\\\C&amp;C&amp;C&amp;C&amp;C\\\\D&amp;D&amp;D&amp;D&amp;D\\\\E&amp;E&amp;E&amp;E&amp;E\\\\\\end{matrix}ABCDE​ABCDE​ABCDE​ABCDE​ABCDE​1≤A≤m,m+1≤B≤2m…1\\leA\\lem,m+1\\leB\\le2m\\dots1≤A≤m,m+1≤B≤2m…再列重排后矩阵的每一列都会包含A,B,C…A,B,C\\dotsA,B,C…各一个，这是操作两步的必然结论。最后一步再回到输入的乱序矩阵，则此时乱序矩阵进行行重排后需要满足每列都各有A,B,C…A,B,C\\dotsA,B,C…各一个的性质。◊\\Large{\\color{red}\\Diamond}◊进行构造时将枚举(i,j)(i,j)(i,j)后将i↔⌈ai,j−1m⌉+nmi\\leftrightarrow\\lceil\\frac{a_{i,j}-1}m\\rceil+nmi↔⌈mai,j​−1​⌉+nm，由于每行有mmm个数，每种字符会出现mmm次，所以最终连出的是正则二分图（每个点度数都相同的二分图），每次需要寻找出一组完美匹配表示当前列的状态，随后删除这组边并继续寻找二分图完美匹配。本图任选一个左部点集合都满足out(S)=∣S∣out(S)=|S|out(S)=∣S∣，由于Hall定理，存在完美匹配，删除匹配后依旧满足out(S)=∣S∣out(S)=|S|out(S)=∣S∣，所以一定可以找出mmm组完美匹配。◊\\Large{\\color{red}\\Diamond}◊AT_agc061_cFirstComeFirstServe设dpidp_idpi​表示[1,i][1,i][1,i]的答案，转移为dpi←2dpi−1−Cdp_i\\leftarrow2dp_{i-1}-Cdpi​←2dpi−1​−C，CCC为容斥掉的方案数。设iii最终取的值为ti∈{ai,bi}t_i\\in\\{a_i,b_i\\}ti​∈{ai​,bi​}，则tit_iti​取aia_iai​和bib_ibi​时结果相同当且仅当∀tj∉[ai,bi]\\forallt_j\\notin[a_i,b_i]∀tj​∈/​[ai​,bi​]，思考如何容斥掉这一部分。因为ai&lt;ai+1,bi&lt;bi+1a_i&lt;a_{i+1},b_i&lt;b_{i+1}ai​&lt;ai+1​,bi​&lt;bi+1​，所以区间之间不存在包含。若使∃tj∈[ai,bi]\\not\\existt_j\\in[a_i,b_i]​∃tj​∈[ai​,bi​]，则对于Li=min⁡j(bj&gt;ai),Ri=max⁡j(aj&lt;bi)L_i=\\minj(b_j&gt;a_i),R_i=\\maxj(a_j&lt;b_i)Li​=minj(bj​&gt;ai​),Ri​=maxj(aj​&lt;bi​)，当j∈[Li,i)j\\in[L_i,i)j∈[Li​,i)选tj=ajt_j=a_jtj​=aj​，j∈(i,Ri]j\\in(i,R_i]j∈(i,Ri​]选tj=bjt_j=b_jtj​=bj​，可以使k∈[Li,Ri]k\\in[L_i,R_i]k∈[Li​,Ri​]都可以选出tk∉[ai,bi]t_k\\notin[a_i,b_i]tk​∈/​[ai​,bi​]，即满足∃tj∈[ai,bi]\\not\\existt_j\\in[a_i,b_i]​∃tj​∈[ai​,bi​]。◊\\Large{\\color{red}\\Diamond}◊所以对于dpRidp_{R_i}dpRi​​需要删去aia_iai​和bib_ibi​重复的贡献，由于此时[Li,Ri][L_i,R_i][Li​,Ri​]的方案固定，所以dpRi←−dpLi−1dp_{R_i}\\leftarrow-dp_{L_{i-1}}dpRi​​←−dpLi−1​​。求LiL_iLi​和RiR_iRi​直接二分或双指针即可，复杂度为O(n)/O(nlog⁡2n)\\mathcalO(n)/\\mathcalO(n\\log_2n)O(n)/O(nlog2​n)。P6657【模板】LGV引理感觉原本的定义还是比较复杂，尝试用比较简洁但不一定足够适用的讲述。先构造矩阵M=[f(sx1,sy1,tx1,ty1)…f(sx1,sy1,txn,tyn)f(sx2,sy2,tx1,ty1)…f(sx2,sy2,txn,tyn)⋱f(sxn−1,syn−1,tx1,ty1)…f(sxn−1,syn−1,txn,tyn)f(sxn,syn,tx1,ty1)…f(sxn,syn,txn,tyn)]M=\\left[\\begin{matrix}f(sx_1,sy_1,tx_1,ty_1)&amp;\\dots&amp;f(sx_1,sy_1,tx_n,ty_n)\\\\f(sx_2,sy_2,tx_1,ty_1)&amp;\\dots&amp;f(sx_2,sy_2,tx_n,ty_n)\\\\&amp;\\ddots\\\\f(sx_{n-1},sy_{n-1},tx_1,ty_1)&amp;\\dots&amp;f(sx_{n-1},sy_{n-1},tx_n,ty_n)\\\\f(sx_n,sy_n,tx_1,ty_1)&amp;\\dots&amp;f(sx_n,sy_n,tx_n,ty_n)\\\\\\end{matrix}\\right]M=⎣⎢⎢⎢⎢⎡​f(sx1​,sy1​,tx1​,ty1​)f(sx2​,sy2​,tx1​,ty1​)f(sxn−1​,syn−1​,tx1​,ty1​)f(sxn​,syn​,tx1​,ty1​)​……⋱……​f(sx1​,sy1​,txn​,tyn​)f(sx2​,sy2​,txn​,tyn​)f(sxn−1​,syn−1​,txn​,tyn​)f(sxn​,syn​,txn​,tyn​)​⎦⎥⎥⎥⎥⎤​使用LGV引理需要保证存在构造从(sxi,syi)(sx_i,sy_i)(sxi​,syi​)到达(txpi,typj)(tx_{p_i},ty_{p_j})(txpi​​,typj​​)的nnn条路径之间互不相交，排列ppp只能为p={1,2,3..,n}p=\\{1,2,3..,n\\}p={1,2,3..,n}。换言之，若∃pi≠i\\existp_i\\neqi∃pi​​=i，则无法构造nnn条互不相交的路径。LGV引理只适用于DAG。LGV引理：从(sxi,syi)(sx_i,sy_i)(sxi​,syi​)到达(txi,tyi)(tx_i,ty_i)(txi​,tyi​)的nnn条路径互不相交的方案数为det⁡(M)\\det(M)det(M)。AT_agc057_dSumAvoidance神仙题，根本不可能想出来。首先∣A∣|A|∣A∣的上界显然是⌊S−12⌋\\lfloor\\frac{S-1}2\\rfloor⌊2S−1​⌋，因为(1,S−1),(2,S−2)…(1,S-1),(2,S-2)\\dots(1,S−1),(2,S−2)…不能同时存在，若2∣S2|S2∣S，也不能出现S2\\fracS22S​。而这个上界也可以直接构造出来，只要取最大的⌊S−12⌋\\lfloor\\frac{S-1}2\\rfloor⌊2S−1​⌋个数即可，因为任意两个数相加已经&gt;S&gt;S&gt;S。此时想要让字典序尽量小。令选择的集合包括A⊆[1,⌊S−12⌋]A\\subseteq[1,\\lfloor\\frac{S-1}2\\rfloor]A⊆[1,⌊2S−1​⌋]，B⊆[S−⌊S−12⌋,S−1]B\\subseteq[S-\\lfloor\\frac{S-1}2\\rfloor,S-1]B⊆[S−⌊2S−1​⌋,S−1]。将字典序变小的过程就是将一些x∈Bx\\inBx∈B的换成S−xS-xS−x。可以证明，直接从小到大，如果加入xxx后依旧凑不出SSS，则在答案集合加入xxx一定更优。◊\\Large{\\color{red}\\Diamond}◊证明：对于任意一个x∈[1,⌊S−12⌋]x\\in[1,\\lfloor\\frac{S-1}2\\rfloor]x∈[1,⌊2S−1​⌋]，若前面的数能凑出xxx，则加入xxx不影响凑其他数。否则前面的数无法凑出xxx，则可以加入S−xS-xS−x，由于后面的加入集合的数都&gt;x&gt;x&gt;x，所以不会导致S−xS-xS−x和其他数凑出SSS。这样就可以比较方便的O(S)O(S)O(S)求答案，思考如何继续加速贪心过程。设加入的最小数为ddd，由于d∣Sd\\not\\midSd​∣S，lcm(1,2,...43)&gt;1018lcm(1,2,...43)&gt;10^{18}lcm(1,2,...43)&gt;1018，所以d≤43d\\le43d≤43。思考两种添加方式，添加的数x≤⌊S−12⌋x\\le\\lfloor\\frac{S-1}2\\rfloorx≤⌊2S−1​⌋。xxx可以由AAA中的数凑出。xxx不能被AAA中的数凑出，但加入后也无法凑出SSS。111的做法可以后面二分时再处理，思考222会加入哪些数。因为d∈Ad\\inAd∈A，所以222加入的数在modd\\bmoddmodd意义下互不相同，否则可以用111做出，所以222加入的数至多O(d)\\mathcalO(d)O(d)，复杂度可以接受。◊\\Large{\\color{red}\\Diamond}◊令fi,i∈[1,d)f_i,i\\in[1,d)fi​,i∈[1,d)表示222加入的数modd=i\\bmodd=imodd=i的最小的数，转移时枚举加入vvv，若能加入需保证f(S−iv)modd+iv&gt;Sf_{(S-iv)\\bmodd}+iv&gt;Sf(S−iv)modd​+iv&gt;S，即保证v≥max⁡i=1d−1(⌊S−f(S−iv)moddi⌋+1)v\\ge\\max_{i=1}^{d-1}(\\lfloor\\frac{S-f_{(S-iv)\\bmodd}}i\\rfloor+1)v≥i=1maxd−1​(⌊iS−f(S−iv)modd​​⌋+1)由于转移式中只与vmoddv\\bmoddvmodd相关，所以枚举x=vxmoddx=v_x\\bmoddx=vx​modd，按上面的式子跑一遍后将vxv_xvx​加到vx≡x(modd)v_x\\equivx(\\bmodd)vx​≡x(modd)为止。这一步需要枚举xxx和iii，单次复杂度为O(d2)\\mathcalO(d^2)O(d2)。由于要从小到大进行贪心，所以对于所有的vxv_xvx​，每次只会选取最小的vmnv_{mn}vmn​更新所有的fff。更新fff时枚举i,j∈[1,d)i,j\\in[1,d)i,j∈[1,d)。f(i+j×vmn)modd←fi+j×vmnf_{(i+j\\timesv_{mn})\\bmodd}\\leftarrowf_i+j\\timesv_{mn}f(i+j×vmn​)modd​←fi​+j×vmn​由于每个x∈[0,d)x\\in[0,d)x∈[0,d)只会有至多一次x=mnx=mnx=mn将fxf_xfx​更新至最小值（最终值），所以会进行O(d)\\mathcalO(d)O(d)次上述的单次，复杂度为O(d3)\\mathcalO(d^3)O(d3)。AAA中≤x\\lex≤x的个数为∑i=0d−1max⁡(0,⌊x−fid⌋+[i=0])\\sum_{i=0}^{d-1}\\max(0,\\lfloor\\frac{x-f_i}d\\rfloor+[i\\not=0])∑i=0d−1​max(0,⌊dx−fi​​⌋+[i​=0])。注意f0=0f_0=0f0​=0，i=0i=0i=0时不加一是因为无法选取0∈A0\\inA0∈A。对于询问二分答案后求有多少个凑出的数≤x\\lex≤x，对于≤⌊S−12⌋\\le\\lfloor\\frac{S-1}2\\rfloor≤⌊2S−1​⌋的答案直接二分答案即可，&gt;⌊S−12⌋&gt;\\lfloor\\frac{S-1}2\\rfloor&gt;⌊2S−1​⌋的答案先将k←k−∣A∣k\\leftarrowk-|A|k←k−∣A∣后反着二分。本题最终复杂度为O(T(d3+dlog⁡2k))\\mathcalO(T(d^3+d\\log_2k))O(T(d3+dlog2​k))。CF1389GDirectingEdgesran_qwq的讲题，感觉有点像答辩缝合怪。连通性和给无向边定向先想到使用边双缩点，因为一个边双内的点一定可以定向成强连通分量，这样一定更优。此时从无向图变成了一棵树，然后考虑关键点的限制。先随便取一个关键点做根，若一个子树内没有关键点，则将边全部定向为u→fauu\\rightarrowfa_uu→fau​一定不劣，由于这种子树的贡献固定，所以再缩起来。具体的，若一条边(u,fau)(u,fa_u)(u,fau​)满足uuu子树内没有关键点，而faufa_ufau​子树内有关键点，则[关键点能到达fau]=[关键点能到达u][\\text{关键点能到达}fa_u]=[\\text{关键点能到达}u][关键点能到达fau​]=[关键点能到达u]，此时将uuu子树和faufa_ufau​缩到一起。此时所有叶子节点都是关键点。可以开始树形DP了。令fuf_ufu​表示uuu子树内强制选uuu为饱和点的收益，fu=max⁡(fv−w(u,v),0)+cuf_u=\\max(f_v-w(u,v),0)+c_ufu​=max(fv​−w(u,v),0)+cu​，当让顶点iii强制选为饱和点时将iii钦定为根即可，写下换根DP即可。代码没写，感觉依托。CF1017GTheTreelbw的题感觉都很妙。考虑将修改和查询的复杂度平衡，尝试类似于线段树标记永久化的思路。先不管2操作，若一个操作1v能影响到uuu，则v→fauv\\tofa_uv→fau​的点一定已经被标记为黑色，手玩可以发现修改之间的顺序其实不影响，所以将修改合并，即维护cuc_ucu​表示在uuu节点进行了cuc_ucu​次操作，则操作1v能影响到uuu当且仅当∑iisonpath(v,u)ci≥depu−depv+1\\sum_\\text{iisonpath(v,u)}c_i\\gedep_u-dep_v+1∑iisonpath(v,u)​ci​≥depu​−depv​+1，套路地，将depu−depv+1dep_u-dep_v+1depu​−depv​+1移到左边，分给每个iisonpath(v,u)\\text{iisonpath(v,u)}iisonpath(v,u)。将cuc_ucu​的初始值设为−1-1−1，然后求最大后缀和（一定要包含自己）是否≥0\\ge0≥0即可。现在考虑操作2u，首先肯定要将uuu子树内的所有cic_ici​设为−1-1−1，此外，需要让uuu向上的最大后缀和变为−1-1−1，所以将cu←cu−query(u)−1c_u\\getsc_u-query(u)-1cu​←cu​−query(u)−1。直接上树剖维护，复杂度O(nlog⁡2n)\\mathcalO(n\\log^2n)O(nlog2n)。AT_abc230_g[ABC230G]GCDPermutation令S(p)S(p)S(p)表示满足ppp命题的方案数。ans=S(gcd⁡(i,j)≠1∧gcd⁡(Pi,Pj)≠1)=S(1)−S(gcd⁡(i,j)=1)−S(gcd⁡(Pi,Pj)=1)+S(gcd⁡(i,j)=1∧gcd⁡(Pi,Pj)=1)=n(n+1)2−2∑i=1nφ(i)+S(gcd⁡(i,j)=1∧gcd⁡(Pi,Pj)=1)ans=S(\\gcd(i,j)\\ne1\\wedge\\gcd(P_i,P_j)\\ne1)\\\\=S(1)-S(\\gcd(i,j)=1)-S(\\gcd(P_i,P_j)=1)+S(\\gcd(i,j)=1\\wedge\\gcd(P_i,P_j)=1)\\\\=\\frac{n(n+1)}2-2\\sum_{i=1}^n\\varphi(i)+S(\\gcd(i,j)=1\\wedge\\gcd(P_i,P_j)=1)\\\\ans=S(gcd(i,j)​=1∧gcd(Pi​,Pj​)​=1)=S(1)−S(gcd(i,j)=1)−S(gcd(Pi​,Pj​)=1)+S(gcd(i,j)=1∧gcd(Pi​,Pj​)=1)=2n(n+1)​−2i=1∑n​φ(i)+S(gcd(i,j)=1∧gcd(Pi​,Pj​)=1)只要解决β=S(gcd⁡(i,j)=1∧gcd⁡(Pi,Pj)=1)=∑i=1n∑j=1n[gcd⁡(i,j)=1∧gcd⁡(Pi,Pj)=1]\\beta=S(\\gcd(i,j)=1\\wedge\\gcd(P_i,P_j)=1)=\\sum_{i=1}^n\\sum_{j=1}^n[\\gcd(i,j)=1\\wedge\\gcd(P_i,P_j)=1]β=S(gcd(i,j)=1∧gcd(Pi​,Pj​)=1)=∑i=1n​∑j=1n​[gcd(i,j)=1∧gcd(Pi​,Pj​)=1]即可。由莫反可得β=∑x=1n∑y=1nμ(x)μ(y)∑i=1n∑j=1n[(x∣gcd⁡(i,j))∧(y∣gcd⁡(Pi,Pj))]=∑x=1n∑y=1nμ(x)μ(y)((∑x∣i,y∣Pi1)+12)letf(x,y)=∑i=1n[x∣i∧y∣pi]β=∑x=1n∑y=1nμ(x)μ(y)(f(x,y)+1)f(x,y)2\\beta=\\sum_{x=1}^n\\sum_{y=1}^n\\mu(x)\\mu(y)\\sum_{i=1}^n\\sum_{j=1}^n[(x|\\gcd(i,j))\\wedge(y|\\gcd(P_i,P_j))]\\\\=\\sum_{x=1}^n\\sum_{y=1}^n\\mu(x)\\mu(y)\\binom{(\\sum_{x|i,y|P_i}1)+1}2\\\\\\text{let}f(x,y)=\\sum_{i=1}^n[x|i\\wedgey|p_i]\\\\\\beta=\\sum_{x=1}^n\\sum_{y=1}^n\\mu(x)\\mu(y)\\frac{(f(x,y)+1)f(x,y)}2β=x=1∑n​y=1∑n​μ(x)μ(y)i=1∑n​j=1∑n​[(x∣gcd(i,j))∧(y∣gcd(Pi​,Pj​))]=x=1∑n​y=1∑n​μ(x)μ(y)(2(∑x∣i,y∣Pi​​1)+1​)letf(x,y)=i=1∑n​[x∣i∧y∣pi​]β=x=1∑n​y=1∑n​μ(x)μ(y)2(f(x,y)+1)f(x,y)​每次加入一个新的数时枚举x∣i,y∣Pix|i,y|P_ix∣i,y∣Pi​并修改对β\\betaβ的贡献即可，复杂度为O(nln⁡n+∑i=1nd(i)2)\\mathcalO(n\\lnn+\\sum_{i=1}^nd(i)^2)O(nlnn+∑i=1n​d(i)2)，打表得N=2×105N=2\\times10^5N=2×105时大约为6×1076\\times10^76×107。P13997【MX-X19-T6】「FeOIRound4.5」はぐ路径上求可以差分转化成四个点到根求，同时可能有ai←ai±depia_i\\getsa_i\\pmdep_iai​←ai​±depi​，然后就是求⨁i=0dis(1,x)(api+k)\\bigoplus_{i=0}^{dis(1,x)}(a_{p_i}+k)⨁i=0dis(1,x)​(api​​+k)，其中pip_ipi​为111走到xxx的经过的第iii个点。每个位单独考虑，xkx_kxk​表示xxx二进制下的第kkk位的值，拆项得(aj+k)i=(aj)i⊕ki⊕[(ajmod2i+kmod2i)≥2i](a_j+k)_i=(a_j)_i\\oplusk_i\\oplus[(a_j\\bmod2^i+k\\bmod2^i)\\ge2^i](aj​+k)i​=(aj​)i​⊕ki​⊕[(aj​mod2i+kmod2i)≥2i]⨁(aj)i\\bigoplus(a_j)_i⨁(aj​)i​可以直接预处理出根到xxx的aaa的异或和，kkk直接看depxdep_xdepx​的奇偶性即可，最后一个考虑离线下来，将询问(x,k,i)(x,k,i)(x,k,i)挂在xxx上，使用BIT维护当前点祖先的ajmod2ia_j\\bmod2^iaj​mod2i即可，复杂度为O(nlog⁡2n)\\mathcalO(n\\log^2n)O(nlog2n)。One,Two,Three怎么出了若干次的题都还没补过。设共匹配AAA组(1,2,3)(1,2,3)(1,2,3)和BBB组(3,2,1)(3,2,1)(3,2,1)，求max⁡(A+B)\\max(A+B)max(A+B)。显然(1,2,3)(1,2,3)(1,2,3)选定的一定是最左边的AAA个111和最右边的AAA个333，(3,2,1)(3,2,1)(3,2,1)同理。再分讨一下发现取的(1,2,3)(1,2,3)(1,2,3)匹配(ai,bi,ci)(a_i,b_i,c_i)(ai​,bi​,ci​)满足a1&lt;a2&lt;⋯&lt;aAa_1&lt;a_2&lt;\\dots&lt;a_Aa1​&lt;a2​&lt;⋯&lt;aA​，b1&lt;b2&lt;⋯&lt;bAb_1&lt;b_2&lt;\\dots&lt;b_Ab1​&lt;b2​&lt;⋯&lt;bA​，c1&lt;c2&lt;⋯&lt;cAc_1&lt;c_2&lt;\\dots&lt;c_Ac1​&lt;c2​&lt;⋯&lt;cA​一定是不劣的，证明可以讨论222的位置。现在就可以将匹配对应到A+BA+BA+B个区间了。过程其实就类似二分图匹配，需要对A+BA+BA+B个区间[li,ri][l_i,r_i][li​,ri​]匹配所在区间内的222。考虑HALL定理，即需要满足对于任意一个S∈[A+B]S\\in[A+B]S∈[A+B]，满足∣S∣≤cnt2(∪[li,ri]),i∈S|S|\\lecnt2(\\cup[l_i,r_i]),i\\inS∣S∣≤cnt2(∪[li​,ri​]),i∈S，由于区间之间有偏序关系，即∀li&lt;lj,ri&lt;rj\\foralll_i&lt;l_j,r_i&lt;r_j∀li​&lt;lj​,ri​&lt;rj​，所以实际上SSS取到一个区间是本质相同的，即R−L+1≤cnt2[lL,rR]R-L+1\\lecnt2[l_L,r_R]R−L+1≤cnt2[lL​,rR​]。换一种说法，就是对于每一个区间[l,r][l,r][l,r]，令被[l,r][l,r][l,r]严格包含的区间数量为fl,rf_{l,r}fl,r​，则满足∀l≤r,fl,r≤cnt2[l,r]\\foralll\\ler,f_{l,r}\\lecnt2[l,r]∀l≤r,fl,r​≤cnt2[l,r]。对于每对(A,B)(A,B)(A,B)，考虑fl,rf_{l,r}fl,r​的下界，先考虑(1,2,3)(1,2,3)(1,2,3)的情况，令x←cnt1(1,l−1),y←cnt3(r+1,n)x\\getscnt1(1,l-1),y\\getscnt3(r+1,n)x←cnt1(1,l−1),y←cnt3(r+1,n)，则[l,r][l,r][l,r]需要包含max⁡(0,A−x)\\max(0,A-x)max(0,A−x)个111和max⁡(0,A−y)\\max(0,A-y)max(0,A−y)个333，按照匹配的顺序左右端点都单调可以发现[l,r][l,r][l,r]的最右边yyy个111和最左边xxx个333会被外面的点匹配，所以内部就会剩下max⁡(A−x−y,0)\\max(A-x-y,0)max(A−x−y,0)组(1,3)(1,3)(1,3)需要匹配，所以有max⁡(A−x−y,0)≤cnt2[l,r]\\max(A-x-y,0)\\lecnt2[l,r]max(A−x−y,0)≤cnt2[l,r]。同理考虑(3,2,1)(3,2,1)(3,2,1)的情况能得到max⁡(A−cnt1[0,l−1]−cnt3[r+1,n],0)+max⁡(B−cnt3[0,l−1]−cnt1[r+1,n],0)≤fl,r≤cnt2[l,r]\\max(A-cnt1[0,l-1]-cnt3[r+1,n],0)+\\max(B-cnt3[0,l-1]-cnt1[r+1,n],0)\\lef_{l,r}\\lecnt2[l,r]max(A−cnt1[0,l−1]−cnt3[r+1,n],0)+max(B−cnt3[0,l−1]−cnt1[r+1,n],0)≤fl,r​≤cnt2[l,r]。分讨两个max⁡\\maxmax的取值，就能得到A,B,A+BA,B,A+BA,B,A+B的范围了，构造由于(1,2,3)(1,2,3)(1,2,3)和(3,2,1)(3,2,1)(3,2,1)的区间内部满足左右端点都是单调的，所以在左端点加入，发现一个222时贪心匹配最小的右端点即可。时间复杂度为O(n)\\mathcalO(n)O(n)。","link":"https://yaohaoyou.github.io/post/summer-solution/"},{"title":"比赛题解","content":"◊\\Large{\\color{red}\\Diamond}◊为重点转换步骤。typer直接设fi,jf_{i,j}fi,j​表示前S[1∼i]S[1\\simi]S[1∼i]匹配T[1∼j]T[1\\simj]T[1∼j]位的答案。fi,j=min⁡(fi−1,j+1,fi,j−1+1,fi−1,j−1+[Si=Tj])f_{i,j}=\\min(f_{i-1,j}+1,f_{i,j-1}+1,f_{i-1,j-1}+[S_i\\not=T_j])fi,j​=min(fi−1,j​+1,fi,j−1​+1,fi−1,j−1​+[Si​​=Tj​])直接做复杂度为O(∣S∣m∣T∣)\\mathcalO(|S|m|T|)O(∣S∣m∣T∣)。由于∣T∣≤20|T|\\le20∣T∣≤20，并且发现i−j≤fi,j≤i+ji-j\\lef_{i,j}\\lei+ji−j≤fi,j​≤i+j，所以i+j−fi,j≤2∣T∣i+j-f_{i,j}\\le2|T|i+j−fi,j​≤2∣T∣，由于值域范围小，所以套路性的将值域放在定义维上，将原本的iii定为dp值。◊\\Large{\\color{red}\\Diamond}◊设gi,jg_{i,j}gi,j​为满足fx,i=x+i−jf_{x,i}=x+i-jfx,i​=x+i−j最小的xxx。上面的fff的转移式中前两种方法的i+j−fi,ji+j-f_{i,j}i+j−fi,j​是不变的，所以先gi,j←gi−1,jg_{i,j}\\leftarrowg_{i-1,j}gi,j​←gi−1,j​。若想让Si=TjS_i=T_jSi​=Tj​，gi,j←k(k&gt;gi−1,j−2,Sk=Tj)g_{i,j}\\leftarrowk(k&gt;g_{i-1,j-2},S_k=T_j)gi,j​←k(k&gt;gi−1,j−2​,Sk​=Tj​)，否则gi,j←k(k&gt;gi−1,j−1,Sk≠Tj)g_{i,j}\\leftarrowk(k&gt;g_{i-1,j-1},S_k\\neqT_j)gi,j​←k(k&gt;gi−1,j−1​,Sk​​=Tj​)。预处理出每个位置nxi,j,0/1nx_{i,j,0/1}nxi,j,0/1​表示SiS_iSi​后字符为/不为jjj的第一个位置。sum本题保证了无重边自环。k=1k=1k=1简单。将∑f(S)2\\sumf(S)^2∑f(S)2转成∑(f(S)2)\\sum\\binom{f(S)}2∑(2f(S)​)，赋予组合意义即为从SSS的导出子图中任意选两条边的方案数的和，从而可以拆贡献至选取两条边进行计算。◊\\Large{\\color{red}\\Diamond}◊f(S)2=2(f(S)2)+f(S)f(S)^2=2\\binom{f(S)}2+f(S)f(S)2=2(2f(S)​)+f(S)两条边的情况可能是两条无交边或有一个公用顶点，分开讨论并枚举公共点即可。f(S)3=6(f(S)3)+3f(S)2−2f(S)f(S)^3=6\\binom{f(S)}3+3f(S)^2-2f(S)f(S)3=6(3f(S)​)+3f(S)2−2f(S)f(S)2f(S)^2f(S)2和f(S)f(S)f(S)直接使用上面的即可，重点讨论(f(S)3)\\binom{f(S)}3(3f(S)​)如何拆开。影响结果的只有任选的三条边的点数xxx和方案数yyy，贡献为y2n−xy2^{n-x}y2n−x。x=3,4,5,6x={3,4,5,6}x=3,4,5,6。由于总方案数为(m3)\\binom{m}3(3m​)，所以x=6x=6x=6可以直接用总的减去其它的计算。x=3x=3x=3，即一个三元环。直接用三元环计数即可，令方案数为AAA，复杂度为O(mm)O(m\\sqrtm)O(mm​)。x=4x=4x=4，可能是一条链或者一个菊花。链：枚举中间那一条边(u,v)(u,v)(u,v)，方案数B=(∑(degu−1)×(degv−1))−3AB=(\\sum(deg_u-1)\\times(deg_v-1))-3AB=(∑(degu​−1)×(degv​−1))−3A，最后减3A3A3A是因为如果形成三元环，每条边都会被作为中间的边多算一次。菊花：枚举度数为333的点uuu，方案数C=∑(degu3)C=\\sum\\binom{deg_u}{3}C=∑(3degu​​)。x=5x=5x=5，即分离的一条三元链和一条边，枚举三元链的中心uuu，方案数D=(∑(degu2)(m−2))−3A−2B−3CD=(\\sum\\binom{deg_u}2(m-2))-3A-2B-3CD=(∑(2degu​​)(m−2))−3A−2B−3C。3A3A3A因为三元环中三个点都会被作为链中心，2B2B2B因为插入的新边可能在链的两端，3C3C3C因为菊花的三条边都会被作为插入的新边。x=6x=6x=6，E=(m3)−A−B−C−DE=\\binomm3-A-B-C-DE=(3m​)−A−B−C−D。(f(S)3)=2n−3A+2n−4(B+C)+2n−5D+2n−6E\\binom{f(S)}3=2^{n-3}A+2^{n-4}(B+C)+2^{n-5}D+2^{n-6}E(3f(S)​)=2n−3A+2n−4(B+C)+2n−5D+2n−6E。sort寻找第kkk小可以先转化成二分答案+求有多少个≤mid\\lemid≤mid。k←k−1k\\leftarrowk-1k←k−1这里的字典序有些不同，可以直接用AiA_iAi​记录iii出现的次数，比较AAA和BBB时从i=1→ni=1\\toni=1→n比较AiA_iAi​和BiB_iBi​即可，若Ai&lt;BiA_i&lt;B_iAi​&lt;Bi​则A&gt;BA&gt;BA&gt;B，Ai&gt;BiA_i&gt;B_iAi​&gt;Bi​则A&lt;BA&lt;BA&lt;B。由于增加一个数一定会使字典序变小，所以S[l,l]&gt;S[l,l+1]&gt;...&gt;S[l,n]S[l,l]&gt;S[l,l+1]&gt;...&gt;S[l,n]S[l,l]&gt;S[l,l+1]&gt;...&gt;S[l,n]且S[1,r]&lt;S[2,r]&lt;...S[r,r]S[1,r]&lt;S[2,r]&lt;...S[r,r]S[1,r]&lt;S[2,r]&lt;...S[r,r]，于是对于左端点固定的区间具有单调性，设二分的区间是[L,R][L,R][L,R]，则可以通过双指针或二分对每个iii求出MiM_iMi​使S[i,n]&lt;S[i,n−1]&lt;...&lt;S[i,Mi]≤S[L,R]S[i,n]&lt;S[i,n-1]&lt;...&lt;S[i,M_i]\\leS[L,R]S[i,n]&lt;S[i,n−1]&lt;...&lt;S[i,Mi​]≤S[L,R]，进而求出S[L,R]S[L,R]S[L,R]的排名。◊\\Large{\\color{red}\\Diamond}◊若rnk(S[L,R])≤krnk(S[L,R])\\lekrnk(S[L,R])≤k，则将pri=Mi−1pr_i=M_i-1pri​=Mi​−1表示删去[i,Mi],[i,Mi+1]...[i,n][i,M_i],[i,M_i+1]...[i,n][i,Mi​],[i,Mi​+1]...[i,n]，并将k←k−rnk(S[L,R])k\\leftarrowk-rnk(S[L,R])k←k−rnk(S[L,R])。否则将pli=Mipl_{i}=M_ipli​=Mi​表示删去[i,i],[i,i+1],...[i,Mi−1][i,i],[i,i+1],...[i,M_i-1][i,i],[i,i+1],...[i,Mi​−1]。生成[L,R][L,R][L,R]时在剩余的所有区间中随机一个即可，期望每次能选到字典序排名的重点左右，所以复杂度是O(log⁡n)O(\\logn)O(logn)的。双指针的过程就是有O(n)O(n)O(n)次加入和删除一个字符，并查询桶内第一个和S[l,r]S[l,r]S[l,r]的桶内的不同值。可以使用线段树维护Ti=Ai−BiT_i=A_i-B_iTi​=Ai​−Bi​，加入字符ccc时将Tc←Tc+1T_c\\leftarrowT_c+1Tc​←Tc​+1，删除时Tc←Tc−1T_c\\leftarrowT_c-1Tc​←Tc​−1，查询时在线段树上二分或提前存储第一个Ti≠0T_i\\neq0Ti​​=0，若Ti&gt;0T_i&gt;0Ti​&gt;0则A&lt;BA&lt;BA&lt;B，否则A&gt;BA&gt;BA&gt;B。总复杂度为O(nlog⁡2n)O(n\\log^2n)O(nlog2n)。countcircle设Li,j,Ri,j,Ui,j,Di,jL_{i,j},R_{i,j},U_{i,j},D_{i,j}Li,j​,Ri,j​,Ui,j​,Di,j​分别表示(i,j)(i,j)(i,j)向左，向右，向上，向下能走到的最远的位置。原题就是求∑i=1n∑j=1m∑x=Uii−1∑y=Ljj−1[Dx,y≥i∧Rx,y≥j]\\sum_{i=1}^n\\sum_{j=1}^m\\sum_{x=U_i}^{i-1}\\sum_{y=L_j}^{j-1}[D_{x,y}\\gei\\wedgeR_{x,y}\\gej]i=1∑n​j=1∑m​x=Ui​∑i−1​y=Lj​∑j−1​[Dx,y​≥i∧Rx,y​≥j]明显上面的式子是四维的，无法直接做。将矩阵进行分治，选择竖着的中线midmidmid，分别对左右独立讨论经过中线的方案数再乘起来，将四维转换为三维。◊\\Large{\\color{red}\\Diamond}◊两边情况相似，只考虑左侧穿过中线的情况。先枚举u∈[1,n],v∈(u,n]u\\in[1,n],v\\in(u,n]u∈[1,n],v∈(u,n]，计算左侧选取的匚的数量。于是现在只要求∑u=LR∑v=u+1R∑x=max⁡(l,Lu,mid,Lv,mid)mid−1[Du,x≥v]\\sum_{u=L}^R\\sum_{v=u+1}^R\\sum_{x=\\max(l,L_{u,mid},L_{v,mid})}^{mid-1}[D_{u,x}\\gev]u=L∑R​v=u+1∑R​x=max(l,Lu,mid​,Lv,mid​)∑mid−1​[Du,x​≥v]枚举完u,vu,vu,v后分类讨论max⁡(l,Lu,mid)\\max(l,L_{u,mid})max(l,Lu,mid​)和max⁡(l,Lv,mid)\\max(l,L_{v,mid})max(l,Lv,mid​)哪个更大，若前者更大，则对于所有uuu询问的区间已经固定，所以只要开一个桶记录Du,xD_{u,x}Du,x​的后缀个数和。如果是后者更大，就相当于求∑x=max⁡(l,Lv,mid)mid−1[Uv,x≤u]\\displaystyle\\sum_{x=\\max(l,L_{v,mid})}^{mid-1}[U_{v,x}\\leu]x=max(l,Lv,mid​)∑mid−1​[Uv,x​≤u]，处理方式和上面类似，开另一个桶记录Uv,xU_{v,x}Uv,x​的前缀个数和。这样就能单次O(1)O(1)O(1)解决。设len=r−l+1,LEN=R−L+1len=r-l+1,LEN=R-L+1len=r−l+1,LEN=R−L+1，这样单次的复杂度为O(LEN2+len×LEN)\\mathcalO(LEN^2+len\\timesLEN)O(LEN2+len×LEN)，由于分治时面积每次一定会减半，所以递归层数为O(log⁡2nm)\\mathcalO(\\log_2nm)O(log2​nm)。若能保证LEN≤lenLEN\\lelenLEN≤len则单次复杂度为O(len×LEN)\\mathcalO(len\\timesLEN)O(len×LEN)，此时总复杂度正确。每次递归后若LEN&gt;lenLEN&gt;lenLEN&gt;len则从[l,r][l,r][l,r]中间取中线变为从[L,R][L,R][L,R]中间取中线，复杂度为O(nmlog⁡2nm)\\mathcalO(nm\\log_2nm)O(nmlog2​nm)。frame多树问题和距离问题考虑点分治和点分树。点分树的性质：原树上u,vu,vu,v的路径会经过点分树上的LCA(u,v)LCA(u,v)LCA(u,v)，所以dis(x,y)=dis(x,LCA′(x,y))+dis(LCA′(x,y),y)dis(x,y)=dis(x,LCA&#x27;(x,y))+dis(LCA&#x27;(x,y),y)dis(x,y)=dis(x,LCA′(x,y))+dis(LCA′(x,y),y)，LCA′LCA&#x27;LCA′表示在点分树上的lca。◊\\Large{\\color{red}\\Diamond}◊考虑对第一棵树进行点分治，若当前分治中心为rtrtrt，已经处理过的点集为SSS，当前需要求uuu到SSS的答案。设iii以rtrtrt为根的深度为aia_iai​，则需要求min⁡v∈Sau+av+dis2(u,v)\\min_{v\\inS}a_u+a_v+dis_2(u,v)minv∈S​au​+av​+dis2​(u,v)，由点分治的性质可得\\min_{v\\inS}a_u+a_v+dis_2(u,v)=\\min_{v\\inS}a_u+a_v+dis_2(u,LCA_{2&#039;}(u,v))+dis_2(LCA_{2&#039;}(u,v),v)\\\\=\\min_{v\\inS,x=LCA_{2&#039;}(u,v)}(a_u+dis_2(u,x))+(a_v+dis_2(v,x))&amp;\\Large{\\color{red}\\Diamond}xxx为点分树上uuu和vvv的祖先，所以xxx只有O(log⁡2n)\\mathcalO(\\log_2n)O(log2​n)个，当将vvv加入SSS时，跳过vvv的每个祖先xxx并将av+dis2(v,x)a_v+dis_2(v,x)av​+dis2​(v,x)的贡献挂在xxx上，uuu查询时只要将挂在所有祖先的贡献加上au+dis2(u,x)a_u+dis_2(u,x)au​+dis2​(u,x)后求最大值即可，若u,vu,vu,v在xxx的同一颗子树内，则长度只会更大，不影响最小值更新。复杂度为O(nlog⁡2n)\\mathcalO(n\\log^2n)O(nlog2n)，瓶颈在点分治和在点分树上跳祖先。岁月正难则反。先容斥一下，考虑计算有多少方案使得没有一个点能被1，21，21，2同时到达。◊\\Large{\\color{red}\\Diamond}◊令fSf_SfS​表示只保留SSS导出子图并给其定向，111恰好能到达x∈Sx\\inSx∈S的方案数，gSg_SgS​和fSf_SfS​同理，从222号点出发，w(S)w(S)w(S)表示SSS的导出子图的边数。ans=2m−∑S∩T=∅fSgT2w(U−S−T)ans=2^m-\\sum_{S\\capT=\\empty}f_Sg_T2^{w(U-S-T)}ans=2m−S∩T=∅∑​fS​gT​2w(U−S−T)由于S∩T=∅S\\capT=\\emptyS∩T=∅，所以只需枚举T⊆U−ST\\subeU-ST⊆U−S即可，复杂度为O(3n)\\mathcalO(3^n)O(3n)。思考如何求f,gf,gf,g，同样用总方案数2w(S)2^{w(S)}2w(S)减去不合法的。先枚举T⊂ST\\subST⊂S，计算只能到达TTT的方案数。内部可达为fTf_TfT​，外部S−TS-TS−T的导出子图随意，一条边(u,v),u∈T,v∈S−T(u,v),u\\inT,v\\inS-T(u,v),u∈T,v∈S−T的只能定向为(v,u)(v,u)(v,u)，所以方案数为2w(S−T)fT2^{w(S-T)}f_T2w(S−T)fT​，枚举子集复杂度也是O(3n)\\mathcalO(3^n)O(3n)。总复杂度为O(3n)\\mathcalO(3^n)O(3n)。","link":"https://yaohaoyou.github.io/post/contest-solution/"},{"title":"PKUWC 2025","content":"Day0坐半天高铁到绍兴了，感谢黄连赞助的adofai，结果他自己没得玩。结果酒店没预定，等了10+min后换酒店了。见到了pyb和《我这里不是网吧》。话说为什么酒店公共网络什么都能上，但就是上不了qiu。和log住一间。外卖都没有什么好点的，最后点了推荐的，量挺多，但还挺贵。qiu自摸四暗刻极限翻盘，加大分，赛前溢满rp++Day1早上起床后参加开幕式，好像没什么，直到。。。有请GDFZwxp教练（choi此时上台领奖）。然后结束就飞奔去抢饭了，吃完学长都没打完，人多的比较逆天。12：20考场竟然不在学校里，去试机的路上发现THU好像都还在打，有点爽啊。13：00开题，才发现原来一共只有4h。14:00只会a=2a=2a=2和a&gt;b+1a&gt;b+1a&gt;b+1，暴力好像什么都跑不出来，要完蛋了。先开T2。14:30T2只会24pts，本以为很妙，结果好像就是暴力，不展开了。继续回去看T1。15:30继续手玩T1，暴力加上一点点优化后没想到快了超多，拿到了a,b≤4a,b\\le4a,b≤4。打表出来，好像原来手推的答案都错了，随便输出一组构造，结果发现直接将a+ba+ba+b个电池平均分成a−1a-1a−1组，抽屉原理得至少一组有至少222个好电池，直接每组暴力做就过了。前面全部想偏了，现在还不知道怎么证，但觉得非常不合常理。严厉批斗O(T)O(T)O(T)的题目数据范围是T,a,b≤1000T,a,b\\le1000T,a,b≤1000。看T2，好像会L=1L=1L=1，结果假了。看T3，好像会AB性质。写写写。写了40min+，过了样例，交，0pts。T3的A性质把DAG看成树了，白打了，唐！已经没什么时间了，好像暴力还不好打。T2T3反复横跳。最后10min，直接摆了，受不了一点。结果发现竟然有SublimeText，Day2可以用。100+24+0=124100+24+0=124100+24+0=124。出来了，ljq161，lgg&amp;lbs124。被yyx和本伟薄纱了。好像又垫底了。。。ljq母亲带我们去吃饭了，为什么绍兴菜都是辣、甜、咸啊。晚上好无聊啊，qiu都没什么意思了。等Day2翻盘？Day2上午听讲座讲AI。吃完饭，休息一下。提前10min到考场配sublime。开题，T1交互，T2疑似DP，T3小清新。2h30min还没拿分，感觉要爆了。T1胡了几个做法都错了（2次in是什么鬼？），T2的暴力怎么写都拿不了分，先开T3。T3写了暴力24，结果不太会B≤4B\\le4B≤4，应该可以暴力分讨，但是先去写前面吧。T2写了c=1c=1c=1。怎么不会T1，不切T1你切什么题，不切题你打什么比赛。但是这次是真不会。过一会发现原来早就会写n3n^3n3，直接写了。只剩30min，心态要爆了，T1好像没有一点非暴力做法。结束了。16+11+24=5116+11+24=5116+11+24=51。好多拿过约的都在磕T1。lgg会3n3n3n，ljq会4n4n4n，好像又是垫底，烦！log和我又是一个分。THU那边好像好一点，mlk终于金牌了，/bx/bx/bx。","link":"https://yaohaoyou.github.io/post/pkuwc2025/"},{"title":"GDOI2025 又记","content":"更爽的阅读体验前言马上回归综合了，所以就早点写了吧。。。前情提要NOIP排名都去到200+了，省选可能就走过场吧。。。Day-1晚上没要到体锻不爽。（原来NOIP前也没要到）。Day0早上10点出发去佛山，酒店有点偏，好像附近只有M吃。中午发现一群疑似旅游的大爷大妈来吃饭，场景还是太壮观了。试机发现竟然有vs+cph和cpeditor，从没打过这么富裕的仗，终于可以不用sublime了。Day1酒店早餐爆吃，所以比较早就去考场了。开T1，还比较可做，应该分情况讨论一下直接两次二分求区间就行了，感觉刚开始思路比较绕，所以写了O(nV)\\mathcalO(nV)O(nV)的，后面改了好久才写完O(nlog⁡2V)\\mathcalO(n\\log_2V)O(nlog2​V)。这唐题也是给我写了2h，有点急。T2n≤105n\\le10^5n≤1052GB+6s，一看就是bitset题，感觉比较能写。看了一会写了跑不满的O(n2ω+nq)\\mathcalO(\\frac{n^2}{\\omega}+nq)O(ωn2​+nq)当暴力，6×1046\\times10^46×104要跑9s左右，不知道能不能骗到分。又看了一下，发现B性质可以用DS做O(n2log⁡2nω)\\mathcalO(\\frac{n^2\\log_2n}\\omega)O(ωn2log2​n​)，因为空间要用树状数组，log⁡n\\lognlogn常数比较小，先写了，跑8×1048\\times10^48×104卡满都只要3s，非常爽。T3暴力，看了半天还是不会树。后面又回来看T2，会了AC，和B其实差不多，复杂度一样，但常数更大，先开写，此时只剩下15min。最后5min发现写错了一点，遂放弃，感觉比较可惜，但还是只能检查代码了。100+36+8=144100+36+8=144100+36+8=144。mlk会T352pts还是太恐怖了，其他人好像都差不多，yinhee（sana)切T2了，这也太有实力了。cyz怎么像generals一样丢代码了？祝好。又有聚餐。回酒店时思考为什么T2没有想过根号？？？下午好像都在晃晃晃。。。Day2开T1，部分分给的这么多，好像还比较可做。手玩一下发现直接按tit_iti​从小到大做不劣，剩下直接ds模拟整个过程就行了。想起来AT_abc371_f的线段树维护ai−ia_i-iai​−i的trick，剩下就上个线段树上二分就行了。一开始写错二分，但又把大样例过完了，改成单log发现了，也是rp++了。写完又花了差不多2h，吸取Day1经验，先不开拍了。后面两题计数，只会暴力，撤了。100+12+8=120100+12+8=120100+12+8=120。还是聚餐，但是可以直接回家了。Day3竟然还有周一放假！晚上回学校写了这篇游记。终于写完了。下雨了，比较伤感，NOIP后机房也少了许多面孔，特别是机位旁边的jx哥，感觉竞赛还是充满着遗憾。也不知道退役离我有多远，也许离开早已是命运。初中也快结束了，可能不甘和遗憾才是青春吧。但是还是舍不得大家啊。希望大家一直记得我。“希望大家永远忘了我。”Day¿云斗没挂，但也没反向挂，也挺好的。为什么D1T2乱搞可以拿巨量分数啊！","link":"https://yaohaoyou.github.io/post/GDOI2025/"},{"title":"NOIP 犹记","content":"更爽的阅读体验前言出分后再写邮寄是好习惯。前情提要这篇游记是在Day7写的，可能比较暴躁，讲究看吧。不要恶评，看到就删。Day0晚上没要到体锻不爽。Day16点多就起了，7：00出发去考场。要用Sublime，不爽。开T1，好答辩（满脑子循环播放：你不切T1你切什么题，你不切题你打什么比赛）。应该直接贪心是对的，但是也不确定。矛盾后终于开写了，1h左右一遍过大样例了，爽，上个厕所压压惊。T2应该不用矩阵快速幂，直接算就行了。30min写完，一遍过大样例，爽（伏笔才1.5h，放松许多。开始拼暴力，T3是什么鬼，跳了。T4应该是DS，想想想。不会一点，直接拼部分分。T3完全看不懂是在干什么，只会暴力，k=1k=1k=1都不会，rlfl。感觉后面一直在坐牢，连拍子都没上，部分分也不太会打（伏笔估分：100+100+12+36=248100+100+12+36=248100+100+12+36=248。出来了。不出意外，部分分打得太少了，T3好像很多都应该要会，真要学计数了。Day7早上信息会考。下午知道分了，洛谷上没挂分，爽！（伏笔1hlater......好像T2挂了30pts。真的服了，多写了一个=。依照惯例，下面放个代码。sort(a+1,a+n+1);for(inti=1;i&lt;=n;i++)if(a[i].fi==a[i+1].fi&amp;&amp;a[i].se!=a[i+1].se)returnputs(&quot;0&quot;),void();n=unique(a+1,a+n+1)-a-1;解释一下，因为有多测，而for循环中访问到了an+1a_{n+1}an+1​，所以有可能在上组多测中an+1.fi=a_{n+1.fi}=an+1.fi​=当前多测的an.fia_{n.fi}an.fi​，然后就多判了000。但是这概率不应该超级小吗，T≤10T\\le10T≤10能给我挂6个点，我#@!$!Y$!($&amp;(!&amp;)$!@&amp;$^&amp;@!$。但是为什么_log_的如果ans=0ans=0ans=0不为T组询问中的后缀就会错都能通过，CCF负众望。。。烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦听说misakaS组也有这个问题，但是CCF数据没挂。等正式分吧。upd：被骗了，只挂了151515。100+85+16+32=233100+85+16+32=233100+85+16+32=233。","link":"https://yaohaoyou.github.io/post/noip2024/"},{"title":"AT_arc187_d Many Easy Optimizations 题解","content":"题目传送器更爽的阅读体验前言怎么没有人写官方做法，set应该比线段树好写吧。题意给定长为nnn的序列a,ba,ba,b，对k∈[1,n]k\\in[1,n]k∈[1,n]求min⁡{max⁡i=1kci−min⁡i=1kci,ci=ai∨ci=bi}\\min\\{\\max_{i=1}^kc_i-\\min_{i=1}^kc_i,c_i=a_i\\veec_i=b_i\\}min{maxi=1k​ci​−mini=1k​ci​,ci​=ai​∨ci​=bi​}。做法开始也没什么信息，所以可以先钦定c1=a1∨c1=b1c_1=a_1\\veec_1=b_1c1​=a1​∨c1​=b1​。当c1c_1c1​固定后，可以分析出一些结论了。设ai≤bia_i\\leb_iai​≤bi​，若不是就交换一下，则变成在区间上取两个端点之一。对于ai≤bi≤c1a_i\\leb_i\\lec_1ai​≤bi​≤c1​，显然ci=bic_i=b_ici​=bi​是不劣的，同理，c1≤ai≤bic_1\\lea_i\\leb_ic1​≤ai​≤bi​，选择ci=aic_i=a_ici​=ai​是不劣的。当固定这些cic_ici​后，又可以固定更多的cjc_jcj​。形式化的，设LLL为当前固定的cic_ici​中的最小值，RRR为最大值，则满足剩下的ai&lt;L≤R&lt;bia_i&lt;L\\leR&lt;b_iai​&lt;L≤R&lt;bi​。接着考虑剩下的区间，若存在ai≤aj≤bj≤bia_i\\lea_j\\leb_j\\leb_iai​≤aj​≤bj​≤bi​，即存在包含关系时，iii所形成的极差一定不会比jjj的更小，所以jjj必然不会贡献答案，可以删除jjj。将最后剩下的区间设为l1≤⋯≤lm≤L≤R≤r1≤⋯≤rml_1\\le\\dots\\lel_m\\leL\\leR\\ler_1\\le\\dots\\ler_ml1​≤⋯≤lm​≤L≤R≤r1​≤⋯≤rm​，则答案为min⁡{min⁡i=1m−1(ri−li+1),L−l1,rm−R}\\min\\{\\min_{i=1}^{m-1}(r_i-l_{i+1}),L-l_1,r_m-R\\}min{mini=1m−1​(ri​−li+1​),L−l1​,rm​−R}。开一个set维护[li,ri][l_i,r_i][li​,ri​]和一个multiset维护(ri−li+1)(r_i-l_{i+1})(ri​−li+1​)。每次插入一个区间[ai,bi][a_i,b_i][ai​,bi​]时先检查set中是否存在[lj,rj][l_j,r_j][lj​,rj​]包含了[ai,bi][a_i,b_i][ai​,bi​]，若有则不用修改，否则再将所有被[ai,bi][a_i,b_i][ai​,bi​]包含的[lj,rj][l_j,r_j][lj​,rj​]从set中删除，最后类似于链表的插入，将[ai,bi][a_i,b_i][ai​,bi​]插入到set中，同时删除和插入时需要同步更新multiset中的答案集合。由于每个区间只会插入和删除一次，所以时间复杂度为O(n×log⁡2n)\\mathcal{O}(n\\times\\log_2n)O(n×log2​n)。实际上要跑1s左右，STL常数较大，但比较好写。Submission","link":"https://yaohaoyou.github.io/post/AT_arc187_d-solution/"},{"title":"CP duels记录","content":"CF1368ESkiAccidents比较神的构造，被对手10min秒了。看到47\\frac4774​和outi≤2out_i\\le2outi​≤2，然后就应该想到47=2220+21+22\\frac47=\\frac{2^2}{2^0+2^1+2^2}74​=20+21+2222​，尝试将nnn划分为333个集合。感觉比较结论，所以直接说了。将nnn划分成333个无交且并为全集的集合A,B,CA,B,CA,B,C，满足∀a∈A,{∀u→a,u∈C}\\foralla\\inA,\\{\\forallu\\rarra,u\\inC\\}∀a∈A,{∀u→a,u∈C}∀b∈B,{∃u→b,u∈A},{∃u→b,u∈B}\\forallb\\inB,\\{\\existu\\rarrb,u\\inA\\},\\{\\not\\existu\\rarrb,u\\inB\\}∀b∈B,{∃u→b,u∈A},{​∃u→b,u∈B}∀c∈C,{∃u→c,u∈B}\\forallc\\inC,\\{\\existu\\rarrc,u\\inB\\}∀c∈C,{∃u→c,u∈B}分类讨论一下，不难发现A,B,CA,B,CA,B,C交且并为全集。由于∀b∈B,∃a→b\\forallb\\inB,\\exista\\rarrb∀b∈B,∃a→b，∣B∣≤2∣A∣|B|\\le2|A|∣B∣≤2∣A∣，同理，∣B∣≤2∣C∣|B|\\le2|C|∣B∣≤2∣C∣，即4∣A∣≥2∣B∣≥∣C∣4|A|\\ge2|B|\\ge|C|4∣A∣≥2∣B∣≥∣C∣，∣C∣≤47n|C|\\le\\frac47n∣C∣≤74​n。删除CCC中的所有点后AAA的入度都是000，BBB的出度都是000，故最多只有a→ba\\rarrba→b的边，满足条件。因为是DAG，分集合时可以做拓扑排序。复杂度线性。","link":"https://yaohaoyou.github.io/post/cp-duels/"},{"title":"P10743 AND = OR 题解","content":"题目传送器更爽的阅读体验前言赛时想出的做法，结果过了一周才过，非常难写，常数还大，本文其实可以认为是做法的补充，只用到了一个性质。做法先分析一些性质。对于询问的区间[l,r][l,r][l,r]，将区间排序后，显然结果是一个前缀a1,a2...aka_1,a_2...a_ka1​,a2​...ak​的或和等于后缀ak+1,ak+2...ana_{k+1},a_{k+2}...a_nak+1​,ak+2​...an​的与和，因为或和的最小值为aka_kak​，与和的最大值为ak+1a_{k+1}ak+1​，ak≤ak+1a_k\\lea_{k+1}ak​≤ak+1​，所以两个部分一定可以不交，即形成一个前缀和后缀。设与和===或和=x=x=x。按位考虑，若xxx的第iii位为000，则分界点kkk满足[l,k][l,k][l,k]的第iii位都是000，且[k+1,r][k+1,r][k+1,r]中至少有一个000。若xxx的第iii位为111，则kkk满足[k+1,r][k+1,r][k+1,r]的第iii位都是111，[l,k][l,k][l,k]至少有一个111。第二条性质本质上就是说明，若第iii位为000，设第iii位的一个极长前缀[1,L][1,L][1,L]满足2，则k∈[1,L]k\\in[1,L]k∈[1,L]，若第iii为为111，设第iii位的一个极长后缀[R+1,n][R+1,n][R+1,n]满足2，则k∈[R+1,n]k\\in[R+1,n]k∈[R+1,n]。具体实现就是建一棵主席树，在主席树上二分得到满足以上要求的极长前缀和后缀，则最终的分界点kkk必然满足在每一位都在[1,Li][1,L_i][1,Li​]或[Ri+1,n][R_i+1,n][Ri​+1,n]区间中，即若满足∃k,k∈[1,Li]∪[Ri+1,n]\\existk,k\\in[1,L_i]\\cup[R_i+1,n]∃k,k∈[1,Li​]∪[Ri​+1,n]，则答案为YES，否则为NO。本质上就是对每个区间求交集。分析时间复杂度，对每一位做主席树上二分为O((q+n)×log⁡2V×log⁡2n)\\mathcal{O}((q+n)\\times\\log_2V\\times\\log_2n)O((q+n)×log2​V×log2​n)，求交集可以将每个区间先取反，再求并集是否为全集即可O(q×log⁡2V×log⁡2log⁡2V)\\mathcal{O}(q\\times\\log_2V\\times\\log_2\\log_2V)O(q×log2​V×log2​log2​V)。具体实现时，可以将询问离线，对每个位先求出qqq个询问的极长前后缀，最后求交集，这样可以将空间复杂度将为O(n×log⁡2n)\\mathcal{O}(n\\times\\log_2n)O(n×log2​n)，时间常数减小，再添加一些小剪枝就通过了。Code","link":"https://yaohaoyou.github.io/post/P10743-solution/"},{"title":"CF198E Gripping Story题解","content":"题目传送器更爽的阅读体验CF2400前言好题啊，但是为什么题解区没有单log做法。双倍经验做法首先不难想出O(n2)O(n^2)O(n2)的bfs做法。思考一个机械臂能抓住哪些新的机械臂，即dis(i)≤r∧mi≤pdis(i)\\ler\\landm_i\\lepdis(i)≤r∧mi​≤p的所有iii，这是一个较为明显的二维偏序，应该可以直接使用线段树套线段树优化建图解决（不知道会不会MLE）。回顾弹跳的Trick，对于一个点向一个坐标轴中的左下角矩阵连边，可以先使用排序后离线一维，再使用数据结构维护剩下一维。具体的，对每个机械臂按照mim_imi​排序，将dis(i)dis(i)dis(i)离散化后挂在线段树上。线段树上每个节点记录一个queue表示disidis_idisi​在当前区间的iii集合，由于提前按照mim_imi​排序了，所以当前队列中的mim_imi​是单调不减的。利用这一条性质就可以类似于双指针，每次队首加入bfs后退队，如果当前队首不满足mi≤pm_i\\lepmi​≤p则后面的必然也不满足。实现时queue的空间常数非常大，会直接MLE，可以使用vector并记录队头的位置。每个机械臂会在线段树中被加入O(log⁡2n)O(\\log_2n)O(log2​n)次，也只会被删除O(log⁡2n)O(\\log_2n)O(log2​n)次，所以时空复杂度都是O(n×log⁡2n)O(n\\times\\log_2n)O(n×log2​n)。ACCode","link":"https://yaohaoyou.github.io/post/CF198E-solution/"},{"title":"CSP2024 煤济","content":"更爽的阅读体验前言出分后再写邮寄是好习惯。Day0连续三天飞盘，爽完了。Day1上午打J，应该是最后一场了，弥补去年挂分的遗憾。初赛竟然AK了，直接尝试双AK（初赛+复赛）。T1会。T2会。T3会，上拍。T4不会。。我怎么不会？！#！@#！#！*&amp;@#%……@#rrr怎么这么小，不会有是分层图吧（怎么连续两年T4放分层图）。会了，写写写。写完，跑大样例，2s+。本地机子怎么这么慢！卡常，卡常。然后就卡了1.5h，比赛结束前15min卡过了，爽。出考场，lbw强完了，提前两小时AK，/bx/bx/bx。菇粉：100+100+100+100=400=smalljoker100+100+100+100=400=\\text{smalljoker}100+100+100+100=400=smalljoker。下午打S。早起拜锦鲤，rp++！开T1，会了！嗯？T1被秒了？CCF真是越来越会出题了。。。（伏笔）开T2，给一堆式子，这题充满单调性，第一问会了，上二分后求最少有多少个点被所有区间覆盖。这。。。思考一下很可做，AcSaber应该打过，但我都是贺的（后悔ing...）。然后就会了。写写写。卡卡卡。过大样例了，爽！稳一波，先写后面暴力，50+28拿下。这时还有1.5h左右，然后就迎来了全场最迷惑的操作。莫名其妙开始猜一波，T3超级困难，然后为了防止挂大分，然后就开始检查代码了？测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。然后还剩40min，继续无视T3的存在，开始拍T2。写写写，拍拍拍。然后比赛结束都没拍问题，比较爽了。出考场，lbw薄纱我，T3怎么被切爆了？？？（CCF真是越来越会出题了，呼应）简单提一嘴我就会了，我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。菇粉：100+100+50+28=278=bigjoker100+100+50+28=278=\\text{bigjoker}100+100+50+28=278=bigjoker。Day¿神秘途径获得J组的民间分数，怎么T4挂了第2个点，布什个门，CCF球球了。S组好像没有挂分。Day¿¿出分日。省流：13:00-&gt;16:00-&gt;17:30，CCF不愧是你。J：100+100+100+100=400=smalljoker100+100+100+100=400=\\text{smalljoker}100+100+100+100=400=smalljoker。双AK，双倍满足。S：100+100+50+28=278=bigjoker100+100+50+28=278=\\text{bigjoker}100+100+50+28=278=bigjoker。挂分了，但是CCF又挂回来了（不愧是你）。最后放一下S组T3的部分代码，多亏CCF神机，要不然就挂15pts了，我写的是O(n2)O(n^2)O(n2)，下面代码是O(n×maxn)O(n\\timesmaxn)O(n×maxn)的，不能写memset，要for循环清空。constintmaxn=2e5+10;lldp[2][maxn];for(inti=1;i&lt;=n;i++){mems(dp[i&amp;1],0);//DP转移}在线讨一手七级勾。","link":"https://yaohaoyou.github.io/post/csp2024/"},{"title":"P8180 「EZEC-11」Unmemorable 题解","content":"题目传送器更爽的阅读体验前言赛时会了，结果预处理忘优化了，大样例跑得飞快，O(n2)O(n^2)O(n2)假完甲烷了，喜提暴力分。题意自己看题面。做法先大眼暴力，观察结论（我也不会证明，但把表打出来后还比较明显）：rrr数组无用顺序正确的lll数组唯一先从大到小排序，对于当前值iii，放入第一个lj=0l_j=0lj​=0的位置，j&gt;ij&gt;ij&gt;i。形成最后的lll。对于第333点的观察，可以自己参考别的题解的做法，反正能确定lll数组即可。现在已经得到了lll数组了，rrr数组已经固定，有保证有解，所以算出多少个排列ppp满足lll的限制即可。其实做到这一步，就完全是这题了，接下来讲一讲具体的做法。对于当前数组能推出的信息很少，所以先从局部推结论。不难发现在当前lll数组中ppp最小的位置一定是当前最后一个li=0l_i=0li​=0的iii，证明可以设ak=min⁡i=1naia_k=\\min_{i=1}^na_iak​=mini=1n​ai​，因为是最小值，所以前面不会再有pk&lt;pip_k&lt;p_ipk​&lt;pi​，故lkl_klk​一定是000，最后一个lk=0l_k=0lk​=0一定会满足前面的∀lj=0,pk&lt;pj\\foralll_j=0,p_k&lt;p_j∀lj​=0,pk​&lt;pj​。推出当前序列的最小值后，序列就又分成了两个独立的区间，因为保证有解，所以∀j&gt;k,pj≥k\\forallj&gt;k,p_j\\gek∀j&gt;k,pj​≥k，将i∈[k+1,n]i\\in[k+1,n]i∈[k+1,n]的li←li−kl_i\\getsl_i-kli​←li​−k后，后面的部分就与前面独立了。接下来就类似于分治的做法，将当前区间分成两段，递归求解。设当前区间为[L,R][L,R][L,R]，这个区间的最小值已经确定，从剩下的R−LR-LR−L个数中选取k−Lk-Lk−L个数作为左边区间，剩下就是右边区间，所以要再乘上(R−Lk−L)\\binom{R-L}{k-L}(k−LR−L​)。形式化的，设f(L,R)f(L,R)f(L,R)为区间[L,R][L,R][L,R]的分配方案数（数的集合已经固定，相当于离散化后的方案数）。f(L,R)={1L&gt;Rf(L,k−1)×f(k+1,R)×(R−Lk−L)L&lt;=Rf(L,R)=\\begin{cases}1&amp;L&gt;R\\\\f(L,k-1)\\timesf(k+1,R)\\times\\binom{R-L}{k-L}&amp;L&lt;=R\\end{cases}f(L,R)={1f(L,k−1)×f(k+1,R)×(k−LR−L​)​L&gt;RL&lt;=R​想到这里就完成了，实现并不难。注意lkl_klk​是区间最小值，但并不一定是midmidmid，所以直接做不是O(n×log⁡2n)O(n\\times\\log_2n)O(n×log2​n)的，而是卡不满的O(n2)O(n^2)O(n2)。可以使用st表或线段树做rmq。本题空间要求线性，于是只能使用线段树，复杂度为O(n×log⁡2n)O(n\\times\\log_2n)O(n×log2​n)。Code递归求fff的主要代码如下：voiddfs(intl,intr){if(l&gt;r)return;intx=-query(all,l,r).se;//区间最小值的位置mmul(ans,C(r-l,x-l));dfs(l,x-1);dfs(x+1,r);}完整代码","link":"https://yaohaoyou.github.io/post/P8180-solution/"},{"title":"AtCoder 做题记录","content":"\\def\\OO{\\mathcalO}\\def\\opn#1{\\operatorname{#1}}\\def\\dia{\\Large\\color{red}\\Diamond}AtCoderRegularContest186AmodMGame2Difficulty：1042唐完了，不会做打表（大便）题，1≤n×(n−1)2modm≤n1\\le\\frac{n\\times(n-1)}2\\modm\\len1≤2n×(n−1)​modm≤n时Bob，否则Alice。B+1and-1Difficulty：1332我都能场最后数列的状态固定，从前往后模拟，前面有多的就留个tag。EAdjacentGCDDifficulty：2185欧拉函数，数论欧拉函数反演n=∑d∣nφ(d)gcd⁡(a,b)=∑d∣gcd⁡(a,b)φ(d)=∑d∣a∧d∣bφ(d)n=\\sum_{d|n}\\varphi(d)\\\\\\gcd(a,b)=\\sum_{d|\\gcd(a,b)}\\varphi(d)=\\sum_{d|a\\wedged|b}\\varphi(d)n=d∣n∑​φ(d)gcd(a,b)=d∣gcd(a,b)∑​φ(d)=d∣a∧d∣b∑​φ(d)对于本题，每次加入一个aia_iai​后，新增ans+∑j=1i−1gcd⁡(aj,ai)×2j−1ans+\\sum_{j=1}^{i-1}\\gcd(a_j,a_i)\\times2^{j-1}ans+∑j=1i−1​gcd(aj​,ai​)×2j−1的贡献。由于gcd⁡\\gcdgcd的其中一项确定，则可以枚举aia_iai​的因数ddd，添加sumd×φ(d)sum_d\\times\\varphi(d)sumd​×φ(d)的贡献。最后对于每个因数ddd，sumd+=2i−1sum_d+=2^{i-1}sumd​+=2i−1即可。DRandomWalkonTreeDifficulty：2649推式子，期望就是走完nnn条长度为mmm的链。走完一条链的充要条件是走到叶子节点，钦定dep0=0dep_0=0dep0​=0。定义有效点为之前没别走过的点。fif_ifi​表示从深度为iii的有效点走到i+1i+1i+1的有效点期望步数。fi=12+1+fi−1+fi2fi=2+fi−1f_{i}=\\frac12+\\frac{1+f_{i-1}+f_{i}}2\\\\f_i=2+f_{i-1}fi​=21​+21+fi−1​+fi​​fi​=2+fi−1​即有12\\frac1221​的概率直接走到，和先往i−1i-1i−1走再走回来，再到i+1i+1i+1的步数期望。初始化f0f_0f0​与当前有多少条已经走完的链相关，并且如果走到了无效点还要走回来。设可以走到的有效点数为kkk，pip_ipi​表示从深度为iii的点走到i−1i-1i−1的步数期望。ppp实际上在链上走的情况和fff相同，故pi=2+pi+1p_i=2+p_{i+1}pi​=2+pi+1​，初始化pm=1p_m=1pm​=1。f0=kn+(1−kn)×(1+p1+f0)f0=n+(n−k)×p1if_0=\\frac{k}{n}+(1-\\frac{k}{n})\\times(1+p_1+f_0)\\\\f_0=\\frac{n+(n-k)\\timesp_1}if0​=nk​+(1−nk​)×(1+p1​+f0​)f0​=in+(n−k)×p1​​先计算从n−1n-1n−1个叶子回到000号点的贡献，即为(n−1)×∑i=1mpi(n-1)\\times\\sum_{i=1}^mp_i(n−1)×∑i=1m​pi​。再计算从000号点到dep=1dep=1dep=1的有效点后再到叶子节点的贡献和，即为∑i=1n∑j=1mfj\\sum_{i=1}^n\\sum_{j=1}^mf_j∑i=1n​∑j=1m​fj​，时间复杂度为O(n2)O(n^2)O(n2)（注：每次fjf_jfj​都需要重新计算，因为f0f_0f0​的值会变）。观察到fi=2+fi−1f_i=2+f_{i-1}fi​=2+fi−1​的式子非常简单，甚至是等差数列，可以得到通项公式fi=f0+2×(i−1)f_i=f_0+2\\times(i-1)fi​=f0​+2×(i−1)，故∑i=1mfi=∑i=1m(f0+2×(i−1))=m×f0+m×(m−1)\\sum_{i=1}^mf_i=\\sum_{i=1}^m(f_0+2\\times(i-1))=m\\timesf_0+m\\times(m-1)i=1∑m​fi​=i=1∑m​(f0​+2×(i−1))=m×f0​+m×(m−1)优化后就可以O(1)O(1)O(1)求出f0f_0f0​和∑fi\\sumf_i∑fi​了，复杂度为O(nlog⁡2n)O(n\\log_2n)O(nlog2​n)，使用预处理逆元做到O(n)O(n)O(n)，但是我懒了。Codep[m]=1;for(inti=m-1;i;i--)p[i]=imadd(p[i+1],2);intinvn=qpow(n,mod-2);intans=0,sum=0;for(inti=1;i&lt;=m;i++)madd(ans,p[i]);mmul(ans,n-1);for(inti=1;i&lt;=n;i++){intf0=immul(imadd(n,immul(n-i,p[1])),qpow(i,mod-2));madd(ans,immul(m,f0));madd(ans,immul(m,m-1));}AtCoderRegularContest186BTypicalPermutationDescriptorDifficulty：1677赛时差一点写完的计数，唐不难得出当前序列中ppp最小的数的位置，然后从这一点断开后形成两个新区间，两个区间相互独立，只要×(r−lp−l)\\times\\binom{r-l}{p-l}×(p−lr−l​)将数划分到两个区间即可。CBallandBoxDifficulty：2451贪心，博弈按容量从小到大排序，相同容量花费从大到小。最后的状态一定形如ViV_iVi​最大的m−1m-1m−1个会只获得111的贡献，剩余获得ViV_iVi​的贡献，即s=∑i=1k−m+1Vi+m−1−∑i=1kPis=\\sum_{i=1}^{k-m+1}V_i+m-1-\\sum_{i=1}^kP_is=∑i=1k−m+1​Vi​+m−1−∑i=1k​Pi​。对后缀用大根堆维护最小的m−1m-1m−1个ViV_iVi​作为所选的数中最大的m−1m-1m−1个，剩余的选取所有[1,i−1][1,i-1][1,i−1]中(Vi−Pi)(V_i-P_i)(Vi​−Pi​)为正的，求和即可。AUndercluedDifficulty：2511性质，转化好困难。看到01矩阵，尝试给二分图定向。当ai,j=0a_{i,j}=0ai,j​=0时，Li↔RjL_i\\leftrightarrowR_jLi​↔Rj​，当ai,j=1a_{i,j}=1ai,j​=1时，Ri↔LjR_i\\leftrightarrowL_jRi​↔Lj​，则两个矩阵相似即为对于每个点在两个图中的出入度相同。原矩阵上(i,j)(i,j)(i,j)是不动点，当且仅当在二分图中改变图的形态但出入度不变时，上面连的边不变。考虑变一条边的方向后，会继续影响别的点，知道绕回原点，即形成一个简单环后才会结束，则不动点即为二分图上不在简单环上的边。转化后就不困难了，设dpi,j,kdp_{i,j,k}dpi,j,k​表示左部点前iii个点和右部点前jjj个点，形成的环能否覆盖恰好kkk条边。枚举左部点新加uuu个点，右部点新加vvv个点，且这些点形成一个强连通分量。新覆盖成了u×vu\\timesvu×v条边，即uuu个左部点都会和vvv个右部点的连边一一被覆盖。因为是可行性dp，转移可以用bitset，时间复杂度降为O(n6ω)\\mathcalO(\\frac{n^6}\\omega)O(ωn6​)，但不用也能过。AtCoderRegularContest187DManyEasyOptimizationsDifficulty：2880hereAtCoderRegularContest197DAncestorRelationDifficulty：2062性质111作为根，将Ai,1A_{i,1}Ai,1​取出后剩下的AAA会被分成几个相同的集合，对于Aa1=Aa2=...=AakA_{a_1}=A_{a_2}=...=A_{a_k}Aa1​​=Aa2​​=...=Aak​​的集合，使答案×k!\\timesk!×k!，因为这kkk个点形成一条链，可以随意排列。每次由uuu跑出在祖先-孙子关系图上的可达点作为集合递归，若该集合SSS有几个点rtrtrt满足rtrtrt直接到达SSS的所有点则为根，否则无解。AtCoderRegularContest198DManyPalindromesonTreeDifficulty：2299构造按照给定的矩阵构造出一个满足的带边权树再算答案即可。暴力做就是若Au,v=1A_{u,v}=1Au,v​=1，预处理nxu,vnx_{u,v}nxu,v​表示从uuu走到vvv的下一步到达的点，暴力从uuu走到vvv，将相等的两个位置在并查集合并，复杂度为O(N3α(N))O(N^3\\alpha(N))O(N3α(N))。思考到中途会重复走过很多路，所以考虑标记(u,v)(u,v)(u,v)对是否走过。若当前的点(x,y)(x,y)(x,y)标记过，就可以直接break，由于状态数只有O(N2)O(N^2)O(N2)，所以复杂度也是O(N2)O(N^2)O(N2)。最后求答案可以将所有二元组按之间的距离从小到大排序，ansu,v=ansnxu,v,nxv,u∨(find(u)=find(v))ans_{u,v}=ans_{nx_{u,v},nx_{v,u}}\\vee(find(u)=find(v))ansu,v​=ansnxu,v​,nxv,u​​∨(find(u)=find(v))，复杂度为O(N2α(N))O(N^2\\alpha(N))O(N2α(N))。AtCoderRegularContest200Epopcount&lt;=2Difficulty：2299分类讨论将得到的AAA序列全部异或xxx后依旧满足情况，所以不妨将AAA异或A1A_1A1​后使A1=0A_1=0A1​=0。直接钦定A1=0A_1=0A1​=0，最后将答案×2m\\times2^m×2m即可。◊\\Large{\\color{red}\\Diamond}◊由于A1=0A_1=0A1​=0，popcount(A1⊕Ai)≤2popcount(A_1\\oplusA_i)\\le2popcount(A1​⊕Ai​)≤2，所以popcount(Ai)≤2popcount(A_i)\\le2popcount(Ai​)≤2。接下来分情况讨论。popcount(Ai)≤1popcount(A_i)\\le1popcount(Ai​)≤1，没有其他限制了，方案数为(m+1)n−1(m+1)^{n-1}(m+1)n−1。有且仅有一种popcount(Ax)=2popcount(A_x)=2popcount(Ax​)=2，方案数为(m2)(4n−1−3n−1)\\binomm2(4^{n-1}-3^{n-1})(2m​)(4n−1−3n−1)。有多种popcount(Aa1,Aa2,..Aak)=2popcount(A_{a_1},A_{a_2},..A_{a_k})=2popcount(Aa1​​,Aa2​​,..Aak​​)=2，且popcount(Aa1&amp;Aa2&amp;..&amp;Aak)=1,k≥2popcount(A_{a_1}\\AndA_{a_2}\\And..\\AndA_{a_k})=1,k\\ge2popcount(Aa1​​&amp;Aa2​​&amp;..&amp;Aak​​)=1,k≥2，方案数为m((m+1)n−1−2n−1−(m−1)(3n−1−2n−1))m((m+1)^{n-1}-2^{n-1}-(m-1)(3^{n-1}-2^{n-1}))m((m+1)n−1−2n−1−(m−1)(3n−1−2n−1))。有且仅有三种popcount(Ax,Ay,Az)=2popcount(A_x,A_y,A_z)=2popcount(Ax​,Ay​,Az​)=2，此时只能有这三种数和000出现，并且两两交的popcount都为111，如{Ax,Ay,Az}={3,5,6}\\{A_x,A_y,A_z\\}=\\{3,5,6\\}{Ax​,Ay​,Az​}={3,5,6}。方案数为(m3)(4n−1−3×3n−1+3×2n−1−1)\\binomm3(4^{n-1}-3\\times3^{n-1}+3\\times2^{n-1}-1)(3m​)(4n−1−3×3n−1+3×2n−1−1)。AtCoderRegularContest201BBinaryKnapsackDifficulty:1808贪心因为WWW很大，所以不能是01背包的思路，应该想贪心。思考偏序关系，由于不同重量只有log⁡2W\\log_2Wlog2​W种，并且两个2x−12^{x-1}2x−1可以直接合并成2x2^x2x，所以每次贪心取当前重量价值最大的一定更优。对WWW进行二进制拆位，从小到大，若当前第iii位为111，则选一个重量为2i2^i2i的一定不劣。◊\\Large{\\color{red}\\Diamond}◊剩下的排序后两两合并成重量为2i+12^{i+1}2i+1的物品，继续递归子问题。AtCoderGrandContest073AChordsandCheckeredDifficulty:2219数学由于2K&lt;L2K&lt;L2K&lt;L，所以每条弦围出的图形一定都不会包含圆心，所以初始一定为黑色，而当有一条新的弦交到这条弦时，会将这块图形分成新的两个部分，所以令与当前弦相交的弦的条数为xxx，则会贡献⌈x+12⌉\\lceil\\frac{x+1}{2}\\rceil⌈2x+1​⌉。使用双指针求出能与当前弦的相交的弦的条数为mmm，则这条弦的贡献为2n−m∑i=0m(mi)⌈i+12⌉∑i=0m(mi)⌈i2⌉=∑i=0m(mi)i+2−imod22=12(∑i=0m(mi)i+2∑i=0m(mi)+∑i=0m(mi)(imod2))∑i=0m(mi)i=∑i=1mm!i!(m−i)!i=m∑i=1m(m−1)!(i−1)!(m−i)!=m∑i=1m(m−1i−1)=m2m−12∑i=0m(mi)=2m+12^{n-m}\\sum_{i=0}^m\\binom{m}{i}\\lceil\\frac{i+1}2\\rceil\\\\\\sum_{i=0}^m\\binommi\\lceil\\fraci2\\rceil=\\sum_{i=0}^m\\binommi\\frac{i+2-i\\bmod2}2\\\\=\\frac12(\\sum_{i=0}^m\\binommii+2\\sum_{i=0}^m\\binommi+\\sum_{i=0}^m\\binommi(i\\bmod2))\\\\\\sum_{i=0}^m\\binommii=\\sum_{i=1}^m\\frac{m!}{i!(m-i)!}i=m\\sum_{i=1}^m\\frac{(m-1)!}{(i-1)!(m-i)!}=m\\sum_{i=1}^m\\binom{m-1}{i-1}=m2^{m-1}\\\\2\\sum_{i=0}^m\\binommi=2^{m+1}2n−mi=0∑m​(im​)⌈2i+1​⌉i=0∑m​(im​)⌈2i​⌉=i=0∑m​(im​)2i+2−imod2​=21​(i=0∑m​(im​)i+2i=0∑m​(im​)+i=0∑m​(im​)(imod2))i=0∑m​(im​)i=i=1∑m​i!(m−i)!m!​i=mi=1∑m​(i−1)!(m−i)!(m−1)!​=mi=1∑m​(i−1m−1​)=m2m−12i=0∑m​(im​)=2m+1∑i=0m(mi)(imod2)\\sum_{i=0}^m\\binommi(i\\bmod2)∑i=0m​(im​)(imod2)的意义为大小为奇数的集合的个数，前m−1m-1m−1个选不选都可以，最后一个数要满足集合大小为奇数的限制，所以方案数为2m−12^{m-1}2m−1。综上，一条弦的贡献为2n−m−1×((m+3)2m−2)2^{n-m-1}\\times((m+3)2^{m-2})2n−m−1×((m+3)2m−2)，m=0/1m=0/1m=0/1时特判一下即可。总复杂度为O(n)\\mathcalO(n)O(n)。AtCoderRegularContest213(Div.1)CDoubleXDifficulty:3241图论，数据结构没想到我还会更新这个md。显然x1,x2,x3,x4x_1,x_2,x_3,x_4x1​,x2​,x3​,x4​满足在以kkk为根的TTT和UUU中两两之间的LCA都是kkk，这其实是一个类似于二分图匹配的问题。具体的，可以将这个问题转化成对于kkk在TTT上的儿子a1,a2,…,adegTka_1,a_2,\\dots,a_{degT_k}a1​,a2​,…,adegTk​​，和在UUU上的儿子b1,b2,…,bdegUkb_1,b_2,\\dots,b_{degU_{k}}b1​,b2​,…,bdegUk​​之间，若一个点xxx在aia_iai​和bjb_jbj​的子树中，则连接一条(i,j,Ax)(i,j,A_x)(i,j,Ax​)的边，代表一对匹配\\dia。这一步转化后，现在只需要求这个二分图中找到大小为4的最小匹配。由于二分图两边点数的总和只有degTk+degUkdegT_k+degU_kdegTk​+degUk​，所以可以对每个kkk考虑\\tilde\\OO(degT_k+degU_k)解决这个问题，总复杂度就只有\\tilde\\OO(\\sumn)。首先显然重边只用保留边权最小的一条。其次事实上，只要对每个左部点保留边权前4小的边也不会影响答案。证明考虑若选择了第5小的边，则剩余的3组匹配一定无法完全包含前4小的边的右端点，所以可以将第5小的边调整到没选的前4小的边一定不劣。所以每个左部点直接保留前4小的边即可，总边数就缩到\\OO(degT_k+degU_k)级别了。由于流量flow=4flow=4flow=4很小，直接用费用流跑匹配，使用Primal-Dual能做到\\OO(n\\logn)，实测直接SSP也能过。现在思考如何建出这个图，即考虑如何快速求出以kkk为根时，在axa_xax​子树中前4小的不相同的边。考虑在UUU中将bib_ibi​的子树内的点vvv在TTT中染色成iii，则需要在TTT中找axa_xax​的子树中4种颜色的点的最小值。注意到我们实际上不可能每次吧kkk提出来做根跑dfs，但是可以将kkk的邻域分为kkk的父亲和kkk的儿子，kkk的父亲对应的子树直接全部染色成0，每次换根时就只会修改一个位置了，剩下的儿子子树的染色过程可以在UUU上用dsuontree在\\OO(n\\logn)做完。再开一棵线段树维护当前节点对应的TTT上欧拉序区间的最小的4种颜色和权值，在TTT上做线段树区间查即可，总复杂度为\\OO(n\\log^2n+Flow(n))，Flow(n)Flow(n)Flow(n)为边数为nnn的费用流的复杂度。注意最短路要开longlong，虽然最后的增广最短路只会有2×1092\\times10^92×109，但过程中可能需要经过的最短路会&lt;−2×109&lt;-2\\times10^9&lt;−2×109。code","link":"https://yaohaoyou.github.io/post/atcoder-solution/"},{"title":"光速幂学习笔记","content":"多次询问axmodpa^x\\bmodpaxmodp。选定一个数BBB，预处理出aimodp,i∈[0,B)a^i\\bmodp,i\\in[0,B)aimodp,i∈[0,B)和ai×Bmodp,i∈[1,(p−1)B)a^{i\\timesB}\\bmodp,i\\in[1,\\frac{(p-1)}B)ai×Bmodp,i∈[1,B(p−1)​)，询问时axmodp=a⌊xB⌋×axmodBmodpa^x\\bmodp=a^{\\lfloor\\fracxB\\rfloor}\\timesa^{x\\bmodB}\\bmodpaxmodp=a⌊Bx​⌋×axmodBmodp，取B=pB=\\sqrtpB=p​时可以做到O(p)−O(1)O(\\sqrtp)-O(1)O(p​)−O(1)快速幂。然而O(p)O(\\sqrtp)O(p​)可能还是太慢了，实际上可以做到取一个BBB，复杂度为O(log⁡Bp×B)−O(log⁡Bp)O(\\log_Bp\\timesB)-O(\\log_Bp)O(logB​p×B)−O(logB​p)，后面的log⁡Bp\\log_BplogB​p基本就只是常数了，可以按需求平衡复杂度，其实不太好理解，下面放一份B=32B=32B=32的代码，这应该是比较优的块长了，常数较小。inlinevoidinit(intx){Pow[0][0]=Pow[1][0]=Pow[2][0]=Pow[3][0]=Pow[4][0]=Pow[5][0]=1;for(inti=1;i&lt;S;i++)Pow[0][i]=Pow[0][i-1]*x%mod;intb=immul(Pow[0][S-1],x);for(inti=1;i&lt;S;i++)Pow[1][i]=Pow[1][i-1]*b%mod;b=immul(Pow[1][S-1],b);for(inti=1;i&lt;S;i++)Pow[2][i]=Pow[2][i-1]*b%mod;b=immul(Pow[2][S-1],b);for(inti=1;i&lt;S;i++)Pow[3][i]=Pow[3][i-1]*b%mod;b=immul(Pow[3][S-1],b);for(inti=1;i&lt;S;i++)Pow[4][i]=Pow[4][i-1]*b%mod;b=immul(Pow[4][S-1],b);for(inti=1;i&lt;S;i++)Pow[5][i]=Pow[5][i-1]*b%mod;}inlineintqpow(inty){returnPow[5][(y&gt;&gt;25)]*Pow[4][(y&gt;&gt;20)&amp;(S-1)]%mod*Pow[3][(y&gt;&gt;15)&amp;(S-1)]%mod*Pow[2][(y&gt;&gt;10)&amp;(S-1)]%mod*Pow[1][(y&gt;&gt;5)&amp;(S-1)]%mod*Pow[0][y&amp;(S-1)]%mod;}}POW;实测尽量添加#pragmaunroll(4)实现并行，Pow可以开longlong避免多次int强转。完整代码","link":"https://yaohaoyou.github.io/post/FastPow/"},{"title":"CF1995D Cases 题解","content":"题目传送器更爽的阅读体验CF2300前言我菜了，不会SOSDP，是学习其他题解的做法。题意自己去看翻译。做法SOSDP好题。因为每个子串长度不超过kkk，所以每kkk个位就会有至少一个位是子串的末尾，共有n−k+1n-k+1n−k+1个这样的区间，所以充要条件就是末尾字符构成的集合与n−k−1n-k-1n−k−1个区间构成的集合都有交。形象化来说，Si={c∣c∈s[i,i+k−1]}S_i=\\{c|c\\ins[i,i+k-1]\\}Si​={c∣c∈s[i,i+k−1]}，TTT为每个子串末尾字符组成的集合，∀Si,Si∩T=∅\\forallS_i,S_i\\capT\\not=\\empty∀Si​,Si​∩T​=∅，求∣T∣min⁡|T|_{\\min}∣T∣min​。考虑SOSDP，先预处理出每个SiS_iSi​，再使用子集DP转移。由于要记录当前状态是否与SiS_iSi​有交，时间和空间复杂度均为为O(2c×n)O(2^c\\timesn)O(2c×n)，即使用bitset优化，空间依旧开不下，所以考虑正难则反。上述方法空间较大的主要原因是难以维护当前状态与哪些SiS_iSi​有交，因为这个状态就已经是O(n)O(n)O(n)的。考虑维护当前状态是否与任意一个SiS_iSi​都无交，对于每个状态就只要O(1)O(1)O(1)的空间了，对于和每个SiS_iSi​都不是无交的状态，即和每个SiS_iSi​都有交的状态，就可以成为TTT。具体实现就是预处理出stai={c∣c∉[s,i,i+k−1}sta_i=\\{c|c\\notin[s,i,i+k-1\\}stai​={c∣c∈/​[s,i,i+k−1}，则staista_istai​的任意一个子集都与sis_isi​无交，暴力枚举子集需要O(3c)O(3^c)O(3c)，使用SOSDP转移将复杂度将为O(c×2c)O(c\\times2^c)O(c×2c)，到最后dp值为000的状态就代表与任意sis_isi​都有交，可以成为∣T∣|T|∣T∣，更新答案即可。ACCode","link":"https://yaohaoyou.github.io/post/CF1995D-solution/"},{"title":"P4593 [TJOI2018] 教科书般的亵渎 题解","content":"题目传送器更爽的阅读体验前言太笨了，不会拆贡献，所以复杂度比较劣。题意给定操作A和操作B。定义操作A是将xi←xi−1(xi&gt;0)x_i\\getsx_i-1(x_i&gt;0)xi​←xi​−1(xi​&gt;0)并获得∑xik\\sumx_i^k∑xik​分数，xix_ixi​是第iii个怪物扣血前的血量，kkk是总操作B次数。如果一次操作后会有新的xi=0x_i=0xi​=0，则继续进行操作A。定义操作B是当此时没有新的xi=0x_i=0xi​=0，进行一次操作A。给定集合S={x∈[1,n]∧x∉a}S=\\{x\\in[1,n]\\wedgex\\notina\\}S={x∈[1,n]∧x∈/​a}表示怪物血量所构成的集合，求最后的总分数。做法kkk是好算的。将SSS拆成一段段连续的区间分别考虑，一段连续的区间必定是在同一次操作B中扣为000。设当前处理的血量区间为[li,ri][l_i,r_i][li​,ri​]，对于j≥ij\\geij≥i的区间当前血量为[lj,rj][l_j,r_j][lj​,rj​]，则当前的贡献∑j=im+1∑x=ljrj∑y=x−li+1xyk\\sum_{j=i}^{m+1}\\sum_{x=l_j}^{r_j}\\sum_{y=x-l_i+1}^{x}y^k∑j=im+1​∑x=lj​rj​​∑y=x−li​+1x​yk。直接计算是O(Tm2n2)O(Tm^2n^2)O(Tm2n2)，这里放一份代码。思考如何优化计算∑x=ljrj∑y=x−li+1xyk\\sum_{x=l_j}^{r_j}\\sum_{y=x-l_i+1}^{x}y^k∑x=lj​rj​​∑y=x−li​+1x​yk，设f(x)=∑i=1xix,g(x,len)=∑i=1x(f(i)−f(i−len))f(x)=\\sum_{i=1}^xi^x,g(x,len)=\\sum_{i=1}^x(f(i)-f(i-len))f(x)=∑i=1x​ix,g(x,len)=∑i=1x​(f(i)−f(i−len))，则ans=∑i=1m+1∑j=im+1g(rj,li)−g(lj−1,li)ans=\\sum_{i=1}^{m+1}\\sum_{j=i}^{m+1}g(r_j,l_i)-g(l_j-1,l_i)ans=∑i=1m+1​∑j=im+1​g(rj​,li​)−g(lj​−1,li​)。可以先使用一次拉格朗日插值O(m)O(m)O(m)算出f(x)f(x)f(x)，进而再使用一次拉格朗日插值O(m2)O(m^2)O(m2)算出g(x)g(x)g(x)。总时间复杂度为O(T×m4)O(T\\timesm^4)O(T×m4)，需要轻微卡常。ACCode","link":"https://yaohaoyou.github.io/post/p4593-solution/"},{"title":"2024.8.12 树专题分享","content":"T1原题：CF1399E2WeightsDivision(hardversion)\\color{#ffffff}\\text{CF1399E2WeightsDivision(hardversion)}CF1399E2WeightsDivision(hardversion)CF2200\\color{#ffffff}\\text{CF2200}CF2200题意给你一棵以111为根的香蕉树，每条边有边权wiw_iwi​和花费cic_ici​。每个叶子节点都有一只liangbowen，他们都想去111节点吃香蕉。但是liangbowen们急着去杀戮，所以需要保证∑uisliangbowenw(1,u)≤lim\\sum_\\text{uisliangbowen}w(1,u)\\lelim∑uisliangbowen​w(1,u)≤lim，uisliangbowen\\text{uisliangbowen}uisliangbowen当且仅当uuu是叶子节点，w(x,y)w(x,y)w(x,y)表示xxx到yyy的树上距离。lubenwei可以开挂，将wi←⌊wi2⌋w_i\\gets\\lfloor\\dfrac{w_i}{2}\\rfloorwi​←⌊2wi​​⌋，吸引网管cic_ici​点注意。lubenwei不希望开挂太多导致被网管封号，所以请最小化网管的注意使得liangbowen们可以准时杀戮，保证有解。n≤105,ci∈{1,2},1≤wi≤106,1≤lim≤1016n\\le10^5,c_i\\in\\{1,2\\},1\\lew_i\\le10^6,1\\lelim\\le10^{16}n≤105,ci​∈{1,2},1≤wi​≤106,1≤lim≤1016。形式化题意：\\tiny\\text{形式化题意：}形式化题意：给出一个结点数量为nnn的边带权的有根树，树的根结点为111。你可以进行以下操作。选定任意一条权值为wiw_iwi​的边，使wi←⌊wi2⌋w_i\\gets\\lfloor\\frac{w_i}{2}\\rfloorwi​←⌊2wi​​⌋，花费为cic_ici​且ci∈{1,2}c_i\\in\\{1,2\\}ci​∈{1,2}。你需要回答最小的花费，使得∑v∈leavesw(1,v)≤S\\sum\\limits_{v\\inleaves}w(1,v)\\leqSv∈leaves∑​w(1,v)≤S。EasyVersion：ci=1c_i=1ci​=1。题解先考虑EasyVersion，由于保证ci=1c_i=1ci​=1，所以直接贪心即可。首先可以用树形DP求出删掉当前边的贡献，设dpidp_idpi​表示iii的子树中有多少个叶子节点，不难得出dpu={∑dpsonu≠leaf1u=leafdp_u=\\begin{cases}\\sumdp_{son}&amp;u\\neleaf\\\\1&amp;u=leaf\\end{cases}dpu​={∑dpson​1​u​=leafu=leaf​。设一条边的贡献为sis_isi​，儿子为vvv，则si=dpv×(wi−⌊wi2⌋)s_i=dp_v\\times(w_i-\\lfloor\\frac{w_i}{2}\\rfloor)si​=dpv​×(wi​−⌊2wi​​⌋)。将sis_isi​丢进大根堆，每次取出sis_isi​最大的边模拟进行操作即可。再回到HardVersion。错的做法此时还想贪心就变得非常困难，所以可以思考将答案划分成选择边权花费为111的答案+++选择边权花费为222的答案。当只选择边权花费为111的答案时，可以确定操作的顺序（即EasyVersion），同理，只选择边权花费为222的答案也可以提前处理操作顺序。然后只要枚举要操作花费为111的次数，并计算花费为222的次数即可。此时的时间复杂度为O(n2×log⁡2n)O(n^2\\times\\log_2n)O(n2×log2​n)，无法通过此题。观察性质，发现操作花费为111的次数越多，操作花费为222的次数就越少。所以可以将计算花费为222的次数用双指针优化掉，时间复杂度为O(n×log⁡2n)O(n\\times\\log_2n)O(n×log2​n)，记得处理操作全是花费为111和222的答案。code\\color{white}codecodeT2原题：CF1059ESplittheTree\\color{#ffffff}\\text{CF1059ESplittheTree}CF1059ESplittheTreeCF2400\\color{#ffffff}\\text{CF2400}CF2400题意lbw和Mathew正在宿舍打21点，但是他把牌摆成了一棵树的形状。规则就是在树上找一条深度依次递增的链，使得链上扑克牌的点数和≤21\\le21≤21。同时还有一种规则叫做五龙，就是当你取得555张牌时，游戏就结束了。但是lbw想要练习出千，于是把21点变成LLL点，把555龙变成SSS龙，把扑克牌点数的集合变成自然数集。lbw有透视眼，可以提前看到每个节点的牌的点。lbw用最短的时间秒杀Mathew，所以希望总局数最少。请求lbw最少选出多少条链可以使得每张牌刚好被拿走一次，且牌数≤L\\leL≤L，点数和≤S\\leS≤S，需要判无解。n≤105,L≤105,S≤1018n\\le10^5,L\\le10^5,S\\le10^{18}n≤105,L≤105,S≤1018。形式化题意：\\tiny\\text{形式化题意：}形式化题意：给一棵带点权的树，每次选一条深度依次递增的链，链长≤L\\leL≤L，链上点权和≤S\\leS≤S。想让每个点当且仅当被覆盖一次，求链数最小值，需要判无解。题解显然，当有一个点的点权&gt;S&gt;S&gt;S时就无解，否则有解。考虑一个贪心结论，对于uuu和uuu的儿子vvv，显然从uuu往上能到达的点会比vvv往上到达的点更高或相同，所以节点uuu一定会选择剩余步数最多的儿子节点进行转移。可以先使用树上倍增求出每个节点uuu能到达的最高祖先，计upuup_uupu​表示从uuu节点最多再往上跳upuup_uupu​步。考虑树形DP。设fuf_ufu​表示将uuu的子树覆盖完的链的最少条数，gug_ugu​表示uuu的子树内剩余的最大步数。gu=max⁡vissonofu(gv−1)fu=∑vissonofufvg_u=\\max_\\text{vissonofu}(g_v-1)\\\\f_u=\\sum_\\text{vissonofu}f_vgu​=vissonofumax​(gv​−1)fu​=vissonofu∑​fv​若此时gu=0g_u=0gu​=0，说明无法从子树内已有的链往上延申，所以需要开一条新链，即fu++,gu=upuf_u++,g_u=up_ufu​++,gu​=upu​。否则不需要进行修改。钦定树的根为111，则答案为f1f_1f1​。code\\color{white}codecode","link":"https://yaohaoyou.github.io/post/2024.8.11 trees/"},{"title":"数学学习笔记","content":"狄利克雷卷积Dirichlet定义：其本质是一种运算，可以用∗*∗表示。h(x)=f(x)∗g(x)=∑d∣xf(d)g(xd)=∑ab=xf(a)g(b)h(x)=f(x)*g(x)=\\sum_{d|x}f(d)g(\\frac{x}{d})=\\sum_{ab=x}f(a)g(b)h(x)=f(x)∗g(x)=d∣x∑​f(d)g(dx​)=ab=x∑​f(a)g(b)积性函数f(x)f(x)f(x)满足∀(a,b)=1,f(ab)=f(a)f(b)\\forall(a,b)=1,f(ab)=f(a)f(b)∀(a,b)=1,f(ab)=f(a)f(b)。完全积性函数f(x)f(x)f(x)满足f(ab)=f(a)f(b)f(ab)=f(a)f(b)f(ab)=f(a)f(b)。可以使用线性筛算出积性函数。性质：交换律：f∗g=g∗ff*g=g*ff∗g=g∗f。结合律：(f∗g)∗h=f∗(g∗h)(f*g)*h=f*(g*h)(f∗g)∗h=f∗(g∗h)。分配律：(f+g)∗h=f∗h+g∗h(f+g)*h=f*h+g*h(f+g)∗h=f∗h+g∗h。若fff和ggg是积性函数，则f∗gf*gf∗g也是积性函数。若fff是积性函数，则fff的逆元也是积性函数。逆元：单位函数ε\\varepsilonε，f∗ε=ff*\\varepsilon=ff∗ε=f。若ggg满足f∗g=εf*g=\\varepsilonf∗g=ε，则称g(x)g(x)g(x)是f(x)f(x)f(x)的逆元。逆元唯一。ps：目前还不太懂这是什么，但好像可以理解为ε(n)={1n=10n=1\\varepsilon(n)=\\begin{cases}1&amp;n=1\\\\0&amp;n\\not=1\\end{cases}ε(n)={10​n=1n​=1​。g(x)=ε(x)−∑d∣x,d=1f(d)f(xd)1g(x)=\\dfrac{\\varepsilon(x)-\\sum_{d|x,d\\not=1}f(d)f(\\dfrac{x}{d})}{1}g(x)=1ε(x)−∑d∣x,d​=1​f(d)f(dx​)​莫比乌斯函数Möbius定义式：n=p1a1p2a2...pkakμ(n)={1n=10∃i≤k,ai&gt;1(−1)kelsen=p_1^{a_1}p_2^{a_2}...p_k^{a_k}\\\\\\mu(n)=\\begin{cases}1&amp;n=1\\\\0&amp;\\existi\\lek,a_i&gt;1\\\\(-1)^k&amp;else\\end{cases}n=p1a1​​p2a2​​...pkak​​μ(n)=⎩⎪⎨⎪⎧​10(−1)k​n=1∃i≤k,ai​&gt;1else​性质：μ(x)\\mu(x)μ(x)是积性函数。∑d∣nμ(d)={1n=10n=1\\sum_{d|n}\\mu(d)=\\begin{cases}1&amp;n=1\\\\0&amp;n\\not=1\\end{cases}d∣n∑​μ(d)={10​n=1n​=1​即∑d∣nμ(d)=ε(n),μ∗1=ε\\sum_{d|n}\\mu(d)=\\varepsilon(n),\\mu*1=\\varepsilon∑d∣n​μ(d)=ε(n),μ∗1=ε。在狄利克雷卷积中，莫比乌斯函数是常数函数111的逆元。证明n=p1a1p2a2...pkak,n′=p1p2...pk∵μ(k×a2)=0∴∑d∣nμ(d)=∑d∣n′μ(d)n=p_1^{a_1}p_2^{a_2}...p_k^{a_k},n&#x27;=p_1p_2...p_k\\\\\\because\\mu(k\\timesa^2)=0\\\\\\therefore\\sum_{d|n}\\mu(d)=\\sum_{d|n&#x27;}\\mu(d)n=p1a1​​p2a2​​...pkak​​,n′=p1​p2​...pk​∵μ(k×a2)=0∴d∣n∑​μ(d)=d∣n′∑​μ(d)则现在就是尝试在kkk个互异质数中选择一个集合，若集合大小为奇数，答案-1，否则答案+1。k&gt;1k&gt;1k&gt;1时，∑d∣n′μ(d)=∑i=0k(ki)×(−1)i\\sum_{d|n&#x27;}\\mu(d)=\\sum_{i=0}^k\\binom{k}{i}\\times(-1)^i∑d∣n′​μ(d)=∑i=0k​(ik​)×(−1)i。二项式定理是(a+b)n=∑i=0n(ni)aibn−i(a+b)^n=\\sum_{i=0}^n\\binom{n}{i}a^ib^{n-i}(a+b)n=∑i=0n​(in​)aibn−i，将a=−1,b=1a=-1,b=1a=−1,b=1带入则是(1+(−1))n=∑i=0n(ni)×(−1)i=0(1+(-1))^n=\\sum_{i=0}^n\\binom{n}{i}\\times(-1)^i=0(1+(−1))n=∑i=0n​(in​)×(−1)i=0。故k&gt;1k&gt;1k&gt;1时，∑d∣nμ(d)=0\\sum_{d|n}\\mu(d)=0∑d∣n​μ(d)=0。剩下情况不难自证。ps：以上证明只是本人在初学时的结论，不保证正确，等待未来的我修改或确认。反演结论：[gcd⁡(i,j)=1]=∑d∣gcd⁡(i,j)μ(d)[\\gcd(i,j)=1]=\\sum_{d|\\gcd(i,j)}\\mu(d)[gcd(i,j)=1]=d∣gcd(i,j)∑​μ(d)还不会用。。。阶定义由欧拉定理可知，(a,m)=1(a,m)=1(a,m)=1，aφ(m)≡1(modm)a^{\\varphi(m)}\\equiv1(\\bmodm)aφ(m)≡1(modm)。故存在最小正整数满足an≡1(modm)a^n\\equiv1(\\bmodm)an≡1(modm)，称nnn为aaa模mmm的阶，记作ord⁡m(a)\\operatorname{ord}_m(a)ordm​(a)。性质a,a2...aord⁡m(a)a,a^2...a^{\\operatorname{ord}_m(a)}a,a2...aordm​(a)模mmm两两不同余。若ap≡aq(modm)a^p\\equiva^q(\\bmodm)ap≡aq(modm)，则p≡q(modord⁡m(a))p\\equivq(\\bmod\\operatorname{ord}_m(a))p≡q(modordm​(a))。(a,m)=(b,m)=1ord⁡m(ab)=ord⁡m(a)ord⁡m(b)⇔gcd(ord⁡m(a),ord⁡m(b))=1(a,m)=(b,m)=1\\\\\\operatorname{ord}_m(ab)=\\operatorname{ord}_m(a)\\operatorname{ord}_m(b)\\Leftrightarrowgcd(\\operatorname{ord}_m(a),\\operatorname{ord}_m(b))=1(a,m)=(b,m)=1ordm​(ab)=ordm​(a)ordm​(b)⇔gcd(ordm​(a),ordm​(b))=1原根primitive-root定义若(g,m)=1(g,m)=1(g,m)=1，且ord⁡m(g)=φ(m)\\operatorname{ord}_m(g)=\\varphi(m)ordm​(g)=φ(m)，则称ggg为模mmm的原根。性质对于m≥3,(g,m)=1m\\ge3,(g,m)=1m≥3,(g,m)=1，则ggg是模mmm的原根⇔\\Leftrightarrow⇔对于φ(m)\\varphi(m)φ(m)的每个质因子ppp，都有gφ(m)p≡1(modm)g^{\\frac{\\varphi(m)}{p}}\\not\\equiv1(\\bmodm)gpφ(m)​​≡1(modm)。若mmm有原根，则原根个数为φ(φ(m))\\varphi(\\varphi(m))φ(φ(m))。原根存在定理：一个数mmm存在原根当且仅当m=2,4,pa,2pam=2,4,p^a,2p^am=2,4,pa,2pa，ppp为奇质数。aaa的最小原根大约在a14a^{\\frac{1}{4}}a41​。","link":"https://yaohaoyou.github.io/post/maths/"},{"title":"P10637 BZOJ4262 Sum","content":"题目传送器更爽的阅读体验前言我什么也不会，不知道为什么_maojun_要感谢我。但是我要感谢_maojun_提供思路。题意给出随机的数列aaa，求∑l∈[l1,r1]∑r∈[l2,r2](max⁡i∈[l,r]ai−min⁡i∈[l,r]ai)\\sum_{l\\in[l_1,r_1]}\\sum_{r\\in[l_2,r_2]}(\\max_{i\\in[l,r]}a_i-\\min_{i\\in[l,r]}a_i)∑l∈[l1​,r1​]​∑r∈[l2​,r2​]​(maxi∈[l,r]​ai​−mini∈[l,r]​ai​)。做法做法肯定和这篇题解一样，但我尝试说的更详细一点。conclusion1我会盯式子！因为max⁡−ai=−min⁡ai\\max-a_i=-\\mina_imax−ai​=−minai​，所以只要会求∑l∈[l1,r1]∑r∈[l2,r2]max⁡i∈[l,r]ai\\sum_{l\\in[l_1,r_1]}\\sum_{r\\in[l_2,r_2]}\\max_{i\\in[l,r]}a_i∑l∈[l1​,r1​]​∑r∈[l2​,r2​]​maxi∈[l,r]​ai​，然后将ai=−aia_i=-a_iai​=−ai​，再做一遍，两遍答案加起来就是要输出的结果。conclusion2我会前缀和差分！∑l∈[l1,r1]∑r∈[l2,r2]max⁡i∈[l,r]ai=∑l∈[l1,r1]∑r∈[1,r2]max⁡i∈[l,r]ai−∑l∈[l1,r1]∑r∈[1,l2−1]max⁡i∈[l,r]ai\\sum_{l\\in[l_1,r_1]}\\sum_{r\\in[l_2,r_2]}\\max_{i\\in[l,r]}a_i=\\sum_{l\\in[l_1,r_1]}\\sum_{r\\in[1,r_2]}\\max_{i\\in[l,r]}a_i-\\sum_{l\\in[l_1,r_1]}\\sum_{r\\in[1,l_2-1]}\\max_{i\\in[l,r]}a_i∑l∈[l1​,r1​]​∑r∈[l2​,r2​]​maxi∈[l,r]​ai​=∑l∈[l1​,r1​]​∑r∈[1,r2​]​maxi∈[l,r]​ai​−∑l∈[l1​,r1​]​∑r∈[1,l2​−1]​maxi∈[l,r]​ai​。也就是说设s(l,r,x)=∑i∈[l,r]∑j∈[1,x]max⁡k∈[i,j]aks(l,r,x)=\\sum_{i\\in[l,r]}\\sum_{j\\in[1,x]}\\max_{k\\in[i,j]}a_ks(l,r,x)=∑i∈[l,r]​∑j∈[1,x]​maxk∈[i,j]​ak​，答案可以变成s(l1,r1,r2)−s(l1,r1,l2−1)s(l1,r1,r2)-s(l1,r1,l2-1)s(l1,r1,r2)−s(l1,r1,l2−1)。现在只需会求s(l,r,x)s(l,r,x)s(l,r,x)即可。conclusion3我会扫描线！这个做法在线做好像非常复杂了，所以可以尝试用离线下来做。将所有的s(l,r,x)s(l,r,x)s(l,r,x)的询问挂在xxx上，设f(i,x)=∑j∈[i,x]max⁡k∈[i,j]akf(i,x)=\\sum_{j\\in[i,x]}\\max_{k\\in[i,j]}a_kf(i,x)=∑j∈[i,x]​maxk∈[i,j]​ak​，则s(l,r,x)=∑i∈[l,r]f(i,x)s(l,r,x)=\\sum_{i\\in[l,r]}f(i,x)s(l,r,x)=∑i∈[l,r]​f(i,x)。当x++x++x++时，f(i,x)+=max⁡j∈[i,x]ajf(i,x)+=\\max_{j\\in[i,x]}a_jf(i,x)+=maxj∈[i,x]​aj​，也就是当前的后缀[i,x][i,x][i,x]最大值。所以f(i,x)=max⁡[i,i]+max⁡[i,i+1]+...+max⁡[i,x]=∑j=ixmax[i,j]f(i,x)=\\max[i,i]+\\max[i,i+1]+...+\\max[i,x]=\\sum_{j=i}^xmax[i,j]f(i,x)=max[i,i]+max[i,i+1]+...+max[i,x]=∑j=ix​max[i,j]，也就是以iii为左端点的后缀最大值的历史版本和。所以s(l,r,x)s(l,r,x)s(l,r,x)为区间[l,r][l,r][l,r]的历史版本和之和。conclusion4我会beats+历史版本和（线段树3）！直接做就行了，使用beats进行区间取max，维护后缀最大值，线段树维护历史版本和，求s(l,r,x)s(l,r,x)s(l,r,x)时在线段树上区间修改，时间复杂度为O(n×log⁡22n)O(n\\times\\log_2^2n)O(n×log22​n)，瓶颈在使用beats进行区间取max。conclusion5我会单调栈！后缀[i,x][i,x][i,x]具有单调性，可以使用单调栈维护后缀最大值，来替换beats。由于每个位置只会入栈一次，所以复杂度为大常数的O(n×log⁡2n)O(n\\times\\log_2n)O(n×log2​n)，瓶颈在维护历史版本和与区间查询，维护历史版本和的常数较大。这里放一份_maojun_的代码。conclusion6我会观察性质！注意a数列是随机生成的。众所周知可以证明，在数据随机数列中，使用单调栈维护前缀/后缀min/max值，单调栈的大小期望为O(log⁡2n)O(\\log_2n)O(log2​n)。那就可以不使用常数较大的常规方式维护历史版本和了。对于当前一段后缀max相同的区间，区间内每个数对答案的贡献在目前都是相同的，对于每段区间维护一个时间戳，记录它是什么时候进入单调栈的。当这个区间被弹出时，在线段树上将这个区间的历史版本和更新。与传统的历史版本和不同的是，现在只有在当前点被弹出时才在线段树上维护历史版本和。依然在单调栈中的点可以O(1)O(1)O(1)计算贡献，而这种点又只有O(log⁡2n)O(\\log_2n)O(log2​n)种。所以就获得了一种只需要区间修改和区间查询的线段树的做法，相比之下常数更小，复杂度为O(n×log⁡2n)O(n\\times\\log_2n)O(n×log2​n)。可以将线段树改成zkw或超级树状数组。_maojun_使用了超级树状数组获得了最优解。ACCode#include&lt;bits/stdc++.h&gt;#definelllonglong#defineebemplace_back#definemem(arr,x)memset(arr,x,sizeof(arr))usingnamespacestd;constexprintmaxn=1e5+10;intn,q;lla[maxn];structnode{intl,r,k,id;};namespaceSegmentTree{#definelsp&lt;&lt;1#definersp&lt;&lt;1|1#definelsonls,l,mid#definersonrs,mid+1,r#defineall1,1,n#definesetposintp,intl,intr#definesetmidintmid=(l+r)&gt;&gt;1lltr[maxn&lt;&lt;2],tag[maxn&lt;&lt;2];inlinevoidpushup(intp){tr[p]=tr[ls]+tr[rs];}inlinevoidpushtag(setpos,lls){tr[p]+=(r-l+1)*s;tag[p]+=s;}inlinevoidpushdown(setpos){if(!tag[p])return;setmid;pushtag(lson,tag[p]);pushtag(rson,tag[p]);tag[p]=0;}voidupdate(setpos,intpl,intpr,lls){if(l&gt;=pl&amp;&amp;r&lt;=pr)returnpushtag(p,l,r,s);pushdown(p,l,r);setmid;if(pl&lt;=mid)update(lson,pl,pr,s);if(pr&gt;mid)update(rson,pl,pr,s);pushup(p);}llquery(setpos,intpl,intpr){if(l&gt;=pl&amp;&amp;r&lt;=pr)returntr[p];pushdown(p,l,r);setmid;llres=0;if(pl&lt;=mid)res=query(lson,pl,pr);if(pr&gt;mid)res+=query(rson,pl,pr);returnres;}}usingnamespaceSegmentTree;namespaceDataMaker{constintmod=1e9;longlongfst=1023,sec=1025;voidsolve(){for(inti=1;i&lt;=100000;i++){a[i]=fst^sec;fst=fst*1023%mod;sec=sec*1025%mod;}}}vector&lt;node&gt;v[maxn];llans[maxn];intstk[maxn],tp;voidsolve(){mem(tr,0);mem(tag,0);tp=0;for(inti=1;i&lt;=n;i++){while(tp&amp;&amp;a[stk[tp]]&lt;=a[i]){update(all,stk[tp-1]+1,stk[tp],1ll*(i-stk[tp])*a[stk[tp]]);tp--;}stk[++tp]=i;for(auto[l,r,k,id]:v[i]){llres=query(all,l,r);for(intj=1;j&lt;=tp;j++){intlen=min(stk[j],r)-max(stk[j-1],l-1);if(len&lt;=0)continue;res+=1ll*len*(i-stk[j]+1)*a[stk[j]];}ans[id]+=(res*k);}}}signedmain(){scanf(&quot;%d&quot;,&amp;q);n=1e5;DataMaker::solve();for(inti=1,l1,r1,l2,r2;i&lt;=q;i++){scanf(&quot;%d%d%d%d&quot;,&amp;l1,&amp;r1,&amp;l2,&amp;r2);v[r2].eb(l1,r1,1,i);v[l2-1].eb(l1,r1,-1,i);}solve();for(inti=1;i&lt;=n;i++)a[i]*=-1;solve();for(inti=1;i&lt;=q;i++)printf(&quot;%lld\\n&quot;,ans[i]);}总结基于数组随机可以获得小常数的O(n×log⁡2n)O(n\\times\\log_2n)O(n×log2​n)，不基于数组随机可以获得历史版本和做法的O(n×log⁡2n)O(n\\times\\log_2n)O(n×log2​n)。感谢_maojun_的帮助，同时大力推荐他的题解。*文中部分引用了他人的代码和提交记录，如有侵权行为，请及时私信博主，我会依法进行更改或删除。","link":"https://yaohaoyou.github.io/post/p10637-solution/"},{"title":"P4897 【模板】最小割树（Gomory-Hu Tree） ","content":"题目传送器更爽的阅读体验题意给一个无向连通图，询问两点之间需要割掉多少边权能使两点不连通。做法因为连通性是可传递的，所以可以使用分治。由于无向图两点间最小割===最大流，所以使用网络最大流求最小割。对于当前处理需要处理的点集sss，随意选两个点uuu和vvv跑一次网络最大流，设最大流为maxflowmaxflowmaxflow，则在最小割树上建一条(u,v,maxflow)(u,v,maxflow)(u,v,maxflow)边。设割掉满流的边后uuu能遍历到的点集为s1s1s1，剩下的点集s2=∁ss1s2=\\complement_ss1s2=∁s​s1。往下递归处理s1s1s1和s2s2s2即可。求s1s1s1可以找最后一次dinic的bfs遍历到的点。现在已经建出了最小割树，考虑如何使用。当断掉一条边后，会花费当前边权的代价，将原树树断成两颗新树，这两棵新树上的点两两互相不连通。那对于求(u,v)(u,v)(u,v)的最小割，只要断掉树上(u,lca(u,v))(u,lca(u,v))(u,lca(u,v))和(lca(u,v),v)(lca(u,v),v)(lca(u,v),v)这两条链中最小的一条边即可。可以使用倍增维护边权最小值。ACCode#include&lt;bits/stdc++.h&gt;#definepiipair&lt;int,int&gt;#definepiiipair&lt;int,pii&gt;#defineebemplace_backusingnamespacestd;constintmaxn=1e5+10;constintmaxm=maxn*100;intn,m;structTree{intcnt=1;inthead[maxn];structedge{intnxt,to,w;}e[maxm];inlinevoidadd(intu,intv,intw){e[++cnt]={head[u],v,w};head[u]=cnt;}}Tr;namespaceGraph{piiig[maxn];intcnt=1;inthead[maxn];structedge{intnxt,to,w;}e[maxm];inlinevoidadd(intu,intv,intw){e[++cnt]={head[u],v,w};head[u]=cnt;}inlinevoidrebuild(){cnt=1;memset(head,0,sizeof(head));for(inti=1;i&lt;=m;i++){add(g[i].first,g[i].second.first,g[i].second.second);add(g[i].second.first,g[i].first,g[i].second.second);}}}usingnamespaceGraph;intS,T;namespaceDINIC{constintinf=0x3f3f3f3f;intd[maxn],now[maxn];queue&lt;int&gt;q;inlineboolbfs(){while(!q.empty())q.pop();memset(d,0x3f,sizeof(d));memcpy(now,head,sizeof(head));d[S]=0;q.push(S);while(!q.empty()){intu=q.front();q.pop();for(inti=head[u];i;i=e[i].nxt){intt=e[i].to;if(d[t]!=inf||!e[i].w)continue;d[t]=d[u]+1;q.push(t);if(t==T)returntrue;}}returnfalse;}intdfs(intu,intflw){if(u==T)returnflw;intres=0;for(inti=now[u];i&amp;&amp;flw;i=e[i].nxt){now[u]=i;intt=e[i].to;if(d[t]!=d[u]+1||!e[i].w)continue;intk=dfs(t,min(e[i].w,flw));if(!k)d[t]=inf;e[i].w-=k;e[i^1].w+=k;res+=k;flw-=k;}returnres;}inlineintdinic(){rebuild();intres=0;while(bfs())res+=dfs(S,inf);returnres;}}usingnamespaceDINIC;namespaceDFS{intw[20][maxn],f[20][maxn],dep[maxn];voiddfs(intu,intfa){dep[u]=dep[f[0][u]=fa]+1;w[0][u]=inf;for(inti=Tr.head[u];i;i=Tr.e[i].nxt){intt=Tr.e[i].to;if(t==fa)continue;dfs(t,u);w[0][t]=Tr.e[i].w;}}inlinevoidinit_LCA(){for(inti=1;i&lt;=19;i++)for(intj=1;j&lt;=n;j++){w[i][j]=min(w[i-1][j],w[i-1][f[i-1][j]]);f[i][j]=f[i-1][f[i-1][j]];}}inlineintLCA(intx,inty){//O(nlogn)-O(logn)倍增intres=inf;if(dep[x]&lt;dep[y])swap(x,y);for(inti=19;~i;i--){if(dep[f[i][x]]&gt;=dep[y]){res=min(res,w[i][x]);x=f[i][x];}}if(x==y)returnres;for(inti=19;~i;i--){if(f[i][x]^f[i][y]){res=min(res,w[i][x]);res=min(res,w[i][y]);x=f[i][x];y=f[i][y];}}res=min(res,w[0][x]);res=min(res,w[0][y]);returnres;}}vector&lt;int&gt;v,v1,v2;voiddivide(intl,intr){v1.clear();v2.clear();if(l&gt;=r)return;S=v[l];T=v[l+1];intres=dinic();Tr.add(S,T,res);Tr.add(T,S,res);for(inti=l;i&lt;=r;i++){if(d[v[i]]!=inf)v1.eb(v[i]);elsev2.eb(v[i]);}for(inti=0;i&lt;v1.size();i++)v[i+l]=v1[i];for(inti=0;i&lt;v2.size();i++)v[i+l+v1.size()]=v2[i];intsiz=v1.size();divide(l,l+siz-1);divide(l+siz,r);}intmain(){scanf(&quot;%d%d&quot;,&amp;n,&amp;m);for(inti=1,u,v;i&lt;=m;i++){scanf(&quot;%d%d%d&quot;,&amp;g[i].first,&amp;g[i].second.first,&amp;g[i].second.second);}for(inti=0;i&lt;=n;i++)v.eb(i);divide(0,n);DFS::dfs(1,0);DFS::init_LCA();intq;scanf(&quot;%d&quot;,&amp;q);while(q--){intu,v;scanf(&quot;%d%d&quot;,&amp;u,&amp;v);printf(&quot;%d\\n&quot;,DFS::LCA(u,v));}}总结时间复杂度为O(n×D)O(n\\timesD)O(n×D)，O(D)O(D)O(D)是dinic的时间复杂度，理论是O(n2×m)O(n^2\\timesm)O(n2×m)，但实际上小很多。","link":"https://yaohaoyou.github.io/post/p4897-solution/"},{"title":"鲜花1","content":"2024/7/3LG粉丝破100了。所以到底有没有人看我的博客啊。。。如果有人能不能在这下面发条评论或给我LG私信。。。aboutme","link":"https://yaohaoyou.github.io/post/flower1/"},{"title":"做题记录","content":"P5354[Ynoi2017]由乃的OJAbstractYnoi.不难想到可以先使用树剖维护这个东西。由于每一个二进制位是互相独立的，所以可以记录当前位是0/1在当前区间从左到右或从右到左后能否成为1。可以开k棵线段树维护，复杂度O(n×log⁡22n×k)O(n\\times\\log_2^2n\\timesk)O(n×log22​n×k)。仔细观察pushup，可以将k棵压成一颗，记录当前区间从左往右或从右往左后的。AT_agc027_e[AGC027E]ABBreviate证明题？将a-&gt;1，b-&gt;2，则mod3\\bmod3mod3结果不变。p(s)=∑(si−a+1)mod3p(s)=\\sum(s_i-a+1)\\bmod3p(s)=∑(si​−a+1)mod3。结论（不会证明）：s变成字符c的充要条件是p(s)=p(c)p(s)=p(c)p(s)=p(c)且s有相邻FDSA相同（即不为ababa...或babab..）。前面贪心匹配，注意最后剩下的p值为000。dp即可。使用刷表发，dpidp_idpi​表示前iii个数的答案，每次在当前序列末尾加上一个a或b，注意加答案时要保证剩下的p值为0。ai=p(s[1,i])a_i=p(s[1,i])ai​=p(s[1,i])。dpnxti+1,(ai+1/2)mod3+=dpidp_{nxt_{i+1,(a_i+1/2)\\bmod3}}+=dp_idpnxti+1,(ai​+1/2)mod3​​+=dpi​CF1267HHelpBerLineCF3200《面对做法构造题目》奇妙构造+奇妙证明？考虑这件事情有一个明显的必要条件是：任何时刻相邻两个亮着的灯必须颜色不同。对于时间到这枚举，可以使用set维护前驱和后继，当i=coli=coli=col时，lsti=collst_i\\not=collsti​​=col，nxti=colnxt_i\\not=colnxti​​=col。cyz说可以归纳证明这也是充要条件。也可以证明，colcolcol的范围是log⁡32N\\log_{\\frac{3}{2}}Nlog23​​N。然后就做完了。。。P3233[HNOI2014]世界树码量虚树，为何不改？∑m≤3×105\\summ\\le3\\times10^5∑m≤3×105套路建虚树，暴力是好做的，思考如何在虚树上做。答案=为在虚树上的点的贡献+不在虚树上的点的贡献。设距离节点iii最近的关键节点为p(i)p(i)p(i)。在虚树上的点​两遍dfs可以求出虚树上距离当前点最近的关键点，贡献直接加就可以了。不在虚树上的点xxx​Ⅰxxx在虚树节点yyy的子树并且这个子树中没有关键点。​p(x)=p(y)p(x)=p(y)p(x)=p(y)。直接统计即可​Ⅱxxx在虚树节点uuu和vvv这条链上。​①p(u)=p(v)p(u)=p(v)p(u)=p(v)。则p(x)=p(u)p(x)=p(u)p(x)=p(u)，直接统计即可。​②p(u)=p(v)p(u)\\not=p(v)p(u)​=p(v)。二分出这条链上的ppp的断点qqq，则分开统计两条链即可。复杂度是O(∑m×log⁡2n)O(\\summ\\times\\log_2n)O(∑m×log2​n)。AT_agc048_d[AGC048D]PockyGame又是证明题？自行模拟或证明：只可能有两种操作，取111个石子或取111堆石子。fl,rf_{l,r}fl,r​为[l+1,r][l+1,r][l+1,r]没动，让Firstleft赢，ala_lal​的最小值。gl,rg_{l,r}gl,r​为[l,r−1][l,r-1][l,r−1]没动，让Secondrigtht赢，ara_rar​的最小值。若a1&lt;f1,na_1&lt;f_{1,n}a1​&lt;f1,n​，则Secondright赢，否则Firstleft赢。","link":"https://yaohaoyou.github.io/post/problems-solution/"},{"title":"AT_abc356_e Max/Min","content":"题目传送器更爽的阅读体验AT1506前言赛时小丑以为写假了，遂写篇题解。我不强，我不知道调和级数，但我会根号做法。题意求∑i=1N−1∑j=i+1N⌊max⁡(Ai,Aj)min⁡(Ai,Aj)⌋\\sum_{i=1}^{N-1}\\sum_{j=i+1}^{N}\\left\\lfloor\\frac{\\max(A_i,A_j)}{\\min(A_i,A_j)}\\right\\rfloor∑i=1N−1​∑j=i+1N​⌊min(Ai​,Aj​)max(Ai​,Aj​)​⌋。做法显然可以先将A从小到大排序，然后答案就变成了∑i=2N∑j=1i−1⌊AiAj⌋\\sum_{i=2}^{N}\\sum_{j=1}^{i-1}\\left\\lfloor\\frac{A_i}{A_j}\\right\\rfloor∑i=2N​∑j=1i−1​⌊Aj​Ai​​⌋。然后这就是一个经典的整除分块。具体的，先枚举AiA_iAi​，那此时⌊AiAj⌋\\left\\lfloor\\frac{A_i}{A_j}\\right\\rfloor⌊Aj​Ai​​⌋的答案只有O(V)O(\\sqrtV)O(V​)种。对于当前的k=⌊AiAj⌋k=\\left\\lfloor\\frac{A_i}{A_j}\\right\\rfloork=⌊Aj​Ai​​⌋，可以求出⌊AiAnxt⌋=k\\left\\lfloor\\frac{A_i}{A_{nxt}}\\right\\rfloor=k⌊Anxt​Ai​​⌋=k的另一个边界nxtnxtnxt，然后直接跳到nxt−1nxt-1nxt−1即可。由于kkk的取值只有O(V)O(\\sqrtV)O(V​)种，找到nxtnxtnxt的过程可以使用二分答案，于是复杂度就是O(n×V×log⁡2n)O(n\\times\\sqrtV\\times\\log_2n)O(n×V​×log2​n)。放个代码。赛时代码比较丑，二分答案就不要细看了。Code然而这样是需要在2s内跑4×1094\\times10^94×109的。明显会TLE。思考如何优化。发现整除分块不好优化，所以尝试将log⁡2n\\log_2nlog2​n优化掉。发现二分答案的值域只有O(V)O(V)O(V)，所以可以开一个数组提前预处理。时间复杂度为O(n×V+V×log⁡2n)O(n\\times\\sqrtV+V\\times\\log_2n)O(n×V​+V×log2​n)。ACCode总结时间复杂度为O(n×V+V×log⁡2n)O(n\\times\\sqrtV+V\\times\\log_2n)O(n×V​+V×log2​n)，相比其他做法的却劣了不少，需要1600ms+。赛时真是小丑，同时感谢_maojun_。","link":"https://yaohaoyou.github.io/post/AT_abc356_e/"},{"title":"P10271 漫长悄悄话","content":"题目传送器更爽的阅读体验前言为什么都用PAM和子序列自动机，我会二分答案+manacher+Hash。题意自行看题。做法推一下式子即可，preipre_iprei​表示iii的前缀。Rev(lcs(i,j))=LCP(Rev(prei),Rev(prej))Rev(lcs(i,j))=LCP(Rev(pre_i),Rev(pre_j))Rev(lcs(i,j))=LCP(Rev(prei​),Rev(prej​))手模一下样例就能发现其实就是求以iii为中心的回文半径和以jjj为中心的回文半径的LCP\\text{LCP}LCP。显然答案是有二分性的，可以二分答案xxx后将每个位置iii对应的[i−x+1,i][i-x+1,i][i−x+1,i]的哈希值放入map或unordered_map中，只要有相同的就返回true。manacher只需要跑以当前点为中心的回文串即可，不用在相邻两位加入字符。ACCode#include&lt;bits/stdc++.h&gt;#defineullunsignedlonglongusingnamespacestd;constintmaxn=1e6+10,base=31;intn,p[maxn];ullhsh[maxn],bs[maxn];strings;unordered_map&lt;ull,bool&gt;mp;//记录是否出现过的哈希值inlineullHash(intl,intr){returnhsh[r]-hsh[l-1]*bs[r-l+1];}inlineboolcheck(intx){mp.clear();for(inti=1;i&lt;=n;i++){if(p[i]&lt;x)continue;if(mp[Hash(i-x+1,i)])returntrue;mp[Hash(i-x+1,i)]=true;}returnfalse;}intmain(){ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);cin&gt;&gt;n&gt;&gt;s;s='|'+s+'#';bs[0]=1;for(inti=1;i&lt;=n;i++){hsh[i]=hsh[i-1]*base+(s[i]-'a');bs[i]=bs[i-1]*base;}//manacherfor(inti=1,mid=0,r=0;i&lt;=n;i++){p[i]=i&gt;r?1:min(p[(mid&lt;&lt;1)-i],r-i+1);while(s[i+p[i]]==s[i-p[i]])p[i]++;if(i+p[i]&gt;r){r=i+p[i]-1;mid=i;}}//二分答案intl=1,r=n,ans=0;while(l&lt;=r){intmid=(l+r)&gt;&gt;1;if(check(mid)){ans=mid;l=mid+1;}elser=mid-1;}printf(&quot;%d\\n&quot;,ans);}总结&amp;乱搞时间复杂度为O(n×log⁡2n)O(n\\times\\log_2n)O(n×log2​n)，跑得还挺快。实测不使用哈希，直接将字符串区间放入unordered_map，也就是O(n2×log⁡2n)O(n^2\\times\\log_2n)O(n2×log2​n)也能过，只用300+ms。","link":"https://yaohaoyou.github.io/post/p10271/"},{"title":"关于","content":"欢迎来到我的小站呀，很遇见你！🤝高兴🏠关于本站yaohaoyou\\texttt{yaohaoyou}yaohaoyou的博客👨‍💻博主是谁GD的OI选手，快来爆踩。📬联系我呀LG:739274","link":"https://yaohaoyou.github.io/post/about-me/"}]}
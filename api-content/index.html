{"posts":[{"title":"暑假讲题","content":"◊\\Large{\\color{red}\\Diamond}◊为重点转换步骤。AT_arc201_b[ARC201B]BinaryKnapsack因为WWW很大，所以不能是01背包的思路，应该想贪心。思考偏序关系，由于不同重量只有log⁡2W\\log_2Wlog2​W种，并且两个2x−12^{x-1}2x−1可以直接合并成2x2^x2x，所以每次贪心取当前重量价值最大的一定更优。对WWW进行二进制拆位，从小到大，若当前第iii位为111，则选一个重量为2i2^i2i的一定不劣。◊\\Large{\\color{red}\\Diamond}◊剩下的排序后两两合并成重量为2i+12^{i+1}2i+1的物品，继续递归子问题。AT_arc200_epopcount&lt;=2将得到的AAA序列全部异或xxx后依旧满足情况，所以不妨将AAA异或A1A_1A1​后使A1=0A_1=0A1​=0。直接钦定A1=0A_1=0A1​=0，最后将答案×2m\\times2^m×2m即可。◊\\Large{\\color{red}\\Diamond}◊由于A1=0A_1=0A1​=0，popcount(A1⊕Ai)≤2popcount(A_1\\oplusA_i)\\le2popcount(A1​⊕Ai​)≤2，所以popcount(Ai)≤2popcount(A_i)\\le2popcount(Ai​)≤2。接下来分情况讨论。popcount(Ai)≤1popcount(A_i)\\le1popcount(Ai​)≤1，没有其他限制了，方案数为(m+1)n−1(m+1)^{n-1}(m+1)n−1。有且仅有一种popcount(Ax)=2popcount(A_x)=2popcount(Ax​)=2，方案数为(m2)(4n−1−3n−1)\\binomm2(4^{n-1}-3^{n-1})(2m​)(4n−1−3n−1)。有多种popcount(Aa1,Aa2,..Aak)=2popcount(A_{a_1},A_{a_2},..A_{a_k})=2popcount(Aa1​​,Aa2​​,..Aak​​)=2，且popcount(Aa1&amp;Aa2&amp;..&amp;Aak)=1,k≥2popcount(A_{a_1}\\AndA_{a_2}\\And..\\AndA_{a_k})=1,k\\ge2popcount(Aa1​​&amp;Aa2​​&amp;..&amp;Aak​​)=1,k≥2，方案数为m((m+1)n−1−2n−1−(m−1)(3n−1−2n−1))m((m+1)^{n-1}-2^{n-1}-(m-1)(3^{n-1}-2^{n-1}))m((m+1)n−1−2n−1−(m−1)(3n−1−2n−1))。有且仅有三种popcount(Ax,Ay,Az)=2popcount(A_x,A_y,A_z)=2popcount(Ax​,Ay​,Az​)=2，此时只能有这三种数和000出现，并且两两交的popcount都为111，如{Ax,Ay,Az}={3,5,6}\\{A_x,A_y,A_z\\}=\\{3,5,6\\}{Ax​,Ay​,Az​}={3,5,6}。方案数为(m3)(4n−1−3×3n−1+3×2n−1−1)\\binomm3(4^{n-1}-3\\times3^{n-1}+3\\times2^{n-1}-1)(3m​)(4n−1−3×3n−1+3×2n−1−1)。P9140THUPC2023初赛背包类似于P2371墨墨的等式的思路，先取civi\\frac{c_i}{v_i}vi​ci​​最大的物品作为基准并设m=vi,k=cim=v_i,k=c_im=vi​,k=ci​，由于若V′V&#x27;V′可以被凑出，则V′≡V(modm)V&#x27;\\equivV(\\bmodm)V′≡V(modm)的VVV可以通过加入多个mmm凑出，所以将物品的总大小在modm\\bmodmmodm的剩余系上处理。◊\\Large{\\color{red}\\Diamond}◊对于(V′,C′),V≡V′(modm)(V&#x27;,C&#x27;),V\\equivV&#x27;(\\bmodm)(V′,C′),V≡V′(modm)的情况，此时的总贡献为C′+V−V′mkC&#x27;+\\frac{V-V&#x27;}mkC′+mV−V′​k，由于Vm\\fracVmmV​固定，所以需要使C′−⌊V′m⌋kC&#x27;-\\lfloor\\frac{V&#x27;}m\\rfloorkC′−⌊mV′​⌋k最大，将这个值设为同余最长路上的距离。转移时从ppp加上物品xxx后转移至q=(p+vx)modmq=(p+v_x)\\bmodmq=(p+vx​)modm，fq=fp+cx−⌊p+vxm⌋kf_q=f_p+c_x-\\lfloor\\frac{p+v_x}m\\rfloorkfq​=fp​+cx​−⌊mp+vx​​⌋k。转移过程中需要保证没有正环和V′&gt;VV&#x27;&gt;VV′&gt;V。若有正权环u1→u2→...→usiz→u1u_1\\tou_2\\to...\\tou_{siz}\\tou_1u1​→u2​→...→usiz​→u1​，由于转一圈后物品总体积一定为mmm的倍数，而由于选择的基准为ciwi\\frac{c_i}{w_i}wi​ci​​最大，所以一定不如全部选择物品iii，矛盾，所以不存在正权环。设∀i∈[1,n],vi≤limv=105\\foralli\\in[1,n],v_i\\lelim_v=10^5∀i∈[1,n],vi​≤limv​=105。图上共有mmm个点，因为没有正权环，所以每个点最多走过111次，走过的边数最多也只有m−1m-1m−1条，每条边增加的体积≤limv\\lelim_v≤limv​，所以V′≤(limv)2=1010&lt;1011V&#x27;\\le(lim_v)^2=10^{10}&lt;10^{11}V′≤(limv​)2=1010&lt;1011，所以V′&lt;VV&#x27;&lt;VV′&lt;V。◊\\Large{\\color{red}\\Diamond}◊由于有负边权，所以不能用dijkstra。这个题数据水，最短路直接用SPFA就过了，正解应该使用转两圈的做法将复杂度做到O(nm)O(nm)O(nm)。建边的过程实际是枚举i∈[1,n],u∈[0,m)i\\in[1,n],u\\in[0,m)i∈[1,n],u∈[0,m)并连边(u,(u+vi)modm,w)(u,(u+v_i)\\bmodm,w)(u,(u+vi​)modm,w)，手玩一下（其实比较显然）可以发现对于iii会产生gcd⁡(vi,m)\\gcd(v_i,m)gcd(vi​,m)个环。由于本质上是在模意义下做完全背包，所以转移顺序并不影响。并且由于每个点只会在最短路上走一次，所以最短路只要在已知的gcd⁡(vi,m)\\gcd(v_i,m)gcd(vi​,m)个环上找到最小的disdisdis值，并用其转一圈更新这圈的其他点即可，也就是x∈[0,vi):x→(x+vi)mod→(x+2vi)modm→...→xx\\in[0,v_i):x\\to(x+v_i)\\bmod\\to(x+2v_i)\\bmodm\\to...\\toxx∈[0,vi​):x→(x+vi​)mod→(x+2vi​)modm→...→x。写代码时为了方便，可以不用找到disdisdis最小值，直接在环上转两圈更新即可，复杂度为O(nm)O(nm)O(nm)。P7320「PMOI-4」可怜的团主首先由一个结论是一棵树至少由⌈leaf2⌉\\lceil\\frac{leaf}2\\rceil⌈2leaf​⌉条路径覆盖，构造是将叶子按dfs序排序后，路径为(lf1,lf⌈leaf2⌉),(lf2,lf⌈leaf2⌉+1)…(lf_1,lf_{\\lceil\\frac{leaf}2\\rceil}),(lf_2,lf_{\\lceil\\frac{leaf}2\\rceil+1})\\dots(lf1​,lf⌈2leaf​⌉​),(lf2​,lf⌈2leaf​⌉+1​)…，若leafleafleaf是奇数则最后连一条(1,lfleaf)(1,lf_{leaf})(1,lfleaf​)。◊\\Large{\\color{red}\\Diamond}◊必要性显然，应为一条路径最多覆盖两个叶子。充分性是这样的路径可以使相邻两条路径都有交集。若有一个点uuu没有被覆盖。若uuu有至少两个在uuu儿子dfs序排列中相邻的v,wv,wv,w，则必有一条经过vvv子树的路径与一条经过www子树的路径相交，所以uuu一定被覆盖。若uuu只有一个儿子，若有不在uuu子树内的叶子则有一条从uuu子树内到外的路径，否则从1→u1\\tou1→u的路径上degf=1deg_f=1degf​=1，则存在从uuu子树内到111的路径。综上，至少用⌈leaf2⌉\\lceil\\frac{leaf}2\\rceil⌈2leaf​⌉条路径一定能覆盖所有节点。由于⌈n6⌉\\lceil\\fracn6\\rceil⌈6n​⌉和⌊n3⌋\\lfloor\\fracn3\\rfloor⌊3n​⌋的关系与⌈x2⌉\\lceil\\fracx2\\rceil⌈2x​⌉相似，所以考虑提出dfs树并看叶子考虑。◊\\Large{\\color{red}\\Diamond}◊显然，若leaf≥⌊n3⌋leaf\\ge\\lfloor\\fracn3\\rfloorleaf≥⌊3n​⌋，则选择第二种并将叶子节点输出即可。反之leaf&lt;⌊n3⌋leaf&lt;\\lfloor\\fracn3\\rfloorleaf&lt;⌊3n​⌋，则覆盖所有点的路径数⌈leaf2⌉&lt;⌈⌊n3⌋2⌉&lt;⌈n6⌉\\lceil\\frac{leaf}2\\rceil&lt;\\lceil\\frac{\\lfloor\\fracn3\\rfloor}2\\rceil&lt;\\lceil\\fracn6\\rceil⌈2leaf​⌉&lt;⌈2⌊3n​⌋​⌉&lt;⌈6n​⌉，使用上述的叶子节点相互匹配的做法后，剩下的路径用(x,x)(x,x)(x,x)浪费掉即可。AT_agc037_dSortingaGrid从无序的状态转移到有序的状态可以倒着思考，从有序的状态思考能到达的状态的共同点。由有序的状态进行每行重排后每行的值域集合不会变，设行重排后的矩阵为：AAAAABBBBBCCCCCDDDDDEEEEE\\begin{matrix}A&amp;A&amp;A&amp;A&amp;A\\\\B&amp;B&amp;B&amp;B&amp;B\\\\C&amp;C&amp;C&amp;C&amp;C\\\\D&amp;D&amp;D&amp;D&amp;D\\\\E&amp;E&amp;E&amp;E&amp;E\\\\\\end{matrix}ABCDE​ABCDE​ABCDE​ABCDE​ABCDE​1≤A≤m,m+1≤B≤2m…1\\leA\\lem,m+1\\leB\\le2m\\dots1≤A≤m,m+1≤B≤2m…再列重排后矩阵的每一列都会包含A,B,C…A,B,C\\dotsA,B,C…各一个，这是操作两步的必然结论。最后一步再回到输入的乱序矩阵，则此时乱序矩阵进行行重排后需要满足每列都各有A,B,C…A,B,C\\dotsA,B,C…各一个的性质。◊\\Large{\\color{red}\\Diamond}◊进行构造时将枚举(i,j)(i,j)(i,j)后将i↔⌈ai,j−1m⌉+nmi\\leftrightarrow\\lceil\\frac{a_{i,j}-1}m\\rceil+nmi↔⌈mai,j​−1​⌉+nm，由于每行有mmm个数，每种字符会出现mmm次，所以最终连出的是正则二分图（每个点度数都相同的二分图），每次需要寻找出一组完美匹配表示当前列的状态，随后删除这组边并继续寻找二分图完美匹配。本图任选一个左部点集合都满足out(S)=∣S∣out(S)=|S|out(S)=∣S∣，由于Hall定理，存在完美匹配，删除匹配后依旧满足out(S)=∣S∣out(S)=|S|out(S)=∣S∣，所以一定可以找出mmm组完美匹配。◊\\Large{\\color{red}\\Diamond}◊AT_agc061_cFirstComeFirstServe设dpidp_idpi​表示[1,i][1,i][1,i]的答案，转移为dpi←2dpi−1−Cdp_i\\leftarrow2dp_{i-1}-Cdpi​←2dpi−1​−C，CCC为容斥掉的方案数。设iii最终取的值为ti∈{ai,bi}t_i\\in\\{a_i,b_i\\}ti​∈{ai​,bi​}，则tit_iti​取aia_iai​和bib_ibi​时结果相同当且仅当∀tj∉[ai,bi]\\forallt_j\\notin[a_i,b_i]∀tj​∈/​[ai​,bi​]，思考如何容斥掉这一部分。因为ai&lt;ai+1,bi&lt;bi+1a_i&lt;a_{i+1},b_i&lt;b_{i+1}ai​&lt;ai+1​,bi​&lt;bi+1​，所以区间之间不存在包含。若使∃tj∈[ai,bi]\\not\\existt_j\\in[a_i,b_i]​∃tj​∈[ai​,bi​]，则对于Li=min⁡j(bj&gt;ai),Ri=max⁡j(aj&lt;bi)L_i=\\minj(b_j&gt;a_i),R_i=\\maxj(a_j&lt;b_i)Li​=minj(bj​&gt;ai​),Ri​=maxj(aj​&lt;bi​)，当j∈[Li,i)j\\in[L_i,i)j∈[Li​,i)选tj=ajt_j=a_jtj​=aj​，j∈(i,Ri]j\\in(i,R_i]j∈(i,Ri​]选tj=bjt_j=b_jtj​=bj​，可以使k∈[Li,Ri]k\\in[L_i,R_i]k∈[Li​,Ri​]都可以选出tk∉[ai,bi]t_k\\notin[a_i,b_i]tk​∈/​[ai​,bi​]，即满足∃tj∈[ai,bi]\\not\\existt_j\\in[a_i,b_i]​∃tj​∈[ai​,bi​]。◊\\Large{\\color{red}\\Diamond}◊所以对于dpRidp_{R_i}dpRi​​需要删去aia_iai​和bib_ibi​重复的贡献，由于此时[Li,Ri][L_i,R_i][Li​,Ri​]的方案固定，所以dpRi←−dpLi−1dp_{R_i}\\leftarrow-dp_{L_{i-1}}dpRi​​←−dpLi−1​​。求LiL_iLi​和RiR_iRi​直接二分或双指针即可，复杂度为O(n)/O(nlog⁡2n)\\mathcalO(n)/\\mathcalO(n\\log_2n)O(n)/O(nlog2​n)。P6657【模板】LGV引理感觉原本的定义还是比较复杂，尝试用比较简洁但不一定足够适用的讲述。先构造矩阵M=[f(sx1,sy1,tx1,ty1)…f(sx1,sy1,txn,tyn)f(sx2,sy2,tx1,ty1)…f(sx2,sy2,txn,tyn)⋱f(sxn−1,syn−1,tx1,ty1)…f(sxn−1,syn−1,txn,tyn)f(sxn,syn,tx1,ty1)…f(sxn,syn,txn,tyn)]M=\\left[\\begin{matrix}f(sx_1,sy_1,tx_1,ty_1)&amp;\\dots&amp;f(sx_1,sy_1,tx_n,ty_n)\\\\f(sx_2,sy_2,tx_1,ty_1)&amp;\\dots&amp;f(sx_2,sy_2,tx_n,ty_n)\\\\&amp;\\ddots\\\\f(sx_{n-1},sy_{n-1},tx_1,ty_1)&amp;\\dots&amp;f(sx_{n-1},sy_{n-1},tx_n,ty_n)\\\\f(sx_n,sy_n,tx_1,ty_1)&amp;\\dots&amp;f(sx_n,sy_n,tx_n,ty_n)\\\\\\end{matrix}\\right]M=⎣⎢⎢⎢⎢⎡​f(sx1​,sy1​,tx1​,ty1​)f(sx2​,sy2​,tx1​,ty1​)f(sxn−1​,syn−1​,tx1​,ty1​)f(sxn​,syn​,tx1​,ty1​)​……⋱……​f(sx1​,sy1​,txn​,tyn​)f(sx2​,sy2​,txn​,tyn​)f(sxn−1​,syn−1​,txn​,tyn​)f(sxn​,syn​,txn​,tyn​)​⎦⎥⎥⎥⎥⎤​使用LGV引理需要保证存在构造从(sxi,syi)(sx_i,sy_i)(sxi​,syi​)到达(txpi,typj)(tx_{p_i},ty_{p_j})(txpi​​,typj​​)的nnn条路径之间互不相交，排列ppp只能为p={1,2,3..,n}p=\\{1,2,3..,n\\}p={1,2,3..,n}。换言之，若∃pi≠i\\existp_i\\neqi∃pi​​=i，则无法构造nnn条互不相交的路径。LGV引理只适用于DAG。LGV引理：从(sxi,syi)(sx_i,sy_i)(sxi​,syi​)到达(txi,tyi)(tx_i,ty_i)(txi​,tyi​)的nnn条路径互不相交的方案数为det⁡(M)\\det(M)det(M)。AT_agc057_dSumAvoidance神仙题，根本不可能想出来。首先∣A∣|A|∣A∣的上界显然是⌊S−12⌋\\lfloor\\frac{S-1}2\\rfloor⌊2S−1​⌋，因为(1,S−1),(2,S−2)…(1,S-1),(2,S-2)\\dots(1,S−1),(2,S−2)…不能同时存在，若2∣S2|S2∣S，也不能出现S2\\fracS22S​。而这个上界也可以直接构造出来，只要取最大的⌊S−12⌋\\lfloor\\frac{S-1}2\\rfloor⌊2S−1​⌋个数即可，因为任意两个数相加已经&gt;S&gt;S&gt;S。此时想要让字典序尽量小。令选择的集合包括A⊆[1,⌊S−12⌋]A\\subseteq[1,\\lfloor\\frac{S-1}2\\rfloor]A⊆[1,⌊2S−1​⌋]，B⊆[S−⌊S−12⌋,S−1]B\\subseteq[S-\\lfloor\\frac{S-1}2\\rfloor,S-1]B⊆[S−⌊2S−1​⌋,S−1]。将字典序变小的过程就是将一些x∈Bx\\inBx∈B的换成S−xS-xS−x。可以证明，直接从小到大，如果加入xxx后依旧凑不出SSS，则在答案集合加入xxx一定更优。◊\\Large{\\color{red}\\Diamond}◊证明：对于任意一个x∈[1,⌊S−12⌋]x\\in[1,\\lfloor\\frac{S-1}2\\rfloor]x∈[1,⌊2S−1​⌋]，若前面的数能凑出xxx，则加入xxx不影响凑其他数。否则前面的数无法凑出xxx，则可以加入S−xS-xS−x，由于后面的加入集合的数都&gt;x&gt;x&gt;x，所以不会导致S−xS-xS−x和其他数凑出SSS。这样就可以比较方便的O(S)O(S)O(S)求答案，思考如何继续加速贪心过程。设加入的最小数为ddd，由于d∣Sd\\not\\midSd​∣S，lcm(1,2,...43)&gt;1018lcm(1,2,...43)&gt;10^{18}lcm(1,2,...43)&gt;1018，所以d≤43d\\le43d≤43。思考两种添加方式，添加的数x≤⌊S−12⌋x\\le\\lfloor\\frac{S-1}2\\rfloorx≤⌊2S−1​⌋。xxx可以由AAA中的数凑出。xxx不能被AAA中的数凑出，但加入后也无法凑出SSS。111的做法可以后面二分时再处理，思考222会加入哪些数。因为d∈Ad\\inAd∈A，所以222加入的数在modd\\bmoddmodd意义下互不相同，否则可以用111做出，所以222加入的数至多O(d)\\mathcalO(d)O(d)，复杂度可以接受。◊\\Large{\\color{red}\\Diamond}◊令fi,i∈[1,d)f_i,i\\in[1,d)fi​,i∈[1,d)表示222加入的数modd=i\\bmodd=imodd=i的最小的数，转移时枚举加入vvv，若能加入需保证f(S−iv)modd+iv&gt;Sf_{(S-iv)\\bmodd}+iv&gt;Sf(S−iv)modd​+iv&gt;S，即保证v≥max⁡i=1d−1(⌊S−f(S−iv)moddi⌋+1)v\\ge\\max_{i=1}^{d-1}(\\lfloor\\frac{S-f_{(S-iv)\\bmodd}}i\\rfloor+1)v≥i=1maxd−1​(⌊iS−f(S−iv)modd​​⌋+1)由于转移式中只与vmoddv\\bmoddvmodd相关，所以枚举x=vxmoddx=v_x\\bmoddx=vx​modd，按上面的式子跑一遍后将vxv_xvx​加到vx≡x(modd)v_x\\equivx(\\bmodd)vx​≡x(modd)为止。这一步需要枚举xxx和iii，单次复杂度为O(d2)\\mathcalO(d^2)O(d2)。由于要从小到大进行贪心，所以对于所有的vxv_xvx​，每次只会选取最小的vmnv_{mn}vmn​更新所有的fff。更新fff时枚举i,j∈[1,d)i,j\\in[1,d)i,j∈[1,d)。f(i+j×vmn)modd←fi+j×vmnf_{(i+j\\timesv_{mn})\\bmodd}\\leftarrowf_i+j\\timesv_{mn}f(i+j×vmn​)modd​←fi​+j×vmn​由于每个x∈[0,d)x\\in[0,d)x∈[0,d)只会有至多一次x=mnx=mnx=mn将fxf_xfx​更新至最小值（最终值），所以会进行O(d)\\mathcalO(d)O(d)次上述的单次，复杂度为O(d3)\\mathcalO(d^3)O(d3)。AAA中≤x\\lex≤x的个数为∑i=0d−1max⁡(0,⌊x−fid⌋+[i=0])\\sum_{i=0}^{d-1}\\max(0,\\lfloor\\frac{x-f_i}d\\rfloor+[i\\not=0])∑i=0d−1​max(0,⌊dx−fi​​⌋+[i​=0])。注意f0=0f_0=0f0​=0，i=0i=0i=0时不加一是因为无法选取0∈A0\\inA0∈A。对于询问二分答案后求有多少个凑出的数≤x\\lex≤x，对于≤⌊S−12⌋\\le\\lfloor\\frac{S-1}2\\rfloor≤⌊2S−1​⌋的答案直接二分答案即可，&gt;⌊S−12⌋&gt;\\lfloor\\frac{S-1}2\\rfloor&gt;⌊2S−1​⌋的答案先将k←k−∣A∣k\\leftarrowk-|A|k←k−∣A∣后反着二分。本题最终复杂度为O(T(d3+dlog⁡2k))\\mathcalO(T(d^3+d\\log_2k))O(T(d3+dlog2​k))。","link":"https://yaohaoyou.github.io/post/summer-solution/"},{"title":"比赛题解","content":"◊\\Large{\\color{red}\\Diamond}◊为重点转换步骤。typer直接设fi,jf_{i,j}fi,j​表示前S[1∼i]S[1\\simi]S[1∼i]匹配T[1∼j]T[1\\simj]T[1∼j]位的答案。fi,j=min⁡(fi−1,j+1,fi,j−1+1,fi−1,j−1+[Si=Tj])f_{i,j}=\\min(f_{i-1,j}+1,f_{i,j-1}+1,f_{i-1,j-1}+[S_i\\not=T_j])fi,j​=min(fi−1,j​+1,fi,j−1​+1,fi−1,j−1​+[Si​​=Tj​])直接做复杂度为O(∣S∣m∣T∣)\\mathcalO(|S|m|T|)O(∣S∣m∣T∣)。由于∣T∣≤20|T|\\le20∣T∣≤20，并且发现i−j≤fi,j≤i+ji-j\\lef_{i,j}\\lei+ji−j≤fi,j​≤i+j，所以i+j−fi,j≤2∣T∣i+j-f_{i,j}\\le2|T|i+j−fi,j​≤2∣T∣，由于值域范围小，所以套路性的将值域放在定义维上，将原本的iii定为dp值。◊\\Large{\\color{red}\\Diamond}◊设gi,jg_{i,j}gi,j​为满足fx,i=x+i−jf_{x,i}=x+i-jfx,i​=x+i−j最小的xxx。上面的fff的转移式中前两种方法的i+j−fi,ji+j-f_{i,j}i+j−fi,j​是不变的，所以先gi,j←gi−1,jg_{i,j}\\leftarrowg_{i-1,j}gi,j​←gi−1,j​。若想让Si=TjS_i=T_jSi​=Tj​，gi,j←k(k&gt;gi−1,j−2,Sk=Tj)g_{i,j}\\leftarrowk(k&gt;g_{i-1,j-2},S_k=T_j)gi,j​←k(k&gt;gi−1,j−2​,Sk​=Tj​)，否则gi,j←k(k&gt;gi−1,j−1,Sk≠Tj)g_{i,j}\\leftarrowk(k&gt;g_{i-1,j-1},S_k\\neqT_j)gi,j​←k(k&gt;gi−1,j−1​,Sk​​=Tj​)。预处理出每个位置nxi,j,0/1nx_{i,j,0/1}nxi,j,0/1​表示SiS_iSi​后字符为/不为jjj的第一个位置。sum本题保证了无重边自环。k=1k=1k=1简单。将∑f(S)2\\sumf(S)^2∑f(S)2转成∑(f(S)2)\\sum\\binom{f(S)}2∑(2f(S)​)，赋予组合意义即为从SSS的导出子图中任意选两条边的方案数的和，从而可以拆贡献至选取两条边进行计算。◊\\Large{\\color{red}\\Diamond}◊f(S)2=2(f(S)2)+f(S)f(S)^2=2\\binom{f(S)}2+f(S)f(S)2=2(2f(S)​)+f(S)两条边的情况可能是两条无交边或有一个公用顶点，分开讨论并枚举公共点即可。f(S)3=6(f(S)3)+3f(S)2−2f(S)f(S)^3=6\\binom{f(S)}3+3f(S)^2-2f(S)f(S)3=6(3f(S)​)+3f(S)2−2f(S)f(S)2f(S)^2f(S)2和f(S)f(S)f(S)直接使用上面的即可，重点讨论(f(S)3)\\binom{f(S)}3(3f(S)​)如何拆开。影响结果的只有任选的三条边的点数xxx和方案数yyy，贡献为y2n−xy2^{n-x}y2n−x。x=3,4,5,6x={3,4,5,6}x=3,4,5,6。由于总方案数为(m3)\\binom{m}3(3m​)，所以x=6x=6x=6可以直接用总的减去其它的计算。x=3x=3x=3，即一个三元环。直接用三元环计数即可，令方案数为AAA，复杂度为O(mm)O(m\\sqrtm)O(mm​)。x=4x=4x=4，可能是一条链或者一个菊花。链：枚举中间那一条边(u,v)(u,v)(u,v)，方案数B=(∑(degu−1)×(degv−1))−3AB=(\\sum(deg_u-1)\\times(deg_v-1))-3AB=(∑(degu​−1)×(degv​−1))−3A，最后减3A3A3A是因为如果形成三元环，每条边都会被作为中间的边多算一次。菊花：枚举度数为333的点uuu，方案数C=∑(degu3)C=\\sum\\binom{deg_u}{3}C=∑(3degu​​)。x=5x=5x=5，即分离的一条三元链和一条边，枚举三元链的中心uuu，方案数D=(∑(degu2)(m−2))−3A−2B−3CD=(\\sum\\binom{deg_u}2(m-2))-3A-2B-3CD=(∑(2degu​​)(m−2))−3A−2B−3C。3A3A3A因为三元环中三个点都会被作为链中心，2B2B2B因为插入的新边可能在链的两端，3C3C3C因为菊花的三条边都会被作为插入的新边。x=6x=6x=6，E=(m3)−A−B−C−DE=\\binomm3-A-B-C-DE=(3m​)−A−B−C−D。(f(S)3)=2n−3A+2n−4(B+C)+2n−5D+2n−6E\\binom{f(S)}3=2^{n-3}A+2^{n-4}(B+C)+2^{n-5}D+2^{n-6}E(3f(S)​)=2n−3A+2n−4(B+C)+2n−5D+2n−6E。sort寻找第kkk小可以先转化成二分答案+求有多少个≤mid\\lemid≤mid。k←k−1k\\leftarrowk-1k←k−1这里的字典序有些不同，可以直接用AiA_iAi​记录iii出现的次数，比较AAA和BBB时从i=1→ni=1\\toni=1→n比较AiA_iAi​和BiB_iBi​即可，若Ai&lt;BiA_i&lt;B_iAi​&lt;Bi​则A&gt;BA&gt;BA&gt;B，Ai&gt;BiA_i&gt;B_iAi​&gt;Bi​则A&lt;BA&lt;BA&lt;B。由于增加一个数一定会使字典序变小，所以S[l,l]&gt;S[l,l+1]&gt;...&gt;S[l,n]S[l,l]&gt;S[l,l+1]&gt;...&gt;S[l,n]S[l,l]&gt;S[l,l+1]&gt;...&gt;S[l,n]且S[1,r]&lt;S[2,r]&lt;...S[r,r]S[1,r]&lt;S[2,r]&lt;...S[r,r]S[1,r]&lt;S[2,r]&lt;...S[r,r]，于是对于左端点固定的区间具有单调性，设二分的区间是[L,R][L,R][L,R]，则可以通过双指针或二分对每个iii求出MiM_iMi​使S[i,n]&lt;S[i,n−1]&lt;...&lt;S[i,Mi]≤S[L,R]S[i,n]&lt;S[i,n-1]&lt;...&lt;S[i,M_i]\\leS[L,R]S[i,n]&lt;S[i,n−1]&lt;...&lt;S[i,Mi​]≤S[L,R]，进而求出S[L,R]S[L,R]S[L,R]的排名。◊\\Large{\\color{red}\\Diamond}◊若rnk(S[L,R])≤krnk(S[L,R])\\lekrnk(S[L,R])≤k，则将pri=Mi−1pr_i=M_i-1pri​=Mi​−1表示删去[i,Mi],[i,Mi+1]...[i,n][i,M_i],[i,M_i+1]...[i,n][i,Mi​],[i,Mi​+1]...[i,n]，并将k←k−rnk(S[L,R])k\\leftarrowk-rnk(S[L,R])k←k−rnk(S[L,R])。否则将pli=Mipl_{i}=M_ipli​=Mi​表示删去[i,i],[i,i+1],...[i,Mi−1][i,i],[i,i+1],...[i,M_i-1][i,i],[i,i+1],...[i,Mi​−1]。生成[L,R][L,R][L,R]时在剩余的所有区间中随机一个即可，期望每次能选到字典序排名的重点左右，所以复杂度是O(log⁡n)O(\\logn)O(logn)的。双指针的过程就是有O(n)O(n)O(n)次加入和删除一个字符，并查询桶内第一个和S[l,r]S[l,r]S[l,r]的桶内的不同值。可以使用线段树维护Ti=Ai−BiT_i=A_i-B_iTi​=Ai​−Bi​，加入字符ccc时将Tc←Tc+1T_c\\leftarrowT_c+1Tc​←Tc​+1，删除时Tc←Tc−1T_c\\leftarrowT_c-1Tc​←Tc​−1，查询时在线段树上二分或提前存储第一个Ti≠0T_i\\neq0Ti​​=0，若Ti&gt;0T_i&gt;0Ti​&gt;0则A&lt;BA&lt;BA&lt;B，否则A&gt;BA&gt;BA&gt;B。总复杂度为O(nlog⁡2n)O(n\\log^2n)O(nlog2n)。countcircle设Li,j,Ri,j,Ui,j,Di,jL_{i,j},R_{i,j},U_{i,j},D_{i,j}Li,j​,Ri,j​,Ui,j​,Di,j​分别表示(i,j)(i,j)(i,j)向左，向右，向上，向下能走到的最远的位置。原题就是求∑i=1n∑j=1m∑x=Uii−1∑y=Ljj−1[Dx,y≥i∧Rx,y≥j]\\sum_{i=1}^n\\sum_{j=1}^m\\sum_{x=U_i}^{i-1}\\sum_{y=L_j}^{j-1}[D_{x,y}\\gei\\wedgeR_{x,y}\\gej]i=1∑n​j=1∑m​x=Ui​∑i−1​y=Lj​∑j−1​[Dx,y​≥i∧Rx,y​≥j]明显上面的式子是四维的，无法直接做。将矩阵进行分治，选择竖着的中线midmidmid，分别对左右独立讨论经过中线的方案数再乘起来，将四维转换为三维。◊\\Large{\\color{red}\\Diamond}◊两边情况相似，只考虑左侧穿过中线的情况。先枚举u∈[1,n],v∈(u,n]u\\in[1,n],v\\in(u,n]u∈[1,n],v∈(u,n]，计算左侧选取的匚的数量。于是现在只要求∑u=LR∑v=u+1R∑x=max⁡(l,Lu,mid,Lv,mid)mid−1[Du,x≥v]\\sum_{u=L}^R\\sum_{v=u+1}^R\\sum_{x=\\max(l,L_{u,mid},L_{v,mid})}^{mid-1}[D_{u,x}\\gev]u=L∑R​v=u+1∑R​x=max(l,Lu,mid​,Lv,mid​)∑mid−1​[Du,x​≥v]枚举完u,vu,vu,v后分类讨论max⁡(l,Lu,mid)\\max(l,L_{u,mid})max(l,Lu,mid​)和max⁡(l,Lv,mid)\\max(l,L_{v,mid})max(l,Lv,mid​)哪个更大，若前者更大，则对于所有uuu询问的区间已经固定，所以只要开一个桶记录Du,xD_{u,x}Du,x​的后缀个数和。如果是后者更大，就相当于求∑x=max⁡(l,Lv,mid)mid−1[Uv,x≤u]\\displaystyle\\sum_{x=\\max(l,L_{v,mid})}^{mid-1}[U_{v,x}\\leu]x=max(l,Lv,mid​)∑mid−1​[Uv,x​≤u]，处理方式和上面类似，开另一个桶记录Uv,xU_{v,x}Uv,x​的前缀个数和。这样就能单次O(1)O(1)O(1)解决。设len=r−l+1,LEN=R−L+1len=r-l+1,LEN=R-L+1len=r−l+1,LEN=R−L+1，这样单次的复杂度为O(LEN2+len×LEN)\\mathcalO(LEN^2+len\\timesLEN)O(LEN2+len×LEN)，由于分治时面积每次一定会减半，所以递归层数为O(log⁡2nm)\\mathcalO(\\log_2nm)O(log2​nm)。若能保证LEN≤lenLEN\\lelenLEN≤len则单次复杂度为O(len×LEN)\\mathcalO(len\\timesLEN)O(len×LEN)，此时总复杂度正确。每次递归后若LEN&gt;lenLEN&gt;lenLEN&gt;len则从[l,r][l,r][l,r]中间取中线变为从[L,R][L,R][L,R]中间取中线，复杂度为O(nmlog⁡2nm)\\mathcalO(nm\\log_2nm)O(nmlog2​nm)。frame多树问题和距离问题考虑点分治和点分树。点分树的性质：原树上u,vu,vu,v的路径会经过点分树上的LCA(u,v)LCA(u,v)LCA(u,v)，所以dis(x,y)=dis(x,LCA′(x,y))+dis(LCA′(x,y),y)dis(x,y)=dis(x,LCA&#x27;(x,y))+dis(LCA&#x27;(x,y),y)dis(x,y)=dis(x,LCA′(x,y))+dis(LCA′(x,y),y)，LCA′LCA&#x27;LCA′表示在点分树上的lca。◊\\Large{\\color{red}\\Diamond}◊考虑对第一棵树进行点分治，若当前分治中心为rtrtrt，已经处理过的点集为SSS，当前需要求uuu到SSS的答案。设iii以rtrtrt为根的深度为aia_iai​，则需要求min⁡v∈Sau+av+dis2(u,v)\\min_{v\\inS}a_u+a_v+dis_2(u,v)minv∈S​au​+av​+dis2​(u,v)，由点分治的性质可得\\min_{v\\inS}a_u+a_v+dis_2(u,v)=\\min_{v\\inS}a_u+a_v+dis_2(u,LCA_{2&#039;}(u,v))+dis_2(LCA_{2&#039;}(u,v),v)\\\\=\\min_{v\\inS,x=LCA_{2&#039;}(u,v)}(a_u+dis_2(u,x))+(a_v+dis_2(v,x))&amp;\\Large{\\color{red}\\Diamond}xxx为点分树上uuu和vvv的祖先，所以xxx只有O(log⁡2n)\\mathcalO(\\log_2n)O(log2​n)个，当将vvv加入SSS时，跳过vvv的每个祖先xxx并将av+dis2(v,x)a_v+dis_2(v,x)av​+dis2​(v,x)的贡献挂在xxx上，uuu查询时只要将挂在所有祖先的贡献加上au+dis2(u,x)a_u+dis_2(u,x)au​+dis2​(u,x)后求最大值即可，若u,vu,vu,v在xxx的同一颗子树内，则长度只会更大，不影响最小值更新。复杂度为O(nlog⁡2n)\\mathcalO(n\\log^2n)O(nlog2n)，瓶颈在点分治和在点分树上跳祖先。","link":"https://yaohaoyou.github.io/post/contest-solution/"},{"title":"PKUWC 2025","content":"Day0坐半天高铁到绍兴了，感谢黄连赞助的adofai，结果他自己没得玩。结果酒店没预定，等了10+min后换酒店了。见到了pyb和《我这里不是网吧》。话说为什么酒店公共网络什么都能上，但就是上不了qiu。和log住一间。外卖都没有什么好点的，最后点了推荐的，量挺多，但还挺贵。qiu自摸四暗刻极限翻盘，加大分，赛前溢满rp++Day1早上起床后参加开幕式，好像没什么，直到。。。有请GDFZwxp教练（choi此时上台领奖）。然后结束就飞奔去抢饭了，吃完学长都没打完，人多的比较逆天。12：20考场竟然不在学校里，去试机的路上发现THU好像都还在打，有点爽啊。13：00开题，才发现原来一共只有4h。14:00只会a=2a=2a=2和a&gt;b+1a&gt;b+1a&gt;b+1，暴力好像什么都跑不出来，要完蛋了。先开T2。14:30T2只会24pts，本以为很妙，结果好像就是暴力，不展开了。继续回去看T1。15:30继续手玩T1，暴力加上一点点优化后没想到快了超多，拿到了a,b≤4a,b\\le4a,b≤4。打表出来，好像原来手推的答案都错了，随便输出一组构造，结果发现直接将a+ba+ba+b个电池平均分成a−1a-1a−1组，抽屉原理得至少一组有至少222个好电池，直接每组暴力做就过了。前面全部想偏了，现在还不知道怎么证，但觉得非常不合常理。严厉批斗O(T)O(T)O(T)的题目数据范围是T,a,b≤1000T,a,b\\le1000T,a,b≤1000。看T2，好像会L=1L=1L=1，结果假了。看T3，好像会AB性质。写写写。写了40min+，过了样例，交，0pts。T3的A性质把DAG看成树了，白打了，唐！已经没什么时间了，好像暴力还不好打。T2T3反复横跳。最后10min，直接摆了，受不了一点。结果发现竟然有SublimeText，Day2可以用。100+24+0=124100+24+0=124100+24+0=124。出来了，ljq161，lgg&amp;lbs124。被yyx和本伟薄纱了。好像又垫底了。。。ljq母亲带我们去吃饭了，为什么绍兴菜都是辣、甜、咸啊。晚上好无聊啊，qiu都没什么意思了。等Day2翻盘？Day2上午听讲座讲AI。吃完饭，休息一下。提前10min到考场配sublime。开题，T1交互，T2疑似DP，T3小清新。2h30min还没拿分，感觉要爆了。T1胡了几个做法都错了（2次in是什么鬼？），T2的暴力怎么写都拿不了分，先开T3。T3写了暴力24，结果不太会B≤4B\\le4B≤4，应该可以暴力分讨，但是先去写前面吧。T2写了c=1c=1c=1。怎么不会T1，不切T1你切什么题，不切题你打什么比赛。但是这次是真不会。过一会发现原来早就会写n3n^3n3，直接写了。只剩30min，心态要爆了，T1好像没有一点非暴力做法。结束了。16+11+24=5116+11+24=5116+11+24=51。好多拿过约的都在磕T1。lgg会3n3n3n，ljq会4n4n4n，好像又是垫底，烦！log和我又是一个分。THU那边好像好一点，mlk终于金牌了，/bx/bx/bx。","link":"https://yaohaoyou.github.io/post/pkuwc2025/"},{"title":"GDOI2025 又记","content":"更爽的阅读体验前言马上回归综合了，所以就早点写了吧。。。前情提要NOIP排名都去到200+了，省选可能就走过场吧。。。Day-1晚上没要到体锻不爽。（原来NOIP前也没要到）。Day0早上10点出发去佛山，酒店有点偏，好像附近只有M吃。中午发现一群疑似旅游的大爷大妈来吃饭，场景还是太壮观了。试机发现竟然有vs+cph和cpeditor，从没打过这么富裕的仗，终于可以不用sublime了。Day1酒店早餐爆吃，所以比较早就去考场了。开T1，还比较可做，应该分情况讨论一下直接两次二分求区间就行了，感觉刚开始思路比较绕，所以写了O(nV)\\mathcalO(nV)O(nV)的，后面改了好久才写完O(nlog⁡2V)\\mathcalO(n\\log_2V)O(nlog2​V)。这唐题也是给我写了2h，有点急。T2n≤105n\\le10^5n≤1052GB+6s，一看就是bitset题，感觉比较能写。看了一会写了跑不满的O(n2ω+nq)\\mathcalO(\\frac{n^2}{\\omega}+nq)O(ωn2​+nq)当暴力，6×1046\\times10^46×104要跑9s左右，不知道能不能骗到分。又看了一下，发现B性质可以用DS做O(n2log⁡2nω)\\mathcalO(\\frac{n^2\\log_2n}\\omega)O(ωn2log2​n​)，因为空间要用树状数组，log⁡n\\lognlogn常数比较小，先写了，跑8×1048\\times10^48×104卡满都只要3s，非常爽。T3暴力，看了半天还是不会树。后面又回来看T2，会了AC，和B其实差不多，复杂度一样，但常数更大，先开写，此时只剩下15min。最后5min发现写错了一点，遂放弃，感觉比较可惜，但还是只能检查代码了。100+36+8=144100+36+8=144100+36+8=144。mlk会T352pts还是太恐怖了，其他人好像都差不多，yinhee（sana)切T2了，这也太有实力了。cyz怎么像generals一样丢代码了？祝好。又有聚餐。回酒店时思考为什么T2没有想过根号？？？下午好像都在晃晃晃。。。Day2开T1，部分分给的这么多，好像还比较可做。手玩一下发现直接按tit_iti​从小到大做不劣，剩下直接ds模拟整个过程就行了。想起来AT_abc371_f的线段树维护ai−ia_i-iai​−i的trick，剩下就上个线段树上二分就行了。一开始写错二分，但又把大样例过完了，改成单log发现了，也是rp++了。写完又花了差不多2h，吸取Day1经验，先不开拍了。后面两题计数，只会暴力，撤了。100+12+8=120100+12+8=120100+12+8=120。还是聚餐，但是可以直接回家了。Day3竟然还有周一放假！晚上回学校写了这篇游记。终于写完了。下雨了，比较伤感，NOIP后机房也少了许多面孔，特别是机位旁边的jx哥，感觉竞赛还是充满着遗憾。也不知道退役离我有多远，也许离开早已是命运。初中也快结束了，可能不甘和遗憾才是青春吧。但是还是舍不得大家啊。希望大家一直记得我。“希望大家永远忘了我。”Day¿云斗没挂，但也没反向挂，也挺好的。为什么D1T2乱搞可以拿巨量分数啊！","link":"https://yaohaoyou.github.io/post/GDOI2025/"},{"title":"NOIP 犹记","content":"更爽的阅读体验前言出分后再写邮寄是好习惯。前情提要这篇游记是在Day7写的，可能比较暴躁，讲究看吧。不要恶评，看到就删。Day0晚上没要到体锻不爽。Day16点多就起了，7：00出发去考场。要用Sublime，不爽。开T1，好答辩（满脑子循环播放：你不切T1你切什么题，你不切题你打什么比赛）。应该直接贪心是对的，但是也不确定。矛盾后终于开写了，1h左右一遍过大样例了，爽，上个厕所压压惊。T2应该不用矩阵快速幂，直接算就行了。30min写完，一遍过大样例，爽（伏笔才1.5h，放松许多。开始拼暴力，T3是什么鬼，跳了。T4应该是DS，想想想。不会一点，直接拼部分分。T3完全看不懂是在干什么，只会暴力，k=1k=1k=1都不会，rlfl。感觉后面一直在坐牢，连拍子都没上，部分分也不太会打（伏笔估分：100+100+12+36=248100+100+12+36=248100+100+12+36=248。出来了。不出意外，部分分打得太少了，T3好像很多都应该要会，真要学计数了。Day7早上信息会考。下午知道分了，洛谷上没挂分，爽！（伏笔1hlater......好像T2挂了30pts。真的服了，多写了一个=。依照惯例，下面放个代码。sort(a+1,a+n+1);for(inti=1;i&lt;=n;i++)if(a[i].fi==a[i+1].fi&amp;&amp;a[i].se!=a[i+1].se)returnputs(&quot;0&quot;),void();n=unique(a+1,a+n+1)-a-1;解释一下，因为有多测，而for循环中访问到了an+1a_{n+1}an+1​，所以有可能在上组多测中an+1.fi=a_{n+1.fi}=an+1.fi​=当前多测的an.fia_{n.fi}an.fi​，然后就多判了000。但是这概率不应该超级小吗，T≤10T\\le10T≤10能给我挂6个点，我#@!$!Y$!($&amp;(!&amp;)$!@&amp;$^&amp;@!$。但是为什么_log_的如果ans=0ans=0ans=0不为T组询问中的后缀就会错都能通过，CCF负众望。。。烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦听说misakaS组也有这个问题，但是CCF数据没挂。等正式分吧。upd：被骗了，只挂了151515。100+85+16+32=233100+85+16+32=233100+85+16+32=233。","link":"https://yaohaoyou.github.io/post/noip2024/"},{"title":"AT_arc187_d Many Easy Optimizations 题解","content":"题目传送器更爽的阅读体验前言怎么没有人写官方做法，set应该比线段树好写吧。题意给定长为nnn的序列a,ba,ba,b，对k∈[1,n]k\\in[1,n]k∈[1,n]求min⁡{max⁡i=1kci−min⁡i=1kci,ci=ai∨ci=bi}\\min\\{\\max_{i=1}^kc_i-\\min_{i=1}^kc_i,c_i=a_i\\veec_i=b_i\\}min{maxi=1k​ci​−mini=1k​ci​,ci​=ai​∨ci​=bi​}。做法开始也没什么信息，所以可以先钦定c1=a1∨c1=b1c_1=a_1\\veec_1=b_1c1​=a1​∨c1​=b1​。当c1c_1c1​固定后，可以分析出一些结论了。设ai≤bia_i\\leb_iai​≤bi​，若不是就交换一下，则变成在区间上取两个端点之一。对于ai≤bi≤c1a_i\\leb_i\\lec_1ai​≤bi​≤c1​，显然ci=bic_i=b_ici​=bi​是不劣的，同理，c1≤ai≤bic_1\\lea_i\\leb_ic1​≤ai​≤bi​，选择ci=aic_i=a_ici​=ai​是不劣的。当固定这些cic_ici​后，又可以固定更多的cjc_jcj​。形式化的，设LLL为当前固定的cic_ici​中的最小值，RRR为最大值，则满足剩下的ai&lt;L≤R&lt;bia_i&lt;L\\leR&lt;b_iai​&lt;L≤R&lt;bi​。接着考虑剩下的区间，若存在ai≤aj≤bj≤bia_i\\lea_j\\leb_j\\leb_iai​≤aj​≤bj​≤bi​，即存在包含关系时，iii所形成的极差一定不会比jjj的更小，所以jjj必然不会贡献答案，可以删除jjj。将最后剩下的区间设为l1≤⋯≤lm≤L≤R≤r1≤⋯≤rml_1\\le\\dots\\lel_m\\leL\\leR\\ler_1\\le\\dots\\ler_ml1​≤⋯≤lm​≤L≤R≤r1​≤⋯≤rm​，则答案为min⁡{min⁡i=1m−1(ri−li+1),L−l1,rm−R}\\min\\{\\min_{i=1}^{m-1}(r_i-l_{i+1}),L-l_1,r_m-R\\}min{mini=1m−1​(ri​−li+1​),L−l1​,rm​−R}。开一个set维护[li,ri][l_i,r_i][li​,ri​]和一个multiset维护(ri−li+1)(r_i-l_{i+1})(ri​−li+1​)。每次插入一个区间[ai,bi][a_i,b_i][ai​,bi​]时先检查set中是否存在[lj,rj][l_j,r_j][lj​,rj​]包含了[ai,bi][a_i,b_i][ai​,bi​]，若有则不用修改，否则再将所有被[ai,bi][a_i,b_i][ai​,bi​]包含的[lj,rj][l_j,r_j][lj​,rj​]从set中删除，最后类似于链表的插入，将[ai,bi][a_i,b_i][ai​,bi​]插入到set中，同时删除和插入时需要同步更新multiset中的答案集合。由于每个区间只会插入和删除一次，所以时间复杂度为O(n×log⁡2n)\\mathcal{O}(n\\times\\log_2n)O(n×log2​n)。实际上要跑1s左右，STL常数较大，但比较好写。Submission","link":"https://yaohaoyou.github.io/post/AT_arc187_d-solution/"},{"title":"CP duels记录","content":"CF1368ESkiAccidents比较神的构造，被对手10min秒了。看到47\\frac4774​和outi≤2out_i\\le2outi​≤2，然后就应该想到47=2220+21+22\\frac47=\\frac{2^2}{2^0+2^1+2^2}74​=20+21+2222​，尝试将nnn划分为333个集合。感觉比较结论，所以直接说了。将nnn划分成333个无交且并为全集的集合A,B,CA,B,CA,B,C，满足∀a∈A,{∀u→a,u∈C}\\foralla\\inA,\\{\\forallu\\rarra,u\\inC\\}∀a∈A,{∀u→a,u∈C}∀b∈B,{∃u→b,u∈A},{∃u→b,u∈B}\\forallb\\inB,\\{\\existu\\rarrb,u\\inA\\},\\{\\not\\existu\\rarrb,u\\inB\\}∀b∈B,{∃u→b,u∈A},{​∃u→b,u∈B}∀c∈C,{∃u→c,u∈B}\\forallc\\inC,\\{\\existu\\rarrc,u\\inB\\}∀c∈C,{∃u→c,u∈B}分类讨论一下，不难发现A,B,CA,B,CA,B,C交且并为全集。由于∀b∈B,∃a→b\\forallb\\inB,\\exista\\rarrb∀b∈B,∃a→b，∣B∣≤2∣A∣|B|\\le2|A|∣B∣≤2∣A∣，同理，∣B∣≤2∣C∣|B|\\le2|C|∣B∣≤2∣C∣，即4∣A∣≥2∣B∣≥∣C∣4|A|\\ge2|B|\\ge|C|4∣A∣≥2∣B∣≥∣C∣，∣C∣≤47n|C|\\le\\frac47n∣C∣≤74​n。删除CCC中的所有点后AAA的入度都是000，BBB的出度都是000，故最多只有a→ba\\rarrba→b的边，满足条件。因为是DAG，分集合时可以做拓扑排序。复杂度线性。","link":"https://yaohaoyou.github.io/post/cp-duels/"},{"title":"P10743 AND = OR 题解","content":"题目传送器更爽的阅读体验前言赛时想出的做法，结果过了一周才过，非常难写，常数还大，本文其实可以认为是做法的补充，只用到了一个性质。做法先分析一些性质。对于询问的区间[l,r][l,r][l,r]，将区间排序后，显然结果是一个前缀a1,a2...aka_1,a_2...a_ka1​,a2​...ak​的或和等于后缀ak+1,ak+2...ana_{k+1},a_{k+2}...a_nak+1​,ak+2​...an​的与和，因为或和的最小值为aka_kak​，与和的最大值为ak+1a_{k+1}ak+1​，ak≤ak+1a_k\\lea_{k+1}ak​≤ak+1​，所以两个部分一定可以不交，即形成一个前缀和后缀。设与和===或和=x=x=x。按位考虑，若xxx的第iii位为000，则分界点kkk满足[l,k][l,k][l,k]的第iii位都是000，且[k+1,r][k+1,r][k+1,r]中至少有一个000。若xxx的第iii位为111，则kkk满足[k+1,r][k+1,r][k+1,r]的第iii位都是111，[l,k][l,k][l,k]至少有一个111。第二条性质本质上就是说明，若第iii位为000，设第iii位的一个极长前缀[1,L][1,L][1,L]满足2，则k∈[1,L]k\\in[1,L]k∈[1,L]，若第iii为为111，设第iii位的一个极长后缀[R+1,n][R+1,n][R+1,n]满足2，则k∈[R+1,n]k\\in[R+1,n]k∈[R+1,n]。具体实现就是建一棵主席树，在主席树上二分得到满足以上要求的极长前缀和后缀，则最终的分界点kkk必然满足在每一位都在[1,Li][1,L_i][1,Li​]或[Ri+1,n][R_i+1,n][Ri​+1,n]区间中，即若满足∃k,k∈[1,Li]∪[Ri+1,n]\\existk,k\\in[1,L_i]\\cup[R_i+1,n]∃k,k∈[1,Li​]∪[Ri​+1,n]，则答案为YES，否则为NO。本质上就是对每个区间求交集。分析时间复杂度，对每一位做主席树上二分为O((q+n)×log⁡2V×log⁡2n)\\mathcal{O}((q+n)\\times\\log_2V\\times\\log_2n)O((q+n)×log2​V×log2​n)，求交集可以将每个区间先取反，再求并集是否为全集即可O(q×log⁡2V×log⁡2log⁡2V)\\mathcal{O}(q\\times\\log_2V\\times\\log_2\\log_2V)O(q×log2​V×log2​log2​V)。具体实现时，可以将询问离线，对每个位先求出qqq个询问的极长前后缀，最后求交集，这样可以将空间复杂度将为O(n×log⁡2n)\\mathcal{O}(n\\times\\log_2n)O(n×log2​n)，时间常数减小，再添加一些小剪枝就通过了。Code","link":"https://yaohaoyou.github.io/post/P10743-solution/"},{"title":"CF198E Gripping Story题解","content":"题目传送器更爽的阅读体验CF2400前言好题啊，但是为什么题解区没有单log做法。双倍经验做法首先不难想出O(n2)O(n^2)O(n2)的bfs做法。思考一个机械臂能抓住哪些新的机械臂，即dis(i)≤r∧mi≤pdis(i)\\ler\\landm_i\\lepdis(i)≤r∧mi​≤p的所有iii，这是一个较为明显的二维偏序，应该可以直接使用线段树套线段树优化建图解决（不知道会不会MLE）。回顾弹跳的Trick，对于一个点向一个坐标轴中的左下角矩阵连边，可以先使用排序后离线一维，再使用数据结构维护剩下一维。具体的，对每个机械臂按照mim_imi​排序，将dis(i)dis(i)dis(i)离散化后挂在线段树上。线段树上每个节点记录一个queue表示disidis_idisi​在当前区间的iii集合，由于提前按照mim_imi​排序了，所以当前队列中的mim_imi​是单调不减的。利用这一条性质就可以类似于双指针，每次队首加入bfs后退队，如果当前队首不满足mi≤pm_i\\lepmi​≤p则后面的必然也不满足。实现时queue的空间常数非常大，会直接MLE，可以使用vector并记录队头的位置。每个机械臂会在线段树中被加入O(log⁡2n)O(\\log_2n)O(log2​n)次，也只会被删除O(log⁡2n)O(\\log_2n)O(log2​n)次，所以时空复杂度都是O(n×log⁡2n)O(n\\times\\log_2n)O(n×log2​n)。ACCode","link":"https://yaohaoyou.github.io/post/CF198E-solution/"},{"title":"CSP2024 煤济","content":"更爽的阅读体验前言出分后再写邮寄是好习惯。Day0连续三天飞盘，爽完了。Day1上午打J，应该是最后一场了，弥补去年挂分的遗憾。初赛竟然AK了，直接尝试双AK（初赛+复赛）。T1会。T2会。T3会，上拍。T4不会。。我怎么不会？！#！@#！#！*&amp;@#%……@#rrr怎么这么小，不会有是分层图吧（怎么连续两年T4放分层图）。会了，写写写。写完，跑大样例，2s+。本地机子怎么这么慢！卡常，卡常。然后就卡了1.5h，比赛结束前15min卡过了，爽。出考场，lbw强完了，提前两小时AK，/bx/bx/bx。菇粉：100+100+100+100=400=smalljoker100+100+100+100=400=\\text{smalljoker}100+100+100+100=400=smalljoker。下午打S。早起拜锦鲤，rp++！开T1，会了！嗯？T1被秒了？CCF真是越来越会出题了。。。（伏笔）开T2，给一堆式子，这题充满单调性，第一问会了，上二分后求最少有多少个点被所有区间覆盖。这。。。思考一下很可做，AcSaber应该打过，但我都是贺的（后悔ing...）。然后就会了。写写写。卡卡卡。过大样例了，爽！稳一波，先写后面暴力，50+28拿下。这时还有1.5h左右，然后就迎来了全场最迷惑的操作。莫名其妙开始猜一波，T3超级困难，然后为了防止挂大分，然后就开始检查代码了？测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。测大样例，丢虚拟机。然后还剩40min，继续无视T3的存在，开始拍T2。写写写，拍拍拍。然后比赛结束都没拍问题，比较爽了。出考场，lbw薄纱我，T3怎么被切爆了？？？（CCF真是越来越会出题了，呼应）简单提一嘴我就会了，我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。我是唐龙。菇粉：100+100+50+28=278=bigjoker100+100+50+28=278=\\text{bigjoker}100+100+50+28=278=bigjoker。Day¿神秘途径获得J组的民间分数，怎么T4挂了第2个点，布什个门，CCF球球了。S组好像没有挂分。Day¿¿出分日。省流：13:00-&gt;16:00-&gt;17:30，CCF不愧是你。J：100+100+100+100=400=smalljoker100+100+100+100=400=\\text{smalljoker}100+100+100+100=400=smalljoker。双AK，双倍满足。S：100+100+50+28=278=bigjoker100+100+50+28=278=\\text{bigjoker}100+100+50+28=278=bigjoker。挂分了，但是CCF又挂回来了（不愧是你）。最后放一下S组T3的部分代码，多亏CCF神机，要不然就挂15pts了，我写的是O(n2)O(n^2)O(n2)，下面代码是O(n×maxn)O(n\\timesmaxn)O(n×maxn)的，不能写memset，要for循环清空。constintmaxn=2e5+10;lldp[2][maxn];for(inti=1;i&lt;=n;i++){mems(dp[i&amp;1],0);//DP转移}在线讨一手七级勾。","link":"https://yaohaoyou.github.io/post/csp2024/"},{"title":"P8180 「EZEC-11」Unmemorable 题解","content":"题目传送器更爽的阅读体验前言赛时会了，结果预处理忘优化了，大样例跑得飞快，O(n2)O(n^2)O(n2)假完甲烷了，喜提暴力分。题意自己看题面。做法先大眼暴力，观察结论（我也不会证明，但把表打出来后还比较明显）：rrr数组无用顺序正确的lll数组唯一先从大到小排序，对于当前值iii，放入第一个lj=0l_j=0lj​=0的位置，j&gt;ij&gt;ij&gt;i。形成最后的lll。对于第333点的观察，可以自己参考别的题解的做法，反正能确定lll数组即可。现在已经得到了lll数组了，rrr数组已经固定，有保证有解，所以算出多少个排列ppp满足lll的限制即可。其实做到这一步，就完全是这题了，接下来讲一讲具体的做法。对于当前数组能推出的信息很少，所以先从局部推结论。不难发现在当前lll数组中ppp最小的位置一定是当前最后一个li=0l_i=0li​=0的iii，证明可以设ak=min⁡i=1naia_k=\\min_{i=1}^na_iak​=mini=1n​ai​，因为是最小值，所以前面不会再有pk&lt;pip_k&lt;p_ipk​&lt;pi​，故lkl_klk​一定是000，最后一个lk=0l_k=0lk​=0一定会满足前面的∀lj=0,pk&lt;pj\\foralll_j=0,p_k&lt;p_j∀lj​=0,pk​&lt;pj​。推出当前序列的最小值后，序列就又分成了两个独立的区间，因为保证有解，所以∀j&gt;k,pj≥k\\forallj&gt;k,p_j\\gek∀j&gt;k,pj​≥k，将i∈[k+1,n]i\\in[k+1,n]i∈[k+1,n]的li←li−kl_i\\getsl_i-kli​←li​−k后，后面的部分就与前面独立了。接下来就类似于分治的做法，将当前区间分成两段，递归求解。设当前区间为[L,R][L,R][L,R]，这个区间的最小值已经确定，从剩下的R−LR-LR−L个数中选取k−Lk-Lk−L个数作为左边区间，剩下就是右边区间，所以要再乘上(R−Lk−L)\\binom{R-L}{k-L}(k−LR−L​)。形式化的，设f(L,R)f(L,R)f(L,R)为区间[L,R][L,R][L,R]的分配方案数（数的集合已经固定，相当于离散化后的方案数）。f(L,R)={1L&gt;Rf(L,k−1)×f(k+1,R)×(R−Lk−L)L&lt;=Rf(L,R)=\\begin{cases}1&amp;L&gt;R\\\\f(L,k-1)\\timesf(k+1,R)\\times\\binom{R-L}{k-L}&amp;L&lt;=R\\end{cases}f(L,R)={1f(L,k−1)×f(k+1,R)×(k−LR−L​)​L&gt;RL&lt;=R​想到这里就完成了，实现并不难。注意lkl_klk​是区间最小值，但并不一定是midmidmid，所以直接做不是O(n×log⁡2n)O(n\\times\\log_2n)O(n×log2​n)的，而是卡不满的O(n2)O(n^2)O(n2)。可以使用st表或线段树做rmq。本题空间要求线性，于是只能使用线段树，复杂度为O(n×log⁡2n)O(n\\times\\log_2n)O(n×log2​n)。Code递归求fff的主要代码如下：voiddfs(intl,intr){if(l&gt;r)return;intx=-query(all,l,r).se;//区间最小值的位置mmul(ans,C(r-l,x-l));dfs(l,x-1);dfs(x+1,r);}完整代码","link":"https://yaohaoyou.github.io/post/P8180-solution/"},{"title":"AtCoder 做题记录","content":"AtCoderRegularContest186AmodMGame2Difficulty：1042唐完了，不会做打表（大便）题，1≤n×(n−1)2modm≤n1\\le\\frac{n\\times(n-1)}2\\modm\\len1≤2n×(n−1)​modm≤n时Bob，否则Alice。B+1and-1Difficulty：1332我都能场最后数列的状态固定，从前往后模拟，前面有多的就留个tag。EAdjacentGCDDifficulty：2185欧拉函数，数论欧拉函数反演n=\\sum_{d|n}\\varphi(d)\\\\\\gcd(a,b)=\\sum_{d|\\gcd(a,b)}\\varphi(d)=\\sum_{d|a\\andd|b}\\varphi(d)对于本题，每次加入一个aia_iai​后，新增ans+∑j=1i−1gcd⁡(aj,ai)×2j−1ans+\\sum_{j=1}^{i-1}\\gcd(a_j,a_i)\\times2^{j-1}ans+∑j=1i−1​gcd(aj​,ai​)×2j−1的贡献。由于gcd⁡\\gcdgcd的其中一项确定，则可以枚举aia_iai​的因数ddd，添加sumd×φ(d)sum_d\\times\\varphi(d)sumd​×φ(d)的贡献。最后对于每个因数ddd，sumd+=2i−1sum_d+=2^{i-1}sumd​+=2i−1即可。DRandomWalkonTreeDifficulty：2649推式子，期望就是走完nnn条长度为mmm的链。走完一条链的充要条件是走到叶子节点，钦定dep0=0dep_0=0dep0​=0。定义有效点为之前没别走过的点。fif_ifi​表示从深度为iii的有效点走到i+1i+1i+1的有效点期望步数。fi=12+1+fi−1+fi2fi=2+fi−1f_{i}=\\frac12+\\frac{1+f_{i-1}+f_{i}}2\\\\f_i=2+f_{i-1}fi​=21​+21+fi−1​+fi​​fi​=2+fi−1​即有12\\frac1221​的概率直接走到，和先往i−1i-1i−1走再走回来，再到i+1i+1i+1的步数期望。初始化f0f_0f0​与当前有多少条已经走完的链相关，并且如果走到了无效点还要走回来。设可以走到的有效点数为kkk，pip_ipi​表示从深度为iii的点走到i−1i-1i−1的步数期望。ppp实际上在链上走的情况和fff相同，故pi=2+pi+1p_i=2+p_{i+1}pi​=2+pi+1​，初始化pm=1p_m=1pm​=1。f0=kn+(1−kn)×(1+p1+f0)f0=n+(n−k)×p1if_0=\\frac{k}{n}+(1-\\frac{k}{n})\\times(1+p_1+f_0)\\\\f_0=\\frac{n+(n-k)\\timesp_1}if0​=nk​+(1−nk​)×(1+p1​+f0​)f0​=in+(n−k)×p1​​先计算从n−1n-1n−1个叶子回到000号点的贡献，即为(n−1)×∑i=1mpi(n-1)\\times\\sum_{i=1}^mp_i(n−1)×∑i=1m​pi​。再计算从000号点到dep=1dep=1dep=1的有效点后再到叶子节点的贡献和，即为∑i=1n∑j=1mfj\\sum_{i=1}^n\\sum_{j=1}^mf_j∑i=1n​∑j=1m​fj​，时间复杂度为O(n2)O(n^2)O(n2)（注：每次fjf_jfj​都需要重新计算，因为f0f_0f0​的值会变）。观察到fi=2+fi−1f_i=2+f_{i-1}fi​=2+fi−1​的式子非常简单，甚至是等差数列，可以得到通项公式fi=f0+2×(i−1)f_i=f_0+2\\times(i-1)fi​=f0​+2×(i−1)，故∑i=1mfi=∑i=1m(f0+2×(i−1))=m×f0+m×(m−1)\\sum_{i=1}^mf_i=\\sum_{i=1}^m(f_0+2\\times(i-1))=m\\timesf_0+m\\times(m-1)i=1∑m​fi​=i=1∑m​(f0​+2×(i−1))=m×f0​+m×(m−1)优化后就可以O(1)O(1)O(1)求出f0f_0f0​和∑fi\\sumf_i∑fi​了，复杂度为O(nlog⁡2n)O(n\\log_2n)O(nlog2​n)，使用预处理逆元做到O(n)O(n)O(n)，但是我懒了。Codep[m]=1;for(inti=m-1;i;i--)p[i]=imadd(p[i+1],2);intinvn=qpow(n,mod-2);intans=0,sum=0;for(inti=1;i&lt;=m;i++)madd(ans,p[i]);mmul(ans,n-1);for(inti=1;i&lt;=n;i++){intf0=immul(imadd(n,immul(n-i,p[1])),qpow(i,mod-2));madd(ans,immul(m,f0));madd(ans,immul(m,m-1));}AtCoderRegularContest186BTypicalPermutationDescriptorDifficulty：1677赛时差一点写完的计数，唐不难得出当前序列中ppp最小的数的位置，然后从这一点断开后形成两个新区间，两个区间相互独立，只要×(r−lp−l)\\times\\binom{r-l}{p-l}×(p−lr−l​)将数划分到两个区间即可。CBallandBoxDifficulty：2451贪心，博弈按容量从小到大排序，相同容量花费从大到小。最后的状态一定形如ViV_iVi​最大的m−1m-1m−1个会只获得111的贡献，剩余获得ViV_iVi​的贡献，即s=∑i=1k−m+1Vi+m−1−∑i=1kPis=\\sum_{i=1}^{k-m+1}V_i+m-1-\\sum_{i=1}^kP_is=∑i=1k−m+1​Vi​+m−1−∑i=1k​Pi​。对后缀用大根堆维护最小的m−1m-1m−1个ViV_iVi​作为所选的数中最大的m−1m-1m−1个，剩余的选取所有[1,i−1][1,i-1][1,i−1]中(Vi−Pi)(V_i-P_i)(Vi​−Pi​)为正的，求和即可。AUndercluedDifficulty：2511性质，转化好困难。看到01矩阵，尝试给二分图定向。当ai,j=0a_{i,j}=0ai,j​=0时，Li↔RjL_i\\leftrightarrowR_jLi​↔Rj​，当ai,j=1a_{i,j}=1ai,j​=1时，Ri↔LjR_i\\leftrightarrowL_jRi​↔Lj​，则两个矩阵相似即为对于每个点在两个图中的出入度相同。原矩阵上(i,j)(i,j)(i,j)是不动点，当且仅当在二分图中改变图的形态但出入度不变时，上面连的边不变。考虑变一条边的方向后，会继续影响别的点，知道绕回原点，即形成一个简单环后才会结束，则不动点即为二分图上不在简单环上的边。转化后就不困难了，设dpi,j,kdp_{i,j,k}dpi,j,k​表示左部点前iii个点和右部点前jjj个点，形成的环能否覆盖恰好kkk条边。枚举左部点新加uuu个点，右部点新加vvv个点，且这些点形成一个强连通分量。新覆盖成了u×vu\\timesvu×v条边，即uuu个左部点都会和vvv个右部点的连边一一被覆盖。因为是可行性dp，转移可以用bitset，时间复杂度降为O(n6ω)\\mathcalO(\\frac{n^6}\\omega)O(ωn6​)，但不用也能过。AtCoderRegularContest187DManyEasyOptimizationsDifficulty：2880here","link":"https://yaohaoyou.github.io/post/atcoder-solution/"},{"title":"光速幂学习笔记","content":"多次询问axmodpa^x\\bmodpaxmodp。选定一个数BBB，预处理出aimodp,i∈[0,B)a^i\\bmodp,i\\in[0,B)aimodp,i∈[0,B)和ai×Bmodp,i∈[1,(p−1)B)a^{i\\timesB}\\bmodp,i\\in[1,\\frac{(p-1)}B)ai×Bmodp,i∈[1,B(p−1)​)，询问时axmodp=a⌊xB⌋×axmodBmodpa^x\\bmodp=a^{\\lfloor\\fracxB\\rfloor}\\timesa^{x\\bmodB}\\bmodpaxmodp=a⌊Bx​⌋×axmodBmodp，取B=pB=\\sqrtpB=p​时可以做到O(p)−O(1)O(\\sqrtp)-O(1)O(p​)−O(1)快速幂。然而O(p)O(\\sqrtp)O(p​)可能还是太慢了，实际上可以做到取一个BBB，复杂度为O(log⁡Bp×B)−O(log⁡Bp)O(\\log_Bp\\timesB)-O(\\log_Bp)O(logB​p×B)−O(logB​p)，后面的log⁡Bp\\log_BplogB​p基本就只是常数了，可以按需求平衡复杂度，其实不太好理解，下面放一份B=32B=32B=32的代码，这应该是比较优的块长了，常数较小。inlinevoidinit(intx){Pow[0][0]=Pow[1][0]=Pow[2][0]=Pow[3][0]=Pow[4][0]=Pow[5][0]=1;for(inti=1;i&lt;S;i++)Pow[0][i]=Pow[0][i-1]*x%mod;intb=immul(Pow[0][S-1],x);for(inti=1;i&lt;S;i++)Pow[1][i]=Pow[1][i-1]*b%mod;b=immul(Pow[1][S-1],b);for(inti=1;i&lt;S;i++)Pow[2][i]=Pow[2][i-1]*b%mod;b=immul(Pow[2][S-1],b);for(inti=1;i&lt;S;i++)Pow[3][i]=Pow[3][i-1]*b%mod;b=immul(Pow[3][S-1],b);for(inti=1;i&lt;S;i++)Pow[4][i]=Pow[4][i-1]*b%mod;b=immul(Pow[4][S-1],b);for(inti=1;i&lt;S;i++)Pow[5][i]=Pow[5][i-1]*b%mod;}inlineintqpow(inty){returnPow[5][(y&gt;&gt;25)]*Pow[4][(y&gt;&gt;20)&amp;(S-1)]%mod*Pow[3][(y&gt;&gt;15)&amp;(S-1)]%mod*Pow[2][(y&gt;&gt;10)&amp;(S-1)]%mod*Pow[1][(y&gt;&gt;5)&amp;(S-1)]%mod*Pow[0][y&amp;(S-1)]%mod;}}POW;实测尽量添加#pragmaunroll(4)实现并行，Pow可以开longlong避免多次int强转。完整代码","link":"https://yaohaoyou.github.io/post/FastPow/"},{"title":"CF1995D Cases 题解","content":"题目传送器更爽的阅读体验CF2300前言我菜了，不会SOSDP，是学习其他题解的做法。题意自己去看翻译。做法SOSDP好题。因为每个子串长度不超过kkk，所以每kkk个位就会有至少一个位是子串的末尾，共有n−k+1n-k+1n−k+1个这样的区间，所以充要条件就是末尾字符构成的集合与n−k−1n-k-1n−k−1个区间构成的集合都有交。形象化来说，Si={c∣c∈s[i,i+k−1]}S_i=\\{c|c\\ins[i,i+k-1]\\}Si​={c∣c∈s[i,i+k−1]}，TTT为每个子串末尾字符组成的集合，∀Si,Si∩T=∅\\forallS_i,S_i\\capT\\not=\\empty∀Si​,Si​∩T​=∅，求∣T∣min⁡|T|_{\\min}∣T∣min​。考虑SOSDP，先预处理出每个SiS_iSi​，再使用子集DP转移。由于要记录当前状态是否与SiS_iSi​有交，时间和空间复杂度均为为O(2c×n)O(2^c\\timesn)O(2c×n)，即使用bitset优化，空间依旧开不下，所以考虑正难则反。上述方法空间较大的主要原因是难以维护当前状态与哪些SiS_iSi​有交，因为这个状态就已经是O(n)O(n)O(n)的。考虑维护当前状态是否与任意一个SiS_iSi​都无交，对于每个状态就只要O(1)O(1)O(1)的空间了，对于和每个SiS_iSi​都不是无交的状态，即和每个SiS_iSi​都有交的状态，就可以成为TTT。具体实现就是预处理出stai={c∣c∉[s,i,i+k−1}sta_i=\\{c|c\\notin[s,i,i+k-1\\}stai​={c∣c∈/​[s,i,i+k−1}，则staista_istai​的任意一个子集都与sis_isi​无交，暴力枚举子集需要O(3c)O(3^c)O(3c)，使用SOSDP转移将复杂度将为O(c×2c)O(c\\times2^c)O(c×2c)，到最后dp值为000的状态就代表与任意sis_isi​都有交，可以成为∣T∣|T|∣T∣，更新答案即可。ACCode","link":"https://yaohaoyou.github.io/post/CF1995D-solution/"},{"title":"P4593 [TJOI2018] 教科书般的亵渎 题解","content":"题目传送器更爽的阅读体验前言太笨了，不会拆贡献，所以复杂度比较劣。题意给定操作A和操作B。定义操作A是将xi←xi−1(xi&gt;0)x_i\\getsx_i-1(x_i&gt;0)xi​←xi​−1(xi​&gt;0)并获得∑xik\\sumx_i^k∑xik​分数，xix_ixi​是第iii个怪物扣血前的血量，kkk是总操作B次数。如果一次操作后会有新的xi=0x_i=0xi​=0，则继续进行操作A。定义操作B是当此时没有新的xi=0x_i=0xi​=0，进行一次操作A。给定集合S={x∈[1,n]∧x∉a}S=\\{x\\in[1,n]\\wedgex\\notina\\}S={x∈[1,n]∧x∈/​a}表示怪物血量所构成的集合，求最后的总分数。做法kkk是好算的。将SSS拆成一段段连续的区间分别考虑，一段连续的区间必定是在同一次操作B中扣为000。设当前处理的血量区间为[li,ri][l_i,r_i][li​,ri​]，对于j≥ij\\geij≥i的区间当前血量为[lj,rj][l_j,r_j][lj​,rj​]，则当前的贡献∑j=im+1∑x=ljrj∑y=x−li+1xyk\\sum_{j=i}^{m+1}\\sum_{x=l_j}^{r_j}\\sum_{y=x-l_i+1}^{x}y^k∑j=im+1​∑x=lj​rj​​∑y=x−li​+1x​yk。直接计算是O(Tm2n2)O(Tm^2n^2)O(Tm2n2)，这里放一份代码。思考如何优化计算∑x=ljrj∑y=x−li+1xyk\\sum_{x=l_j}^{r_j}\\sum_{y=x-l_i+1}^{x}y^k∑x=lj​rj​​∑y=x−li​+1x​yk，设f(x)=∑i=1xix,g(x,len)=∑i=1x(f(i)−f(i−len))f(x)=\\sum_{i=1}^xi^x,g(x,len)=\\sum_{i=1}^x(f(i)-f(i-len))f(x)=∑i=1x​ix,g(x,len)=∑i=1x​(f(i)−f(i−len))，则ans=∑i=1m+1∑j=im+1g(rj,li)−g(lj−1,li)ans=\\sum_{i=1}^{m+1}\\sum_{j=i}^{m+1}g(r_j,l_i)-g(l_j-1,l_i)ans=∑i=1m+1​∑j=im+1​g(rj​,li​)−g(lj​−1,li​)。可以先使用一次拉格朗日插值O(m)O(m)O(m)算出f(x)f(x)f(x)，进而再使用一次拉格朗日插值O(m2)O(m^2)O(m2)算出g(x)g(x)g(x)。总时间复杂度为O(T×m4)O(T\\timesm^4)O(T×m4)，需要轻微卡常。ACCode","link":"https://yaohaoyou.github.io/post/p4593-solution/"},{"title":"2024.8.12 树专题分享","content":"T1原题：CF1399E2WeightsDivision(hardversion)\\color{#ffffff}\\text{CF1399E2WeightsDivision(hardversion)}CF1399E2WeightsDivision(hardversion)CF2200\\color{#ffffff}\\text{CF2200}CF2200题意给你一棵以111为根的香蕉树，每条边有边权wiw_iwi​和花费cic_ici​。每个叶子节点都有一只liangbowen，他们都想去111节点吃香蕉。但是liangbowen们急着去杀戮，所以需要保证∑uisliangbowenw(1,u)≤lim\\sum_\\text{uisliangbowen}w(1,u)\\lelim∑uisliangbowen​w(1,u)≤lim，uisliangbowen\\text{uisliangbowen}uisliangbowen当且仅当uuu是叶子节点，w(x,y)w(x,y)w(x,y)表示xxx到yyy的树上距离。lubenwei可以开挂，将wi←⌊wi2⌋w_i\\gets\\lfloor\\dfrac{w_i}{2}\\rfloorwi​←⌊2wi​​⌋，吸引网管cic_ici​点注意。lubenwei不希望开挂太多导致被网管封号，所以请最小化网管的注意使得liangbowen们可以准时杀戮，保证有解。n≤105,ci∈{1,2},1≤wi≤106,1≤lim≤1016n\\le10^5,c_i\\in\\{1,2\\},1\\lew_i\\le10^6,1\\lelim\\le10^{16}n≤105,ci​∈{1,2},1≤wi​≤106,1≤lim≤1016。形式化题意：\\tiny\\text{形式化题意：}形式化题意：给出一个结点数量为nnn的边带权的有根树，树的根结点为111。你可以进行以下操作。选定任意一条权值为wiw_iwi​的边，使wi←⌊wi2⌋w_i\\gets\\lfloor\\frac{w_i}{2}\\rfloorwi​←⌊2wi​​⌋，花费为cic_ici​且ci∈{1,2}c_i\\in\\{1,2\\}ci​∈{1,2}。你需要回答最小的花费，使得∑v∈leavesw(1,v)≤S\\sum\\limits_{v\\inleaves}w(1,v)\\leqSv∈leaves∑​w(1,v)≤S。EasyVersion：ci=1c_i=1ci​=1。题解先考虑EasyVersion，由于保证ci=1c_i=1ci​=1，所以直接贪心即可。首先可以用树形DP求出删掉当前边的贡献，设dpidp_idpi​表示iii的子树中有多少个叶子节点，不难得出dpu={∑dpsonu≠leaf1u=leafdp_u=\\begin{cases}\\sumdp_{son}&amp;u\\neleaf\\\\1&amp;u=leaf\\end{cases}dpu​={∑dpson​1​u​=leafu=leaf​。设一条边的贡献为sis_isi​，儿子为vvv，则si=dpv×(wi−⌊wi2⌋)s_i=dp_v\\times(w_i-\\lfloor\\frac{w_i}{2}\\rfloor)si​=dpv​×(wi​−⌊2wi​​⌋)。将sis_isi​丢进大根堆，每次取出sis_isi​最大的边模拟进行操作即可。再回到HardVersion。错的做法此时还想贪心就变得非常困难，所以可以思考将答案划分成选择边权花费为111的答案+++选择边权花费为222的答案。当只选择边权花费为111的答案时，可以确定操作的顺序（即EasyVersion），同理，只选择边权花费为222的答案也可以提前处理操作顺序。然后只要枚举要操作花费为111的次数，并计算花费为222的次数即可。此时的时间复杂度为O(n2×log⁡2n)O(n^2\\times\\log_2n)O(n2×log2​n)，无法通过此题。观察性质，发现操作花费为111的次数越多，操作花费为222的次数就越少。所以可以将计算花费为222的次数用双指针优化掉，时间复杂度为O(n×log⁡2n)O(n\\times\\log_2n)O(n×log2​n)，记得处理操作全是花费为111和222的答案。code\\color{white}codecodeT2原题：CF1059ESplittheTree\\color{#ffffff}\\text{CF1059ESplittheTree}CF1059ESplittheTreeCF2400\\color{#ffffff}\\text{CF2400}CF2400题意lbw和Mathew正在宿舍打21点，但是他把牌摆成了一棵树的形状。规则就是在树上找一条深度依次递增的链，使得链上扑克牌的点数和≤21\\le21≤21。同时还有一种规则叫做五龙，就是当你取得555张牌时，游戏就结束了。但是lbw想要练习出千，于是把21点变成LLL点，把555龙变成SSS龙，把扑克牌点数的集合变成自然数集。lbw有透视眼，可以提前看到每个节点的牌的点。lbw用最短的时间秒杀Mathew，所以希望总局数最少。请求lbw最少选出多少条链可以使得每张牌刚好被拿走一次，且牌数≤L\\leL≤L，点数和≤S\\leS≤S，需要判无解。n≤105,L≤105,S≤1018n\\le10^5,L\\le10^5,S\\le10^{18}n≤105,L≤105,S≤1018。形式化题意：\\tiny\\text{形式化题意：}形式化题意：给一棵带点权的树，每次选一条深度依次递增的链，链长≤L\\leL≤L，链上点权和≤S\\leS≤S。想让每个点当且仅当被覆盖一次，求链数最小值，需要判无解。题解显然，当有一个点的点权&gt;S&gt;S&gt;S时就无解，否则有解。考虑一个贪心结论，对于uuu和uuu的儿子vvv，显然从uuu往上能到达的点会比vvv往上到达的点更高或相同，所以节点uuu一定会选择剩余步数最多的儿子节点进行转移。可以先使用树上倍增求出每个节点uuu能到达的最高祖先，计upuup_uupu​表示从uuu节点最多再往上跳upuup_uupu​步。考虑树形DP。设fuf_ufu​表示将uuu的子树覆盖完的链的最少条数，gug_ugu​表示uuu的子树内剩余的最大步数。gu=max⁡vissonofu(gv−1)fu=∑vissonofufvg_u=\\max_\\text{vissonofu}(g_v-1)\\\\f_u=\\sum_\\text{vissonofu}f_vgu​=vissonofumax​(gv​−1)fu​=vissonofu∑​fv​若此时gu=0g_u=0gu​=0，说明无法从子树内已有的链往上延申，所以需要开一条新链，即fu++,gu=upuf_u++,g_u=up_ufu​++,gu​=upu​。否则不需要进行修改。钦定树的根为111，则答案为f1f_1f1​。code\\color{white}codecode","link":"https://yaohaoyou.github.io/post/2024.8.11 trees/"},{"title":"数学学习笔记","content":"狄利克雷卷积Dirichlet定义：其本质是一种运算，可以用∗*∗表示。h(x)=f(x)∗g(x)=∑d∣xf(d)g(xd)=∑ab=xf(a)g(b)h(x)=f(x)*g(x)=\\sum_{d|x}f(d)g(\\frac{x}{d})=\\sum_{ab=x}f(a)g(b)h(x)=f(x)∗g(x)=d∣x∑​f(d)g(dx​)=ab=x∑​f(a)g(b)积性函数f(x)f(x)f(x)满足∀(a,b)=1,f(ab)=f(a)f(b)\\forall(a,b)=1,f(ab)=f(a)f(b)∀(a,b)=1,f(ab)=f(a)f(b)。完全积性函数f(x)f(x)f(x)满足f(ab)=f(a)f(b)f(ab)=f(a)f(b)f(ab)=f(a)f(b)。可以使用线性筛算出积性函数。性质：交换律：f∗g=g∗ff*g=g*ff∗g=g∗f。结合律：(f∗g)∗h=f∗(g∗h)(f*g)*h=f*(g*h)(f∗g)∗h=f∗(g∗h)。分配律：(f+g)∗h=f∗h+g∗h(f+g)*h=f*h+g*h(f+g)∗h=f∗h+g∗h。若fff和ggg是积性函数，则f∗gf*gf∗g也是积性函数。若fff是积性函数，则fff的逆元也是积性函数。逆元：单位函数ε\\varepsilonε，f∗ε=ff*\\varepsilon=ff∗ε=f。若ggg满足f∗g=εf*g=\\varepsilonf∗g=ε，则称g(x)g(x)g(x)是f(x)f(x)f(x)的逆元。逆元唯一。ps：目前还不太懂这是什么，但好像可以理解为ε(n)={1n=10n=1\\varepsilon(n)=\\begin{cases}1&amp;n=1\\\\0&amp;n\\not=1\\end{cases}ε(n)={10​n=1n​=1​。g(x)=ε(x)−∑d∣x,d=1f(d)f(xd)1g(x)=\\dfrac{\\varepsilon(x)-\\sum_{d|x,d\\not=1}f(d)f(\\dfrac{x}{d})}{1}g(x)=1ε(x)−∑d∣x,d​=1​f(d)f(dx​)​莫比乌斯函数Möbius定义式：n=p1a1p2a2...pkakμ(n)={1n=10∃i≤k,ai&gt;1(−1)kelsen=p_1^{a_1}p_2^{a_2}...p_k^{a_k}\\\\\\mu(n)=\\begin{cases}1&amp;n=1\\\\0&amp;\\existi\\lek,a_i&gt;1\\\\(-1)^k&amp;else\\end{cases}n=p1a1​​p2a2​​...pkak​​μ(n)=⎩⎪⎨⎪⎧​10(−1)k​n=1∃i≤k,ai​&gt;1else​性质：μ(x)\\mu(x)μ(x)是积性函数。∑d∣nμ(d)={1n=10n=1\\sum_{d|n}\\mu(d)=\\begin{cases}1&amp;n=1\\\\0&amp;n\\not=1\\end{cases}d∣n∑​μ(d)={10​n=1n​=1​即∑d∣nμ(d)=ε(n),μ∗1=ε\\sum_{d|n}\\mu(d)=\\varepsilon(n),\\mu*1=\\varepsilon∑d∣n​μ(d)=ε(n),μ∗1=ε。在狄利克雷卷积中，莫比乌斯函数是常数函数111的逆元。证明n=p1a1p2a2...pkak,n′=p1p2...pk∵μ(k×a2)=0∴∑d∣nμ(d)=∑d∣n′μ(d)n=p_1^{a_1}p_2^{a_2}...p_k^{a_k},n&#x27;=p_1p_2...p_k\\\\\\because\\mu(k\\timesa^2)=0\\\\\\therefore\\sum_{d|n}\\mu(d)=\\sum_{d|n&#x27;}\\mu(d)n=p1a1​​p2a2​​...pkak​​,n′=p1​p2​...pk​∵μ(k×a2)=0∴d∣n∑​μ(d)=d∣n′∑​μ(d)则现在就是尝试在kkk个互异质数中选择一个集合，若集合大小为奇数，答案-1，否则答案+1。k&gt;1k&gt;1k&gt;1时，∑d∣n′μ(d)=∑i=0k(ki)×(−1)i\\sum_{d|n&#x27;}\\mu(d)=\\sum_{i=0}^k\\binom{k}{i}\\times(-1)^i∑d∣n′​μ(d)=∑i=0k​(ik​)×(−1)i。二项式定理是(a+b)n=∑i=0n(ni)aibn−i(a+b)^n=\\sum_{i=0}^n\\binom{n}{i}a^ib^{n-i}(a+b)n=∑i=0n​(in​)aibn−i，将a=−1,b=1a=-1,b=1a=−1,b=1带入则是(1+(−1))n=∑i=0n(ni)×(−1)i=0(1+(-1))^n=\\sum_{i=0}^n\\binom{n}{i}\\times(-1)^i=0(1+(−1))n=∑i=0n​(in​)×(−1)i=0。故k&gt;1k&gt;1k&gt;1时，∑d∣nμ(d)=0\\sum_{d|n}\\mu(d)=0∑d∣n​μ(d)=0。剩下情况不难自证。ps：以上证明只是本人在初学时的结论，不保证正确，等待未来的我修改或确认。反演结论：[gcd⁡(i,j)=1]=∑d∣gcd⁡(i,j)μ(d)[\\gcd(i,j)=1]=\\sum_{d|\\gcd(i,j)}\\mu(d)[gcd(i,j)=1]=d∣gcd(i,j)∑​μ(d)还不会用。。。阶定义由欧拉定理可知，(a,m)=1(a,m)=1(a,m)=1，aφ(m)≡1(modm)a^{\\varphi(m)}\\equiv1(\\bmodm)aφ(m)≡1(modm)。故存在最小正整数满足an≡1(modm)a^n\\equiv1(\\bmodm)an≡1(modm)，称nnn为aaa模mmm的阶，记作ord⁡m(a)\\operatorname{ord}_m(a)ordm​(a)。性质a,a2...aord⁡m(a)a,a^2...a^{\\operatorname{ord}_m(a)}a,a2...aordm​(a)模mmm两两不同余。若ap≡aq(modm)a^p\\equiva^q(\\bmodm)ap≡aq(modm)，则p≡q(modord⁡m(a))p\\equivq(\\bmod\\operatorname{ord}_m(a))p≡q(modordm​(a))。(a,m)=(b,m)=1ord⁡m(ab)=ord⁡m(a)ord⁡m(b)⇔gcd(ord⁡m(a),ord⁡m(b))=1(a,m)=(b,m)=1\\\\\\operatorname{ord}_m(ab)=\\operatorname{ord}_m(a)\\operatorname{ord}_m(b)\\Leftrightarrowgcd(\\operatorname{ord}_m(a),\\operatorname{ord}_m(b))=1(a,m)=(b,m)=1ordm​(ab)=ordm​(a)ordm​(b)⇔gcd(ordm​(a),ordm​(b))=1原根primitive-root定义若(g,m)=1(g,m)=1(g,m)=1，且ord⁡m(g)=φ(m)\\operatorname{ord}_m(g)=\\varphi(m)ordm​(g)=φ(m)，则称ggg为模mmm的原根。性质对于m≥3,(g,m)=1m\\ge3,(g,m)=1m≥3,(g,m)=1，则ggg是模mmm的原根⇔\\Leftrightarrow⇔对于φ(m)\\varphi(m)φ(m)的每个质因子ppp，都有gφ(m)p≡1(modm)g^{\\frac{\\varphi(m)}{p}}\\not\\equiv1(\\bmodm)gpφ(m)​​≡1(modm)。若mmm有原根，则原根个数为φ(φ(m))\\varphi(\\varphi(m))φ(φ(m))。原根存在定理：一个数mmm存在原根当且仅当m=2,4,pa,2pam=2,4,p^a,2p^am=2,4,pa,2pa，ppp为奇质数。aaa的最小原根大约在a14a^{\\frac{1}{4}}a41​。","link":"https://yaohaoyou.github.io/post/maths/"},{"title":"P10637 BZOJ4262 Sum","content":"题目传送器更爽的阅读体验前言我什么也不会，不知道为什么_maojun_要感谢我。但是我要感谢_maojun_提供思路。题意给出随机的数列aaa，求∑l∈[l1,r1]∑r∈[l2,r2](max⁡i∈[l,r]ai−min⁡i∈[l,r]ai)\\sum_{l\\in[l_1,r_1]}\\sum_{r\\in[l_2,r_2]}(\\max_{i\\in[l,r]}a_i-\\min_{i\\in[l,r]}a_i)∑l∈[l1​,r1​]​∑r∈[l2​,r2​]​(maxi∈[l,r]​ai​−mini∈[l,r]​ai​)。做法做法肯定和这篇题解一样，但我尝试说的更详细一点。conclusion1我会盯式子！因为max⁡−ai=−min⁡ai\\max-a_i=-\\mina_imax−ai​=−minai​，所以只要会求∑l∈[l1,r1]∑r∈[l2,r2]max⁡i∈[l,r]ai\\sum_{l\\in[l_1,r_1]}\\sum_{r\\in[l_2,r_2]}\\max_{i\\in[l,r]}a_i∑l∈[l1​,r1​]​∑r∈[l2​,r2​]​maxi∈[l,r]​ai​，然后将ai=−aia_i=-a_iai​=−ai​，再做一遍，两遍答案加起来就是要输出的结果。conclusion2我会前缀和差分！∑l∈[l1,r1]∑r∈[l2,r2]max⁡i∈[l,r]ai=∑l∈[l1,r1]∑r∈[1,r2]max⁡i∈[l,r]ai−∑l∈[l1,r1]∑r∈[1,l2−1]max⁡i∈[l,r]ai\\sum_{l\\in[l_1,r_1]}\\sum_{r\\in[l_2,r_2]}\\max_{i\\in[l,r]}a_i=\\sum_{l\\in[l_1,r_1]}\\sum_{r\\in[1,r_2]}\\max_{i\\in[l,r]}a_i-\\sum_{l\\in[l_1,r_1]}\\sum_{r\\in[1,l_2-1]}\\max_{i\\in[l,r]}a_i∑l∈[l1​,r1​]​∑r∈[l2​,r2​]​maxi∈[l,r]​ai​=∑l∈[l1​,r1​]​∑r∈[1,r2​]​maxi∈[l,r]​ai​−∑l∈[l1​,r1​]​∑r∈[1,l2​−1]​maxi∈[l,r]​ai​。也就是说设s(l,r,x)=∑i∈[l,r]∑j∈[1,x]max⁡k∈[i,j]aks(l,r,x)=\\sum_{i\\in[l,r]}\\sum_{j\\in[1,x]}\\max_{k\\in[i,j]}a_ks(l,r,x)=∑i∈[l,r]​∑j∈[1,x]​maxk∈[i,j]​ak​，答案可以变成s(l1,r1,r2)−s(l1,r1,l2−1)s(l1,r1,r2)-s(l1,r1,l2-1)s(l1,r1,r2)−s(l1,r1,l2−1)。现在只需会求s(l,r,x)s(l,r,x)s(l,r,x)即可。conclusion3我会扫描线！这个做法在线做好像非常复杂了，所以可以尝试用离线下来做。将所有的s(l,r,x)s(l,r,x)s(l,r,x)的询问挂在xxx上，设f(i,x)=∑j∈[i,x]max⁡k∈[i,j]akf(i,x)=\\sum_{j\\in[i,x]}\\max_{k\\in[i,j]}a_kf(i,x)=∑j∈[i,x]​maxk∈[i,j]​ak​，则s(l,r,x)=∑i∈[l,r]f(i,x)s(l,r,x)=\\sum_{i\\in[l,r]}f(i,x)s(l,r,x)=∑i∈[l,r]​f(i,x)。当x++x++x++时，f(i,x)+=max⁡j∈[i,x]ajf(i,x)+=\\max_{j\\in[i,x]}a_jf(i,x)+=maxj∈[i,x]​aj​，也就是当前的后缀[i,x][i,x][i,x]最大值。所以f(i,x)=max⁡[i,i]+max⁡[i,i+1]+...+max⁡[i,x]=∑j=ixmax[i,j]f(i,x)=\\max[i,i]+\\max[i,i+1]+...+\\max[i,x]=\\sum_{j=i}^xmax[i,j]f(i,x)=max[i,i]+max[i,i+1]+...+max[i,x]=∑j=ix​max[i,j]，也就是以iii为左端点的后缀最大值的历史版本和。所以s(l,r,x)s(l,r,x)s(l,r,x)为区间[l,r][l,r][l,r]的历史版本和之和。conclusion4我会beats+历史版本和（线段树3）！直接做就行了，使用beats进行区间取max，维护后缀最大值，线段树维护历史版本和，求s(l,r,x)s(l,r,x)s(l,r,x)时在线段树上区间修改，时间复杂度为O(n×log⁡22n)O(n\\times\\log_2^2n)O(n×log22​n)，瓶颈在使用beats进行区间取max。conclusion5我会单调栈！后缀[i,x][i,x][i,x]具有单调性，可以使用单调栈维护后缀最大值，来替换beats。由于每个位置只会入栈一次，所以复杂度为大常数的O(n×log⁡2n)O(n\\times\\log_2n)O(n×log2​n)，瓶颈在维护历史版本和与区间查询，维护历史版本和的常数较大。这里放一份_maojun_的代码。conclusion6我会观察性质！注意a数列是随机生成的。众所周知可以证明，在数据随机数列中，使用单调栈维护前缀/后缀min/max值，单调栈的大小期望为O(log⁡2n)O(\\log_2n)O(log2​n)。那就可以不使用常数较大的常规方式维护历史版本和了。对于当前一段后缀max相同的区间，区间内每个数对答案的贡献在目前都是相同的，对于每段区间维护一个时间戳，记录它是什么时候进入单调栈的。当这个区间被弹出时，在线段树上将这个区间的历史版本和更新。与传统的历史版本和不同的是，现在只有在当前点被弹出时才在线段树上维护历史版本和。依然在单调栈中的点可以O(1)O(1)O(1)计算贡献，而这种点又只有O(log⁡2n)O(\\log_2n)O(log2​n)种。所以就获得了一种只需要区间修改和区间查询的线段树的做法，相比之下常数更小，复杂度为O(n×log⁡2n)O(n\\times\\log_2n)O(n×log2​n)。可以将线段树改成zkw或超级树状数组。_maojun_使用了超级树状数组获得了最优解。ACCode#include&lt;bits/stdc++.h&gt;#definelllonglong#defineebemplace_back#definemem(arr,x)memset(arr,x,sizeof(arr))usingnamespacestd;constexprintmaxn=1e5+10;intn,q;lla[maxn];structnode{intl,r,k,id;};namespaceSegmentTree{#definelsp&lt;&lt;1#definersp&lt;&lt;1|1#definelsonls,l,mid#definersonrs,mid+1,r#defineall1,1,n#definesetposintp,intl,intr#definesetmidintmid=(l+r)&gt;&gt;1lltr[maxn&lt;&lt;2],tag[maxn&lt;&lt;2];inlinevoidpushup(intp){tr[p]=tr[ls]+tr[rs];}inlinevoidpushtag(setpos,lls){tr[p]+=(r-l+1)*s;tag[p]+=s;}inlinevoidpushdown(setpos){if(!tag[p])return;setmid;pushtag(lson,tag[p]);pushtag(rson,tag[p]);tag[p]=0;}voidupdate(setpos,intpl,intpr,lls){if(l&gt;=pl&amp;&amp;r&lt;=pr)returnpushtag(p,l,r,s);pushdown(p,l,r);setmid;if(pl&lt;=mid)update(lson,pl,pr,s);if(pr&gt;mid)update(rson,pl,pr,s);pushup(p);}llquery(setpos,intpl,intpr){if(l&gt;=pl&amp;&amp;r&lt;=pr)returntr[p];pushdown(p,l,r);setmid;llres=0;if(pl&lt;=mid)res=query(lson,pl,pr);if(pr&gt;mid)res+=query(rson,pl,pr);returnres;}}usingnamespaceSegmentTree;namespaceDataMaker{constintmod=1e9;longlongfst=1023,sec=1025;voidsolve(){for(inti=1;i&lt;=100000;i++){a[i]=fst^sec;fst=fst*1023%mod;sec=sec*1025%mod;}}}vector&lt;node&gt;v[maxn];llans[maxn];intstk[maxn],tp;voidsolve(){mem(tr,0);mem(tag,0);tp=0;for(inti=1;i&lt;=n;i++){while(tp&amp;&amp;a[stk[tp]]&lt;=a[i]){update(all,stk[tp-1]+1,stk[tp],1ll*(i-stk[tp])*a[stk[tp]]);tp--;}stk[++tp]=i;for(auto[l,r,k,id]:v[i]){llres=query(all,l,r);for(intj=1;j&lt;=tp;j++){intlen=min(stk[j],r)-max(stk[j-1],l-1);if(len&lt;=0)continue;res+=1ll*len*(i-stk[j]+1)*a[stk[j]];}ans[id]+=(res*k);}}}signedmain(){scanf(&quot;%d&quot;,&amp;q);n=1e5;DataMaker::solve();for(inti=1,l1,r1,l2,r2;i&lt;=q;i++){scanf(&quot;%d%d%d%d&quot;,&amp;l1,&amp;r1,&amp;l2,&amp;r2);v[r2].eb(l1,r1,1,i);v[l2-1].eb(l1,r1,-1,i);}solve();for(inti=1;i&lt;=n;i++)a[i]*=-1;solve();for(inti=1;i&lt;=q;i++)printf(&quot;%lld\\n&quot;,ans[i]);}总结基于数组随机可以获得小常数的O(n×log⁡2n)O(n\\times\\log_2n)O(n×log2​n)，不基于数组随机可以获得历史版本和做法的O(n×log⁡2n)O(n\\times\\log_2n)O(n×log2​n)。感谢_maojun_的帮助，同时大力推荐他的题解。*文中部分引用了他人的代码和提交记录，如有侵权行为，请及时私信博主，我会依法进行更改或删除。","link":"https://yaohaoyou.github.io/post/p10637-solution/"},{"title":"P4897 【模板】最小割树（Gomory-Hu Tree） ","content":"题目传送器更爽的阅读体验题意给一个无向连通图，询问两点之间需要割掉多少边权能使两点不连通。做法因为连通性是可传递的，所以可以使用分治。由于无向图两点间最小割===最大流，所以使用网络最大流求最小割。对于当前处理需要处理的点集sss，随意选两个点uuu和vvv跑一次网络最大流，设最大流为maxflowmaxflowmaxflow，则在最小割树上建一条(u,v,maxflow)(u,v,maxflow)(u,v,maxflow)边。设割掉满流的边后uuu能遍历到的点集为s1s1s1，剩下的点集s2=∁ss1s2=\\complement_ss1s2=∁s​s1。往下递归处理s1s1s1和s2s2s2即可。求s1s1s1可以找最后一次dinic的bfs遍历到的点。现在已经建出了最小割树，考虑如何使用。当断掉一条边后，会花费当前边权的代价，将原树树断成两颗新树，这两棵新树上的点两两互相不连通。那对于求(u,v)(u,v)(u,v)的最小割，只要断掉树上(u,lca(u,v))(u,lca(u,v))(u,lca(u,v))和(lca(u,v),v)(lca(u,v),v)(lca(u,v),v)这两条链中最小的一条边即可。可以使用倍增维护边权最小值。ACCode#include&lt;bits/stdc++.h&gt;#definepiipair&lt;int,int&gt;#definepiiipair&lt;int,pii&gt;#defineebemplace_backusingnamespacestd;constintmaxn=1e5+10;constintmaxm=maxn*100;intn,m;structTree{intcnt=1;inthead[maxn];structedge{intnxt,to,w;}e[maxm];inlinevoidadd(intu,intv,intw){e[++cnt]={head[u],v,w};head[u]=cnt;}}Tr;namespaceGraph{piiig[maxn];intcnt=1;inthead[maxn];structedge{intnxt,to,w;}e[maxm];inlinevoidadd(intu,intv,intw){e[++cnt]={head[u],v,w};head[u]=cnt;}inlinevoidrebuild(){cnt=1;memset(head,0,sizeof(head));for(inti=1;i&lt;=m;i++){add(g[i].first,g[i].second.first,g[i].second.second);add(g[i].second.first,g[i].first,g[i].second.second);}}}usingnamespaceGraph;intS,T;namespaceDINIC{constintinf=0x3f3f3f3f;intd[maxn],now[maxn];queue&lt;int&gt;q;inlineboolbfs(){while(!q.empty())q.pop();memset(d,0x3f,sizeof(d));memcpy(now,head,sizeof(head));d[S]=0;q.push(S);while(!q.empty()){intu=q.front();q.pop();for(inti=head[u];i;i=e[i].nxt){intt=e[i].to;if(d[t]!=inf||!e[i].w)continue;d[t]=d[u]+1;q.push(t);if(t==T)returntrue;}}returnfalse;}intdfs(intu,intflw){if(u==T)returnflw;intres=0;for(inti=now[u];i&amp;&amp;flw;i=e[i].nxt){now[u]=i;intt=e[i].to;if(d[t]!=d[u]+1||!e[i].w)continue;intk=dfs(t,min(e[i].w,flw));if(!k)d[t]=inf;e[i].w-=k;e[i^1].w+=k;res+=k;flw-=k;}returnres;}inlineintdinic(){rebuild();intres=0;while(bfs())res+=dfs(S,inf);returnres;}}usingnamespaceDINIC;namespaceDFS{intw[20][maxn],f[20][maxn],dep[maxn];voiddfs(intu,intfa){dep[u]=dep[f[0][u]=fa]+1;w[0][u]=inf;for(inti=Tr.head[u];i;i=Tr.e[i].nxt){intt=Tr.e[i].to;if(t==fa)continue;dfs(t,u);w[0][t]=Tr.e[i].w;}}inlinevoidinit_LCA(){for(inti=1;i&lt;=19;i++)for(intj=1;j&lt;=n;j++){w[i][j]=min(w[i-1][j],w[i-1][f[i-1][j]]);f[i][j]=f[i-1][f[i-1][j]];}}inlineintLCA(intx,inty){//O(nlogn)-O(logn)倍增intres=inf;if(dep[x]&lt;dep[y])swap(x,y);for(inti=19;~i;i--){if(dep[f[i][x]]&gt;=dep[y]){res=min(res,w[i][x]);x=f[i][x];}}if(x==y)returnres;for(inti=19;~i;i--){if(f[i][x]^f[i][y]){res=min(res,w[i][x]);res=min(res,w[i][y]);x=f[i][x];y=f[i][y];}}res=min(res,w[0][x]);res=min(res,w[0][y]);returnres;}}vector&lt;int&gt;v,v1,v2;voiddivide(intl,intr){v1.clear();v2.clear();if(l&gt;=r)return;S=v[l];T=v[l+1];intres=dinic();Tr.add(S,T,res);Tr.add(T,S,res);for(inti=l;i&lt;=r;i++){if(d[v[i]]!=inf)v1.eb(v[i]);elsev2.eb(v[i]);}for(inti=0;i&lt;v1.size();i++)v[i+l]=v1[i];for(inti=0;i&lt;v2.size();i++)v[i+l+v1.size()]=v2[i];intsiz=v1.size();divide(l,l+siz-1);divide(l+siz,r);}intmain(){scanf(&quot;%d%d&quot;,&amp;n,&amp;m);for(inti=1,u,v;i&lt;=m;i++){scanf(&quot;%d%d%d&quot;,&amp;g[i].first,&amp;g[i].second.first,&amp;g[i].second.second);}for(inti=0;i&lt;=n;i++)v.eb(i);divide(0,n);DFS::dfs(1,0);DFS::init_LCA();intq;scanf(&quot;%d&quot;,&amp;q);while(q--){intu,v;scanf(&quot;%d%d&quot;,&amp;u,&amp;v);printf(&quot;%d\\n&quot;,DFS::LCA(u,v));}}总结时间复杂度为O(n×D)O(n\\timesD)O(n×D)，O(D)O(D)O(D)是dinic的时间复杂度，理论是O(n2×m)O(n^2\\timesm)O(n2×m)，但实际上小很多。","link":"https://yaohaoyou.github.io/post/p4897-solution/"},{"title":"鲜花1","content":"2024/7/3LG粉丝破100了。所以到底有没有人看我的博客啊。。。如果有人能不能在这下面发条评论或给我LG私信。。。aboutme","link":"https://yaohaoyou.github.io/post/flower1/"},{"title":"做题记录","content":"P5354[Ynoi2017]由乃的OJAbstractYnoi.不难想到可以先使用树剖维护这个东西。由于每一个二进制位是互相独立的，所以可以记录当前位是0/1在当前区间从左到右或从右到左后能否成为1。可以开k棵线段树维护，复杂度O(n×log⁡22n×k)O(n\\times\\log_2^2n\\timesk)O(n×log22​n×k)。仔细观察pushup，可以将k棵压成一颗，记录当前区间从左往右或从右往左后的。AT_agc027_e[AGC027E]ABBreviate证明题？将a-&gt;1，b-&gt;2，则mod3\\bmod3mod3结果不变。p(s)=∑(si−a+1)mod3p(s)=\\sum(s_i-a+1)\\bmod3p(s)=∑(si​−a+1)mod3。结论（不会证明）：s变成字符c的充要条件是p(s)=p(c)p(s)=p(c)p(s)=p(c)且s有相邻FDSA相同（即不为ababa...或babab..）。前面贪心匹配，注意最后剩下的p值为000。dp即可。使用刷表发，dpidp_idpi​表示前iii个数的答案，每次在当前序列末尾加上一个a或b，注意加答案时要保证剩下的p值为0。ai=p(s[1,i])a_i=p(s[1,i])ai​=p(s[1,i])。dpnxti+1,(ai+1/2)mod3+=dpidp_{nxt_{i+1,(a_i+1/2)\\bmod3}}+=dp_idpnxti+1,(ai​+1/2)mod3​​+=dpi​CF1267HHelpBerLineCF3200《面对做法构造题目》奇妙构造+奇妙证明？考虑这件事情有一个明显的必要条件是：任何时刻相邻两个亮着的灯必须颜色不同。对于时间到这枚举，可以使用set维护前驱和后继，当i=coli=coli=col时，lsti=collst_i\\not=collsti​​=col，nxti=colnxt_i\\not=colnxti​​=col。cyz说可以归纳证明这也是充要条件。也可以证明，colcolcol的范围是log⁡32N\\log_{\\frac{3}{2}}Nlog23​​N。然后就做完了。。。P3233[HNOI2014]世界树码量虚树，为何不改？∑m≤3×105\\summ\\le3\\times10^5∑m≤3×105套路建虚树，暴力是好做的，思考如何在虚树上做。答案=为在虚树上的点的贡献+不在虚树上的点的贡献。设距离节点iii最近的关键节点为p(i)p(i)p(i)。在虚树上的点​两遍dfs可以求出虚树上距离当前点最近的关键点，贡献直接加就可以了。不在虚树上的点xxx​Ⅰxxx在虚树节点yyy的子树并且这个子树中没有关键点。​p(x)=p(y)p(x)=p(y)p(x)=p(y)。直接统计即可​Ⅱxxx在虚树节点uuu和vvv这条链上。​①p(u)=p(v)p(u)=p(v)p(u)=p(v)。则p(x)=p(u)p(x)=p(u)p(x)=p(u)，直接统计即可。​②p(u)=p(v)p(u)\\not=p(v)p(u)​=p(v)。二分出这条链上的ppp的断点qqq，则分开统计两条链即可。复杂度是O(∑m×log⁡2n)O(\\summ\\times\\log_2n)O(∑m×log2​n)。AT_agc048_d[AGC048D]PockyGame又是证明题？自行模拟或证明：只可能有两种操作，取111个石子或取111堆石子。fl,rf_{l,r}fl,r​为[l+1,r][l+1,r][l+1,r]没动，让Firstleft赢，ala_lal​的最小值。gl,rg_{l,r}gl,r​为[l,r−1][l,r-1][l,r−1]没动，让Secondrigtht赢，ara_rar​的最小值。若a1&lt;f1,na_1&lt;f_{1,n}a1​&lt;f1,n​，则Secondright赢，否则Firstleft赢。","link":"https://yaohaoyou.github.io/post/problems-solution/"},{"title":"AT_abc356_e Max/Min","content":"题目传送器更爽的阅读体验AT1506前言赛时小丑以为写假了，遂写篇题解。我不强，我不知道调和级数，但我会根号做法。题意求∑i=1N−1∑j=i+1N⌊max⁡(Ai,Aj)min⁡(Ai,Aj)⌋\\sum_{i=1}^{N-1}\\sum_{j=i+1}^{N}\\left\\lfloor\\frac{\\max(A_i,A_j)}{\\min(A_i,A_j)}\\right\\rfloor∑i=1N−1​∑j=i+1N​⌊min(Ai​,Aj​)max(Ai​,Aj​)​⌋。做法显然可以先将A从小到大排序，然后答案就变成了∑i=2N∑j=1i−1⌊AiAj⌋\\sum_{i=2}^{N}\\sum_{j=1}^{i-1}\\left\\lfloor\\frac{A_i}{A_j}\\right\\rfloor∑i=2N​∑j=1i−1​⌊Aj​Ai​​⌋。然后这就是一个经典的整除分块。具体的，先枚举AiA_iAi​，那此时⌊AiAj⌋\\left\\lfloor\\frac{A_i}{A_j}\\right\\rfloor⌊Aj​Ai​​⌋的答案只有O(V)O(\\sqrtV)O(V​)种。对于当前的k=⌊AiAj⌋k=\\left\\lfloor\\frac{A_i}{A_j}\\right\\rfloork=⌊Aj​Ai​​⌋，可以求出⌊AiAnxt⌋=k\\left\\lfloor\\frac{A_i}{A_{nxt}}\\right\\rfloor=k⌊Anxt​Ai​​⌋=k的另一个边界nxtnxtnxt，然后直接跳到nxt−1nxt-1nxt−1即可。由于kkk的取值只有O(V)O(\\sqrtV)O(V​)种，找到nxtnxtnxt的过程可以使用二分答案，于是复杂度就是O(n×V×log⁡2n)O(n\\times\\sqrtV\\times\\log_2n)O(n×V​×log2​n)。放个代码。赛时代码比较丑，二分答案就不要细看了。Code然而这样是需要在2s内跑4×1094\\times10^94×109的。明显会TLE。思考如何优化。发现整除分块不好优化，所以尝试将log⁡2n\\log_2nlog2​n优化掉。发现二分答案的值域只有O(V)O(V)O(V)，所以可以开一个数组提前预处理。时间复杂度为O(n×V+V×log⁡2n)O(n\\times\\sqrtV+V\\times\\log_2n)O(n×V​+V×log2​n)。ACCode总结时间复杂度为O(n×V+V×log⁡2n)O(n\\times\\sqrtV+V\\times\\log_2n)O(n×V​+V×log2​n)，相比其他做法的却劣了不少，需要1600ms+。赛时真是小丑，同时感谢_maojun_。","link":"https://yaohaoyou.github.io/post/AT_abc356_e/"},{"title":"P10271 漫长悄悄话","content":"题目传送器更爽的阅读体验前言为什么都用PAM和子序列自动机，我会二分答案+manacher+Hash。题意自行看题。做法推一下式子即可，preipre_iprei​表示iii的前缀。Rev(lcs(i,j))=LCP(Rev(prei),Rev(prej))Rev(lcs(i,j))=LCP(Rev(pre_i),Rev(pre_j))Rev(lcs(i,j))=LCP(Rev(prei​),Rev(prej​))手模一下样例就能发现其实就是求以iii为中心的回文半径和以jjj为中心的回文半径的LCP\\text{LCP}LCP。显然答案是有二分性的，可以二分答案xxx后将每个位置iii对应的[i−x+1,i][i-x+1,i][i−x+1,i]的哈希值放入map或unordered_map中，只要有相同的就返回true。manacher只需要跑以当前点为中心的回文串即可，不用在相邻两位加入字符。ACCode#include&lt;bits/stdc++.h&gt;#defineullunsignedlonglongusingnamespacestd;constintmaxn=1e6+10,base=31;intn,p[maxn];ullhsh[maxn],bs[maxn];strings;unordered_map&lt;ull,bool&gt;mp;//记录是否出现过的哈希值inlineullHash(intl,intr){returnhsh[r]-hsh[l-1]*bs[r-l+1];}inlineboolcheck(intx){mp.clear();for(inti=1;i&lt;=n;i++){if(p[i]&lt;x)continue;if(mp[Hash(i-x+1,i)])returntrue;mp[Hash(i-x+1,i)]=true;}returnfalse;}intmain(){ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);cin&gt;&gt;n&gt;&gt;s;s='|'+s+'#';bs[0]=1;for(inti=1;i&lt;=n;i++){hsh[i]=hsh[i-1]*base+(s[i]-'a');bs[i]=bs[i-1]*base;}//manacherfor(inti=1,mid=0,r=0;i&lt;=n;i++){p[i]=i&gt;r?1:min(p[(mid&lt;&lt;1)-i],r-i+1);while(s[i+p[i]]==s[i-p[i]])p[i]++;if(i+p[i]&gt;r){r=i+p[i]-1;mid=i;}}//二分答案intl=1,r=n,ans=0;while(l&lt;=r){intmid=(l+r)&gt;&gt;1;if(check(mid)){ans=mid;l=mid+1;}elser=mid-1;}printf(&quot;%d\\n&quot;,ans);}总结&amp;乱搞时间复杂度为O(n×log⁡2n)O(n\\times\\log_2n)O(n×log2​n)，跑得还挺快。实测不使用哈希，直接将字符串区间放入unordered_map，也就是O(n2×log⁡2n)O(n^2\\times\\log_2n)O(n2×log2​n)也能过，只用300+ms。","link":"https://yaohaoyou.github.io/post/p10271/"},{"title":"关于","content":"欢迎来到我的小站呀，很遇见你！🤝高兴🏠关于本站yaohaoyou\\texttt{yaohaoyou}yaohaoyou的博客👨‍💻博主是谁GD的OI选手，快来爆踩。📬联系我呀LG:739274","link":"https://yaohaoyou.github.io/post/about-me/"}]}